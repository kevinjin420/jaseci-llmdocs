useState(initialState): [currentState, setStateFunction]. Hook for function components to declare state variables. Returns current state and function to update it. Example: const [count, setCount] = useState(0); Passing Functions to Components: Pass event handlers as props to child components. Binding: Use bind in constructor, class properties (experimental), or arrow functions in render to ensure functions have access to component attributes. Avoid calling functions in render; pass references. Parameter Passing: Use arrow functions or bind to pass parameters to event handlers. Rate Limiting: Use throttling, debouncing (lodash), or requestAnimationFrame to control function execution frequency. Hooks: Enable state and React features in function components. useState: const [state, setState] = useState(initialState). Returns stateful value and function to update it. setState enqueues re-render. Functional updates: setState(prevState => newState). Lazy init: useState(() => initialState). useEffect(didUpdate, [dependencies]): Executes code after render. Can return cleanup function. Default: runs after every render. Conditional: runs when dependencies change. useEffect(() => {}, []): runs once (mount/unmount). useContext(MyContext): Returns context value for context object. Triggers re-render on context change. useReducer(reducer, initialArg, init): Alternative to useState. Returns state and dispatch method. Lazy init: useReducer(reducer, initialArg, init). useCallback(() => {doSomething(a, b)}, [a, b]): Returns memoized callback. Changes only if dependencies change. useMemo(() => computeExpensiveValue(a, b), [a, b]): Returns memoized value. Recomputes only when dependencies change. useRef(initialValue): Returns mutable ref object (.current property). Persists for component lifetime. useImperativeHandle(ref, createHandle, [deps]): Customizes instance value exposed to parent components with ref. Requires forwardRef. useLayoutEffect: Like useEffect, but synchronous after DOM mutations. Use for reading layout and re-rendering. useDebugValue(value, formatter): Displays label for custom hooks in React DevTools. Forms: Controlled components use React state as single source of truth for form values. NameForm: class component, state:{value:string}, handleChange(event), handleSubmit(event), render(): form with text input. EssayForm: class component, state:{value:string}, handleChange(event), handleSubmit(event), render(): form with textarea. FlavorForm: class component, state:{value:string}, handleChange(event), handleSubmit(event), render(): form with select. Reservation: class component, state:{isGoing:boolean, numberOfGuests:number}, handleInputChange(event), render(): form with checkbox and number input. useEffect(effect, [dependencies]): Performs side effects in function components after render. Replaces componentDidMount, componentDidUpdate, componentWillUnmount. useEffect(() => { document.title = `You clicked ${count} times`; }, [count]); effect: Function containing side effect logic. dependencies: Optional array of dependency values. Effect runs if dependencies change. Empty array [] runs effect only on mount/unmount. If deps are omitted, effect runs after every render. Returning a function from effect cleans up after it. React cleans up previous render effects before running next effects. Use multiple useEffect calls to separate concerns. useLayoutEffect: Synchronous API identical to useEffect, blocks browser updates. Hooks (React 16.8+): functions for state/features in function components. useState(initialState): state/setter. useEffect(effectFn, dependencies?): side effects, cleanup. Rules: top level calls, in function components/custom hooks. Custom Hooks: reuse logic ("use" prefix). useContext, useReducer: other built-in Hooks. React: Entry point to the React library. Components: React.Component: Base class for React components. class Greeting extends React.Component { render() { return <h1>Hello, {this.props.name}</h1>; } } React.PureComponent: Implements shouldComponentUpdate() with shallow prop/state comparison. React.memo: HOC, memoizes result, skips rendering if props are the same. React.memo(MyComponent, areEqual); Creating Elements: createElement(type, [props], [...children]): Creates React element. cloneElement(element, [config], [...children]): Clones element, shallowly merges props. createFactory(type): Returns function that produces React elements. Legacy. Transforming Elements: isValidElement(object): Checks if object is a React element. React.Children: map(children, function[(thisArg)]), forEach(children, function[(thisArg)]), count(children), only(children), toArray(children) React.Fragment: Returns multiple elements without wrapper. <></> Refs: createRef(): Creates ref. forwardRef(fn): Forwards ref to child component. const FancyButton = React.forwardRef((props, ref) => (<button ref={ref}>{props.children}</button>)); Suspense: lazy(import): Loads components dynamically. <React.Suspense fallback={<Spinner />}><OtherComponent /></React.Suspense> Hooks: useState, useEffect, useContext, useReducer, useCallback, useMemo, useRef, useImperativeHandle, useLayoutEffect, useDebugValue React.Component: Define components as classes. Required method: render(). Lifecycle methods (optional): Mounting: constructor(), static getDerivedStateFromProps(), render(), componentDidMount(). Updating: static getDerivedStateFromProps(), shouldComponentUpdate(), render(), getSnapshotBeforeUpdate(), componentDidUpdate(). Unmounting: componentWillUnmount(). Error Handling: static getDerivedStateFromError(), componentDidCatch(). Other APIs: setState(), forceUpdate(). Class Properties: defaultProps, displayName. Instance Properties: props, state. render(): Returns React elements, arrays, fragments, portals, strings, numbers, booleans, or null. Should be pure. constructor(props): Called before mounting. Call super(props) first. Used for initializing state and binding event handlers. Do not call setState() here. componentDidMount(): Called after component is mounted. Use to set up subscriptions or load data. Can call setState() immediately. componentDidUpdate(prevProps, prevState, snapshot): Called after updating. Use to operate on the DOM and make network requests. Can call setState() conditionally. componentWillUnmount(): Called before unmounting. Perform cleanup here. Do not call setState(). shouldComponentUpdate(nextProps, nextState): Optimizes re-rendering; defaults to true. Not called for initial render or forceUpdate(). Return false to skip update. Avoid deep equality checks. static getDerivedStateFromProps(props, state): Returns an object to update state or null. Invoked before render on mount and updates. getSnapshotBeforeUpdate(prevProps, prevState): Captures DOM info before potential changes. Returns a value passed to componentDidUpdate(). Error Boundaries: static getDerivedStateFromError(error): Returns state to update on error. Called during render phase. componentDidCatch(error, info): Logs errors. Called during commit phase. Legacy Lifecycle Methods: UNSAFE_componentWillMount(), UNSAFE_componentWillReceiveProps(nextProps), UNSAFE_componentWillUpdate(nextProps, nextState). setState(updater, [callback]): Enqueues state changes. Asynchronous. Updater function: (state, props) => stateChange. callback executed after update. setState(stateChange[, callback]): Shallow merge. forceUpdate(callback): Forces re-render, skipping shouldComponentUpdate(). defaultProps: Default prop values for the class. displayName: For debugging messages. props: Props from the caller. state: Component-specific data that can change over time. Do not mutate this.state directly. Context API: Share data through component tree without prop drilling. React.createContext(defaultValue): Creates Context object. Context.Provider: Component to provide context value. Props: value. Class.contextType = MyContext: Consume context in classes via this.context. Context.Consumer: Consume context in functions with render prop, child function (value => ReactNode). Context.displayName: For DevTools display. ReactDOM provides DOM-specific methods. render(element, container, callback): Renders a React element into the DOM. hydrate(element, container, callback): Renders a container whose HTML contents were rendered by ReactDOMServer. unmountComponentAtNode(container): Removes a mounted React component from the DOM. Returns boolean. findDOMNode(component): Returns the native browser DOM element. createPortal(child, container): Creates a portal. TestRenderer: Renders React components to pure JavaScript objects. TestRenderer.create(element, options): Creates TestRenderer instance. Returns instance. options: createNodeMock. TestRenderer.act(callback): Prepares component for assertions. Wraps create and update calls. testRenderer.toJSON(): Returns object representing rendered tree (platform-specific nodes/props). testRenderer.toTree(): Returns object representing rendered tree (includes user-written components). testRenderer.update(element): Re-renders in-memory tree. Simulates React update. testRenderer.unmount(): Unmounts in-memory tree. testRenderer.getInstance(): Returns root element instance, if available. testRenderer.root: Returns root "test instance" object. testInstance.find(test): Finds single descendant test instance where test(testInstance) is true. Throws if not exactly one. testInstance.findByType(type): Finds single descendant test instance with type. Throws if not exactly one. testInstance.findByProps(props): Finds single descendant test instance with props. Throws if not exactly one. testInstance.findAll(test): Finds all descendant test instances where test(testInstance) is true. testInstance.findAllByType(type): Finds all descendant test instances with type. testInstance.findAllByProps(props): Finds all descendant test instances with props. testInstance.instance: Component instance for class components. testInstance.type: Component type. testInstance.props: Component props. testInstance.parent: Parent test instance. testInstance.children: Children test instances. SyntheticEvent: A cross-browser wrapper around the browser's native event. stopPropagation(): void, preventDefault(): void, persist(): void Attributes: bubbles: boolean, cancelable: boolean, currentTarget: DOMEventTarget, defaultPrevented: boolean, eventPhase: number, isTrusted: boolean, nativeEvent: DOMEvent, target: DOMEventTarget, timeStamp: number, type: string Supported Events: Clipboard Events: onCopy, onCut, onPaste. Properties: clipboardData: DOMDataTransfer Composition Events: onCompositionEnd, onCompositionStart, onCompositionUpdate. Properties: data: string Keyboard Events: onKeyDown, onKeyPress, onKeyUp. Properties: altKey: boolean, charCode: number, ctrlKey: boolean, getModifierState(key): string, key: string, keyCode: number, locale: string, location: number, metaKey: boolean, repeat: boolean, shiftKey: boolean, which: number Focus Events: onFocus, onBlur. Properties: relatedTarget: DOMEventTarget Form Events: onChange, onInput, onInvalid, onReset, onSubmit Generic Events: onError, onLoad Mouse Events: onClick, onContextMenu, onDoubleClick, onDrag, onDragEnd, onDragEnter, onDragExit, onDragLeave, onDragOver, onDragStart, onDrop, onMouseDown, onMouseEnter, onMouseLeave, onMouseMove, onMouseOut, onMouseOver, onMouseUp. Properties: altKey: boolean, button: number, buttons: number, clientX: number, clientY: number, ctrlKey: boolean, getModifierState(key): boolean, metaKey: boolean, pageX: number, pageY: number, relatedTarget: DOMEventTarget, screenX: number, screenY: number, shiftKey: boolean Pointer Events: onPointerDown, onPointerMove, onPointerUp, onPointerCancel, onGotPointerCapture, onLostPointerCapture, onPointerEnter, onPointerLeave, onPointerOver, onPointerOut. Extends Mouse Events. Properties: pointerId: number, width: number, height: number, pressure: number, tangentialPressure: number, tiltX: number, tiltY: number, twist: number, pointerType: string, isPrimary: boolean Selection Events: onSelect Touch Events: onTouchCancel, onTouchEnd, onTouchMove, onTouchStart. Properties: altKey: boolean, changedTouches: DOMTouchList, ctrlKey: boolean, getModifierState(key): boolean, metaKey: boolean, shiftKey: boolean, targetTouches: DOMTouchList, touches: DOMTouchList UI Events: onScroll. Properties: detail: number, view: DOMAbstractView Wheel Events: onWheel. Properties: deltaMode: number, deltaX: number, deltaY: number, deltaZ: number Media Events: onAbort, onCanPlay, onCanPlayThrough, onDurationChange, onEmptied, onEncrypted, onEnded, onError, onLoadedData, onLoadedMetadata, onLoadStart, onPause, onPlay, onPlaying, onProgress, onRateChange, onSeeked, onSeeking, onStalled, onSuspend, onTimeUpdate, onVolumeChange, onWaiting Image Events: onLoad, onError Animation Events: onAnimationStart, onAnimationEnd, onAnimationIteration. Properties: animationName: string, pseudoElement: string, elapsedTime: float Transition Events: onTransitionEnd. Properties: propertyName: string, pseudoElement: string, elapsedTime: float Other Events: onToggle Hooks FAQ. Hooks in React 16.8+ for state and features without classes. No class rewrite needed, use Hooks in new code. Hooks for component logic reuse. Hooks use existing React concepts. Classes and Hooks can be mixed. Hooks aim to cover class use cases, some not yet. Hooks simpler than render props/HOCs. Redux connect(), React Router work with Hooks. Hooks work with static typing. Test Hooks components like regular ones. ESLint plugin enforces Hook rules. Lifecycle to Hooks: constructor->useState, getDerivedStateFromProps->render update, shouldComponentUpdate->React.memo, render->function body, componentDidMount/Update/WillUnmount->useEffect. Data fetch with Hooks. useRef() for instance variables. useState for state. Effects run after render useEffect(callback, [dependencies]). Dependency array for effect updates, [] for mount only. useCallback for memoized callbacks. useMemo for memoized values. useReducer for state management. Context for prop drilling alternative. Hooks optimized, closures efficient, useCallback, useMemo for perf. useEventCallback (advanced) for event handlers. Hooks internals: memory cells. Hooks prior art: functional APIs, render props, algebraic effects.