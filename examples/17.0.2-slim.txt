useState(initialState): [currentState, setStateFunction]. Hook for function components to declare state variables. Returns current state and function to update it. Example: const [count, setCount] = useState(0); Passing Functions to Components: Pass event handlers as props to child components. Binding: Use bind in constructor, class properties (experimental), or arrow functions in render to ensure functions have access to component attributes. Avoid calling functions in render; pass references. Parameter Passing: Use arrow functions or bind to pass parameters to event handlers. Rate Limiting: Use throttling, debouncing (lodash), or requestAnimationFrame to control function execution frequency. Hooks: Enable state and React features in function components. useState: const [state, setState] = useState(initialState). Returns stateful value and function to update it. setState enqueues re-render. Functional updates: setState(prevState => newState). Lazy init: useState(() => initialState). useEffect(didUpdate, [dependencies]): Executes code after render. Can return cleanup function. Default: runs after every render. Conditional: runs when dependencies change. useEffect(() => {}, []): runs once (mount/unmount). useContext(MyContext): Returns context value for context object. Triggers re-render on context change. useReducer(reducer, initialArg, init): Alternative to useState. Returns state and dispatch method. Lazy init: useReducer(reducer, initialArg, init). useCallback(() => {doSomething(a, b)}, [a, b]): Returns memoized callback. Changes only if dependencies change. useMemo(() => computeExpensiveValue(a, b), [a, b]): Returns memoized value. Recomputes only when dependencies change. useRef(initialValue): Returns mutable ref object (.current property). Persists for component lifetime. useImperativeHandle(ref, createHandle, [deps]): Customizes instance value exposed to parent components with ref. Requires forwardRef. useLayoutEffect: Like useEffect, but synchronous after DOM mutations. Use for reading layout and re-rendering. useDebugValue(value, formatter): Displays label for custom hooks in React DevTools. Forms: Controlled components use React state as single source of truth for form values. NameForm: class component, state:{value:string}, handleChange(event), handleSubmit(event), render(): form with text input. EssayForm: class component, state:{value:string}, handleChange(event), handleSubmit(event), render(): form with textarea. FlavorForm: class component, state:{value:string}, handleChange(event), handleSubmit(event), render(): form with select. Reservation: class component, state:{isGoing:boolean, numberOfGuests:number}, handleInputChange(event), render(): form with checkbox and number input. useEffect(effect, [dependencies]): Performs side effects in function components after render. Replaces componentDidMount, componentDidUpdate, componentWillUnmount. useEffect(() => { document.title = `You clicked ${count} times`; }, [count]); effect: Function containing side effect logic. dependencies: Optional array of dependency values. Effect runs if dependencies change. Empty array [] runs effect only on mount/unmount. If deps are omitted, effect runs after every render. Returning a function from effect cleans up after it. React cleans up previous render effects before running next effects. Use multiple useEffect calls to separate concerns. useLayoutEffect: Synchronous API identical to useEffect, blocks browser updates. Hooks (React 16.8+): functions for state/features in function components. useState(initialState): state/setter. useEffect(effectFn, dependencies?): side effects, cleanup. Rules: top level calls, in function components/custom hooks. Custom Hooks: reuse logic ("use" prefix). useContext, useReducer: other built-in Hooks. React: Entry point to the React library. Components: React.Component: Base class for React components. class Greeting extends React.Component { render() { return <h1>Hello, {this.props.name}</h1>; } } React.PureComponent: Implements shouldComponentUpdate() with shallow prop/state comparison. React.memo: HOC, memoizes result, skips rendering if props are the same. React.memo(MyComponent, areEqual); Creating Elements: createElement(type, [props], [...children]): Creates React element. cloneElement(element, [config], [...children]): Clones element, shallowly merges props. createFactory(type): Returns function that produces React elements. Legacy. Transforming Elements: isValidElement(object): Checks if object is a React element. React.Children: map(children, function[(thisArg)]), forEach(children, function[(thisArg)]), count(children), only(children), toArray(children) React.Fragment: Returns multiple elements without wrapper. <></> Refs: createRef(): Creates ref. forwardRef(fn): Forwards ref to child component. const FancyButton = React.forwardRef((props, ref) => (<button ref={ref}>{props.children}</button>)); Suspense: lazy(import): Loads components dynamically. <React.Suspense fallback={<Spinner />}><OtherComponent /></React.Suspense> Hooks: useState, useEffect, useContext, useReducer, useCallback, useMemo, useRef, useImperativeHandle, useLayoutEffect, useDebugValue