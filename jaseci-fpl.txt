Jac Programming Language: Entry point: with entry { }. Comments: # single line, #* multi-line *#. Statements end with semicolons. Blocks use curly braces {}. Variables: name = value. Type annotations: name: type = value. Types: str (string), int (integer), float (decimal), bool (True/False). String formatting: f"{variable}". Math operators: +, -, *, / (division), % (modulo), ** (exponent). Shortcuts: +=, -=, *=, /=. Comparison: >, <, >=, <=, == (equal), != (not equal). Logical: and, or, not. Control flow: if condition { } elif condition { } else { }. Loops: while condition { }. For counting: for i = start to i < end by i += step { }. For iteration: for item in collection { }. Loop control: break (exit loop), continue (skip iteration). Functions: def name(param: type) -> return_type { return value; }. Default params: param: type = default. Call: name(args) or name(param=value). Collections - Lists: [item1, item2]. Access: list[index] (0-based, negative from end). Methods: append(item), insert(index, item), remove(item), pop(index). Length: len(list). Concatenation: list1 + list2. Repetition: [item] * n. Membership: item in list. Slicing: list[start:end], list[start:end:step]. Comprehension: [expression for item in iterable if condition]. Dictionaries: {key: value, ...}. Access: dict[key]. Loop: for key in dict { }. Tuples: (item1, item2). Immutable. Unpack: (x, y) = tuple. Classes: obj ClassName { has property: type = default; def method { self.property; } }. Create: obj = ClassName(property=value). Inheritance: obj Child(Parent) { }. Override methods by redefining. postinit: runs after initialization. Object-Spatial Programming (OSP): Three types: node (data locations), edge (relationships), walker (mobile computation). Nodes: node NodeName { has property: type; }. Create: node_var = NodeName(property=value). Connect nodes: node1 ++> node2 (forward), node1 <++ node2 (backward), node1 <++> node2 (bidirectional). Edges: edge EdgeName { has property: type; }. Typed connection: node1 +>:EdgeName(property=value):+> node2. Query connections: [node -->] (outgoing), [node <--] (incoming), [node <-->] (both). Filter by type: [node ->:EdgeName:->]. Filter by property: [node ->:EdgeName:property condition:->]. Multi-hop: [node --> -->]. Walkers: walker WalkerName { has property: type; can ability_name with NodeType entry { } }. Abilities trigger when walker visits matching node type. Special abilities: with `root entry (start at root), with NodeType entry (visit NodeType), with exit (walker done). Special references: here (current node), self (walker/node itself), visitor (walker visiting node). visit statement: visit [edge_ref] navigates walker. visit [-->] visits all outgoing connections. Spawn walker: node spawn WalkerName(params) or root spawn WalkerName(). report value: streams values back (continues execution). return value: returns and stops. disengage: stops walker immediately. Bidirectional polymorphism: both nodes and walkers can have abilities for each other. Node ability: can ability_name with WalkerType entry { }. Walker ability: can ability_name with NodeType entry { }. Both execute on interaction. Connection operators build graph: ++>, <++, <++>. Edge references query graph: [-->], [<--], [<-->]. root: implicit root node, starting point for graphs. Pattern: Build graph structure (nodes + edges), spawn walker at entry point, walker traverses using visit, abilities execute based on types, report/return collects results. Use OSP for: complex relationships, graph traversal, relationship properties, multiple connection types. Use OOP for: standalone data, simple hierarchies, tight loops. Advanced: async def for asynchronous operations. Decorators: @decorator_name above function. Context managers: with resource { }. range(n): generates 0 to n-1. sum(list): sum of list items. Type checking enforced with annotations. glob: global variable. import from module { items }. Jac compiles to Python, interoperable with Python libraries.