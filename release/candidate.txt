Jac is a onelang that supersets Python and JavaScript, enabling developers to build fullstack applications spanning frontend, backend, and AI under one unified language. Jac compiles to Python for backend and AI workloads while compiling to JavaScript for frontend, with seamless interoperability between both targets. Write once, deploy anywhere. The core philosophy eliminates context switching between languages: define your data models, API endpoints, AI functions, and reactive UI components all in the same .jac file using consistent syntax.

SYNTAX AND TYPES: Jac supersets Python syntax with curly braces for block delimitation and an enhanced type system. Primitive types include int, float, str, bool, bytes, and any for dynamic typing. Collections support type parameters: list[T], dict[K,V], set[T], tuple[T,...], frozenset[T]. Type unions use the pipe operator: int | None, str | int. Type annotations appear with has for fields (has x: int;) and arrow syntax for return types (-> str). Control flow uses if/elif/else with braces: if x > 0 { print("positive"); } elif x < 0 { print("negative"); } else { print("zero"); }. The for loop has a unique syntax: for i = 0 to i < 10 by i += 1 { print(i); } which iterates with explicit initialization, condition, and increment. Standard iteration works as for item in items { process(item); }. While loops follow while cond { body }. Match/case provides pattern matching: match status { case Status.PENDING { print("Waiting"); } case Status.ACTIVE { print("Active"); } }. Standalone functions use def: def func_name(param: type) -> return_type { return value; }. CRITICAL: can is ONLY for abilities with event clauses (can name with Type entry or can name with Type exit), never for standalone functions or regular methods. Lambdas use pipe syntax: |x: int| -> int { x * 2 }. The entry point for scripts is with entry { main_code(); }. Global variables at module level use glob: glob config: dict = {"debug": true}; and to modify globals within functions use global varname; before assignment.

IMPORTS: Jac seamlessly imports from the Python ecosystem with zero configuration. Jac module imports use import from module_name { Symbol1, Symbol2 };. Python imports use the :py annotation: import:py os; or import:py from datetime { datetime };. Aliased imports work as import from module { Original as Alias };. Simple imports: import os;. Multiple imports: import sys, json;. Alias entire module: import datetime as dt;. From imports: import from math { sqrt, pi };. Include directive merges another Jac file: include module_path;. Any Python package works directly: sklearn, torch, numpy, pandas, requests all import with standard syntax.

ARCHETYPES: Jac provides five archetype kinds for different purposes. node defines graph vertices with has for fields, def for methods, and can with entry/exit for abilities: node Person { has name: str; has age: int; def get_info() -> str { return f"{self.name}, {self.age}"; } can greet with Visitor entry { print(f"Hello from {self.name}"); } }. edge defines typed connections between nodes: edge Knows { has since: int; has strength: float = 1.0; def get_normalized(max: float) -> float { return self.strength / max; } }. walker defines graph traversers with state and traversal abilities: walker FindAdults { has min_age: int = 18; has found: list = []; can start with `root entry { visit [-->]; } can check with Person entry { if here.age >= self.min_age { self.found.append(here); } visit [-->]; } }. obj defines value objects similar to Python classes: obj Calculator { has value: int = 0; def add(n: int) -> int { self.value += n; return self.value; } def reset() -> None { self.value = 0; } }. Objects support postinit for initialization logic. enum defines enumerations: enum Status { PENDING, ACTIVE, COMPLETED } or with explicit values enum Color { RED = "red", GREEN = "green", BLUE = "blue" }.

ACCESS MODIFIERS: Three access levels control visibility: :pub (public, the default), :priv (private), :prot (protected). SYNTAX: the modifier comes AFTER the keyword with NO space between them. For fields: has:priv balance: float; (NOT has :priv: or :priv has). For methods: def:pub get_data() -> str { return self.data; }. For abilities: can:prot helper with entry { }. Complete example: obj Account { has:pub name: str; has:priv balance: float = 0.0; has:prot account_id: str; def:pub deposit(amt: float) -> None { self.balance += amt; } def:priv validate() -> bool { return self.balance >= 0; } def:prot internal_transfer(target: Account, amt: float) -> None { self.balance -= amt; } }. Walker with access: walker:priv InternalProcessor { can process with `root entry { visit [-->]; } }.

GRAPH OPERATIONS: Define edge types with attributes: edge Road { has distance: float; has toll: bool = false; }. Simple forward connect: a ++> b;. Bidirectional connect: a <++> b;. Backward connect: a <++ b;. Typed edge without attributes: a +>:Road:+> b;. Typed edge with single attribute: a +>:Road:distance=100.5:+> b;. Multiple attributes: a +>:Road:distance=100.5:toll=true:+> b;. Disconnect specific edge: del a --> b;. Disconnect all incoming to b: del --> b;. Disconnect all outgoing from a: del a -->;. Traverse forward: [-->]. Traverse backward: [<--]. Traverse both directions: [<-->]. Typed traverse: [-->:Road:] or [->:Road:->]. Filter by node type: [-->(`?Person)]. Filter by attribute: [-->](?age > 18). Combined filters: [-->(`?Person)](?age > 18 and active == true). Chained multi-hop: [->:Friend:-> ->:Friend:->]. Edge attribute filter during traversal: [->:Friend:since > 2020:->]. Complex query combining all: [->:Friend:since < 2020:->(`?Person)](?age > 30).

ABILITIES AND EVENTS: Abilities use can with mandatory event clauses. Node entry ability: can on_enter with Visitor entry { print(f"Visitor arrived at {self.name}"); }. Node exit ability: can on_exit with Visitor exit { print("Visitor leaving"); }. Walker entry ability: can process with Person entry { report here.name; visit [-->]; }. Walker exit ability: can finish with `root exit { report self.collected; }. Generic ability triggers on any type: can default with entry { print("Visited unknown node"); }. CRITICAL: can ALWAYS requires "with ... entry" or "with ... exit" - use def for regular methods without event triggers. Execution order when walker visits node: node entry abilities run first, then walker entry abilities, then walker exit abilities, then node exit abilities. Keywords: self refers to the current archetype instance; here refers to the current node being visited; visitor refers to the walker visiting a node (used in node abilities); props accesses walker properties from node context; root is the graph root node; `root is the root type for type matching in abilities.

WALKER CONTROL: spawn launches a walker at a node: walker_instance spawn node; or MyWalker() spawn `root;. The spawn returns a result object with reports. visit queues nodes for traversal: visit [-->]; visits all forward-connected nodes. visit with else handles leaf nodes: visit [-->] else { print("No more nodes"); handle_leaf(); }. disengage stops the walker completely and returns early, useful for search termination: can search with Target entry { if here.matches { report here; disengage; } visit [-->]; }. report collects return values accessible via result.reports: can collect with Item entry { report here.value; }. skip skips current node processing like continue in loops: for item in items { if item.invalid { skip; } process(item); }. Complete pattern: walker DataCollector { has collected: list = []; can start with `root entry { visit [-->]; } can gather with DataNode entry { if here.value < 0 { skip; } self.collected.append(here.value); if here.is_target { report self.collected; disengage; } visit [-->]; } can finish with `root exit { report self.collected; } }.

AI INTEGRATION: CORRECT IMPORT: import from jaclang.core.llms { Model };. REQUIRED PATTERN at module level: glob llm = Model(model_name="gpt-4o");. Basic function delegation with no parentheses after llm: def summarize(text: str) -> str by llm;. With explicit model reference: def translate(text: str, target: str) -> str by llm(model=llm);. Method in object: obj Assistant { def answer(question: str) -> str by llm; }. Structured output returns typed objects: obj Analysis { has sentiment: str; has confidence: float; has topics: list[str]; } then def analyze(text: str) -> Analysis by llm;. Advanced methods: by llm(method="Reason") enables chain-of-thought reasoning; by llm(method="ReAct") creates tool-using agents; by llm(tools=[func1, func2]) provides specific tools. Semstrings add semantic hints: has description: str """semantic hint for LLM understanding""";. Inline expression: response = "Explain quantum computing simply" by llm;. Streaming: def stream_story(prompt: str) -> str by llm(stream=True); then for chunk in stream_story("Tell a story") { print(chunk, end=""); }. Multimodal with images: import from jaclang.core.llms { Image, Video }; def describe(img: Image) -> str by llm; then describe(Image(url="https://example.com/photo.jpg"));. Tool-using agent: glob llm = Model(model_name="gpt-4o-mini"); def get_time() -> str { import datetime; return datetime.datetime.now().isoformat(); } then def answer(q: str) -> str by llm(tools=[get_time]);. COMMON MISTAKES: Wrong: by llm() with empty parentheses. Right: by llm; for basic or by llm(model=var) with parameters. Wrong: import from byllm. Right: import from jaclang.core.llms { Model }. Wrong: using by llm without glob model declaration.

FILE IO AND JSON: File operations use file module: f = file.open("data.txt", "r"); content = f.read(); f.close();. Write mode: f = file.open("output.txt", "w"); f.write("content"); f.close();. JSON serialization: import json; data = {"key": "value"}; json_str = json.dumps(data);. JSON parsing: parsed = json.loads(json_str);.

CLOUD AND API: Start server with jac start file.jac (formerly jac serve). Walkers automatically become API endpoints at /walker/WalkerName. The __specs__ object configures endpoint behavior and MUST be a nested obj with static has fields, NOT a dict literal. Complete endpoint walker: walker GetTodos { obj __specs__ { static has methods: list = ["GET"]; static has auth: bool = false; static has path_prefix: str = "/api/v1"; } can fetch with `root entry { todos = [-->(`?Todo)]; report [{"id": t.id, "title": t.title, "done": t.done} for t in todos]; } }. POST with body: walker CreateTodo { has title: str; has category: str = "general"; obj __specs__ { static has methods: list = ["POST"]; static has auth: bool = true; } can create with `root entry { new_todo = here ++> Todo(id=uuid(), title=self.title, category=self.category); report {"id": new_todo.id, "created": true}; } }. Query parameters: obj __specs__ { static has methods: list = ["GET"]; static has as_query: list = ["page", "limit"]; }. WRONG: __specs__ = {"methods": ["GET"]}. report returns response data to the client. File upload uses UploadFile type in walker has fields. Fullstack organization: use cl { } for frontend code and sv { } for backend code in the same .jac file, or split into separate .cl.jac files for larger projects.

WEBSOCKET: Configure websocket endpoint with methods: ["websocket"] in __specs__. Socket methods for real-time communication: socket.notify_users(user_ids, message) sends to specific users; socket.notify_channels(channel_names, message) broadcasts to channels; socket.notify_clients(client_ids, message) sends to specific connections. Walker example: walker LiveUpdates { obj __specs__ { static has methods: list = ["websocket"]; } can handle with `root entry { socket.notify_channels(["updates"], {"type": "ping"}); } }.

WEBHOOKS: Configure webhook endpoints with __specs__ containing type (header, query, or body) and name for validation. Endpoint URL pattern: /webhook/walker/{walker_name}. Example: walker GithubWebhook { obj __specs__ { static has methods: list = ["POST"]; static has webhook: dict = {"type": "header", "name": "X-Hub-Signature-256"}; } can process with `root entry { report {"received": true}; } }.

SCHEDULER: Configure scheduled execution in __specs__ with schedule field. Cron schedule runs at specific times: obj __specs__ { static has schedule: dict = {"trigger": "cron", "hour": "9", "minute": "0"}; static has private: bool = true; }. Interval schedule runs repeatedly: obj __specs__ { static has schedule: dict = {"trigger": "interval", "seconds": 30}; static has private: bool = true; }. Date schedule runs once: obj __specs__ { static has schedule: dict = {"trigger": "date", "run_date": "2024-12-31T23:59:59"}; }. Set private: true for scheduled walkers to prevent external HTTP access.

ASYNC: Async walkers and functions enable concurrent operations. Async walker: async walker DataFetcher { has url: str; async can fetch with `root entry { data = await http_get(self.url); report data; } }. Async function: async def fetch_data(url: str) -> dict { response = await http_get(url); return response; }. Task status checking: task = create_task(async_operation()); status = task.__jac__.status; results = task.__jac__.reports; error = task.__jac__.error;. Task queue for background processing: task = create_task(long_running_walker() spawn root);.

PERMISSIONS: Permission levels from lowest to highest: NoPerm (no access), ReadPerm (read only), ConnectPerm (can connect edges), WritePerm (full access). Grant permissions: _.allow_root(node, target_root, WritePerm); or grant(node, ReadPerm);. Revoke permissions: _.disallow_root(node, target_root); or revoke(node);. Custom access control uses __jac_access__ method on archetypes for fine-grained logic.

PERSISTENCE: Nodes connected to root automatically persist across requests. Manual save for explicit persistence: node = here ++> Item(name="test"); save(node); commit();. Reference node by ID: item = &item_id; retrieves persisted node. Delete and commit: del item; commit();. Commit specific type: commit(Item); persists all Item nodes. Global nodes use glob keyword for persistent state shared across requests: glob counter: Counter = Counter();.

TESTING: Test blocks define unit tests: test addition { result = 2 + 2; assert result == 4; }. assert fails the test immediately on false condition. check provides soft assertion that records failure but continues: test multiple_checks { check value > 0; check value < 100; assert valid; }. Walker testing: test walker_collects_data { root ++> DataNode(value=1); root ++> DataNode(value=2); result = root spawn Collector(); assert len(result.reports) == 2; assert sum(result.reports) == 3; }.

STANDARD LIBRARY: Built-in functions include print(value), input(prompt), range(start, stop, step), len(collection), enumerate(iterable), type(obj), str(value), int(value), float(value), list(iterable), dict(pairs). String methods: s.upper(), s.lower(), s.strip(), s.split(delimiter), delimiter.join(list), s.replace(old, new), s.startswith(prefix), s.endswith(suffix), s.find(sub). List methods: l.append(item), l.extend(items), l.insert(index, item), l.remove(item), l.pop(index), l.sort(), l.reverse(), l.index(item), l.count(item). Dict methods: d.keys(), d.values(), d.items(), d.get(key, default), d.update(other), d.pop(key), d.setdefault(key, default).

JSX AND FRONTEND: Jac supports reactive UIs that compile to JavaScript. Server block defines backend-only code: sv { walker get_data { obj __specs__ { static has methods: list = ["GET"]; static has auth: bool = false; } can fetch with `root entry { report {"message": "Hello from server"}; } } }. Client block defines frontend components: cl { has count: int = 0; has message: str = ""; can with entry { response = fetch("/walker/get_data"); message = response.get("message", ""); } can with [count] entry { print(f"Count changed to {count}"); } can with exit { print("Component unmounting"); } def increment() -> None { count += 1; } <div className="container"><p>f"Message: {message}"</p><p>f"Count: {count}"</p><button onClick={increment}>"Increment"</button></div> }. Mount effect runs once on component mount: can with entry { }. Dependency effect runs when dependencies change: can with [dep] entry { } or can with (a, b) entry { } for multiple. Cleanup effect runs on unmount: can with exit { }. JSX syntax: <Component prop={value} />, {expression} for interpolation, onClick={handler} for events, className for CSS classes. File organization options: single .jac file with sv { } and cl { } blocks for small apps, or split into main.jac for backend with components/*.cl.jac for React components in larger projects. Component with props: cl { def:pub Greeting(props: dict) -> any { return <h1>f"Hello, {props.name}!"</h1>; } def:pub app() -> any { return <div><Greeting name="Alice" /><Greeting name="Bob" /></div>; } }. Timer component with lifecycle: cl { def:pub Timer() -> any { has seconds: int = 0; can with entry { intervalId = setInterval(|-> None| { seconds = seconds + 1; }, 1000); } can with exit { clearInterval(intervalId); } return <p>f"Seconds: {seconds}"</p>; } }. Protected route pattern: cl { def:pub ProtectedRoute(props: dict) -> any { auth = use_auth(); if auth.loading { return <div>"Loading..."</div>; } if not auth.isAuthenticated { window.location.href = "/login"; return <div>"Redirecting..."</div>; } return <>{props.children}</>; } }.

DEPLOYMENT: Docker deployment: FROM python:3.11-slim then RUN pip install jaclang then COPY . /app then WORKDIR /app then CMD ["jac", "start", "main.jac"]. Kubernetes deployment requires deployment.yaml with container spec, service.yaml for networking, and ingress.yaml for external access. Environment variables: DATABASE_URL for database connection, JAC_SECRET_KEY for authentication, OPENAI_API_KEY for AI features, JAC_HOST and JAC_PORT for server binding.

PATTERNS: Single-file fullstack app demonstrates the onelang philosophy with frontend, backend, and AI in one file: import from jaclang.core.llms { Model }; glob llm = Model(model_name="gpt-4o"); node Message { has id: str; has content: str; has response: str = ""; } def generate_response(content: str) -> str by llm; sv { walker SendMessage { has content: str; obj __specs__ { static has methods: list = ["POST"]; static has auth: bool = false; } can process with `root entry { response = generate_response(self.content); msg = here ++> Message(id=uuid(), content=self.content, response=response); save(msg); commit(); report {"id": msg.id, "response": response}; } } walker GetMessages { obj __specs__ { static has methods: list = ["GET"]; } can fetch with `root entry { messages = [-->(`?Message)]; report [{"id": m.id, "content": m.content, "response": m.response} for m in messages]; } } } cl { has messages: list = []; has input_text: str = ""; has loading: bool = false; can with entry { response = fetch("/walker/GetMessages"); messages = response if response else []; } async def send_message() -> None { if not input_text { return; } loading = true; response = fetch("/walker/SendMessage", {"content": input_text}); messages = messages + [response]; input_text = ""; loading = false; } <div className="chat-app"><h1>"AI Chat"</h1><div className="messages">{[<div key={m["id"]} className="message"><p className="user">f"{m['content']}"</p><p className="ai">f"{m['response']}"</p></div> for m in messages]}</div><input value={input_text} onChange={|e| { input_text = e.target.value; }} placeholder="Type a message..." /><button onClick={send_message} disabled={loading}>{loading ? "Sending..." : "Send"}</button></div> }. Graph traversal with collection pattern: walker CollectData { has results: list = []; can start with `root entry { visit [-->]; } can collect with DataNode entry { if here.valid { self.results.append({"id": here.id, "value": here.value}); } visit [-->] else { report self.results; } } can finish with `root exit { report self.results; } }. AI-powered processing pipeline: glob llm = Model(model_name="gpt-4o"); obj ProcessedDoc { has summary: str; has keywords: list[str]; has sentiment: str; } def process_document(text: str) -> ProcessedDoc by llm; walker AnalyzeDocuments { can analyze with `root entry { docs = [-->(`?Document)]; for doc in docs { result = process_document(doc.content); doc.summary = result.summary; doc.keywords = result.keywords; doc.sentiment = result.sentiment; save(doc); } commit(); report {"processed": len(docs)}; } }. API endpoint with full specs: walker UserProfile { has user_id: str; obj __specs__ { static has methods: list = ["GET", "PUT"]; static has auth: bool = true; static has path_prefix: str = "/api/v1"; static has as_query: list = ["user_id"]; } can get_profile with `root entry { user = [-->(`?User)](?id == self.user_id); if user { report {"id": user[0].id, "name": user[0].name, "email": user[0].email}; } else { report {"error": "User not found"}; } } }.