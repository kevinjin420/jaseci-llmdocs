Jac Language Reference

SYNTAX AND TYPES: Jac provides primitive types int float str bool bytes any for basic values. Collections include list[T] for ordered sequences, dict[K,V] for key-value mappings, set[T] for unique elements, tuple[T,...] for fixed sequences, and frozenset[T] for immutable sets. Type unions use the pipe operator as in int | None for optional values. Type annotations appear with has x: type for fields and -> return_type for function returns. Control flow uses if/elif/else for conditionals as in if x > 0 { print("positive"); } elif x < 0 { print("negative"); } else { print("zero"); }. Loops include for item in collection { } and while condition { }. Pattern matching uses match value { case pattern => action; }. Functions use def name(param: type, default: type = value) -> return_type { body }. Lambdas use the syntax |params| -> type { body } for inline functions. The entry point for a Jac program is with entry { } which serves as the main function equivalent.

IMPORTS: Simple imports use import os; for single modules. Multiple imports combine as import sys, json; on one line. Aliases use import datetime as dt; for renaming. Selective imports use import from math { sqrt, pi } to import specific items. Python interop uses import:py from module { func } to explicitly import Python functions. All import statements end with semicolons.

ARCHETYPES: Nodes define graph vertices with node Person { has name: str; has age: int; can greet with speak_to; def calculate_birth_year -> int { return 2024 - self.age; } } supporting has for fields, can for abilities, def for methods, and inheritance. Edges define typed connections with edge Friend { has since: int; has strength: float = 1.0; def get_normalized(max_weight: float) -> float { return self.strength / max_weight; } } enabling rich relationship modeling. Walkers define graph traversers with walker DataProcessor { has data: str; can start with `root entry { print("Starting from root"); visit [-->]; } can process with Person entry { print(f"Processing {here.name}"); visit [-->]; } can default with entry { print("At unknown node type"); visit [-->]; } } using entry/exit abilities for node interactions. Objects use obj Calculator { has value: int = 0; def add(n: int) -> int { self.value += n; return self.value; } def reset() -> None { self.value = 0; } } for value types with optional postinit for initialization logic. Enums define enumerations with enum HttpStatus { OK = 200, NOT_FOUND = 404 def is_success -> bool { return 200 <= self.value < 300; } } supporting values and methods.

ACCESS MODIFIERS: The :pub modifier marks public access and is the default for all members. The :priv modifier restricts access to the defining archetype only as in has :priv secret: str; or def :priv internal_method() -> None { }. The :prot modifier allows access from the defining archetype and its descendants. These modifiers apply to both has fields and def/can abilities.

GRAPH OPERATIONS: Connect operators create edges between nodes. Untyped connections use ++> for forward as in alice ++> bob;, <++ for reverse, and <++> for bidirectional. Typed connections use +>:Edge:+> as in alice +>:Friend(since=2020):+> bob; for forward typed, <+:Edge:+> for reverse typed, and <+:Edge:+> for bidirectional typed. Disconnect uses del to remove edges. Traversal operators navigate the graph with [--> ] for outgoing edges, [<--] for incoming, and [<-->] for both directions. Typed traversal uses [-->:EdgeType:] as in [->:Friend:->] to filter by edge type. Node filtering uses [-->(`?NodeType)] to select specific node types. Attribute filtering uses (?attr == val) as in [-->](?age >= 18) for node attributes or [->:Friend:since > 2020:->] for edge attributes. Chained traversal enables multi-hop queries as in friends_of_friends = [here ->:Friend:-> ->:Friend:->];.

ABILITIES AND EVENTS: Ability syntax uses can name with Type entry { } for typed entry abilities or can name with Type exit { } for exit abilities. Generic abilities use can name with entry { } to trigger for any walker. The execution order is node entry, then walker entry, then walker exit, then node exit. The keyword self refers to the current archetype instance. The keyword here refers to the current node being visited. The keyword visitor refers to the walker visiting the node. The keyword root refers to the graph root node. The backtick syntax `root refers to the root type for type matching as in can start with `root entry { }.

WALKER CONTROL: Spawn initiates walker traversal with walker() spawn node as in result = root spawn DataCollector(); which returns a result object. Visit queues nodes for traversal with visit [-->]; for continuing or visit [-->] else { } for handling empty traversals. Disengage stops the walker immediately with disengage; useful for early termination when a condition is met. Report returns values from the walker with report here.value; which continues execution and collects values accessible via result.reports. Skip bypasses the current node with skip; to move to the next queued node. A complete traversal example: walker Searcher { has target: str; can search with Person entry { if here.name == self.target { report here; disengage; } visit [-->]; } } with entry { result = root spawn Searcher(target="Alice"); found = result.reports[0]; }.

AI INTEGRATION: Basic LLM calls use by llm() as in def summarize(text: str) -> str by llm(); for simple inference. Chain-of-thought reasoning uses by llm(method="Reason") for step-by-step thinking. ReAct reasoning uses by llm(method="ReAct") for reasoning with actions. Model selection uses by llm(model=var) with a model variable. Tool use enables function calling with by llm(tools=[funcs]) as in def answer(question: str) -> str by llm(tools=[get_current_time]);. Global model configuration uses glob llm = Model(model_name="gpt-4o-mini"); from import from byllm.lib { Model }. Semstrings provide semantic descriptions with triple quotes """description""" before functions and :sem: for inline semantics. Structured output works with enums and objects for type-safe responses as in def get_status(response: str) -> HttpStatus by llm(); returning guaranteed enum values. Multimodal input uses Image(url="...") or Video(path="...", fps=1) for visual content. Complete example: import from byllm.lib { Model } glob llm = Model(model_name="gpt-4o-mini"); """Analyze the sentiment of the given text.""" def analyze(text: str) -> Sentiment by llm(); with entry { result = analyze("I love this product!"); print(result); }.

FILE IO AND JSON: File operations use file.open(path, mode) to open files with modes like "r" for read and "w" for write. Reading uses content = file.read() to get file contents. Writing uses file.write(data) to output data. Closing uses file.close() to release resources. JSON serialization uses json.dumps(obj) to convert objects to JSON strings. JSON parsing uses json.loads(str) to convert JSON strings to objects.

CLOUD AND API: Starting a server uses jac serve file.jac to expose walkers as endpoints. Walkers become endpoints automatically when served. The __specs__ configuration controls endpoint behavior with static has __specs__: dict = {"auth": True, "methods": ["POST"], "path": "/custom/path", "as_query": ["param1"], "private": True};. The auth field requires authentication. The methods field specifies HTTP methods. The path field customizes the endpoint URL. The as_query field moves parameters to query string. The private field hides from public API. Report returns response data with report {"status": "success", "data": result};. File upload uses UploadFile type for multipart form data. Endpoint example: walker create_user { has name: str; has email: str; static has __specs__: dict = {"methods": ["POST"], "auth": False}; can create with `root entry { user = User(name=self.name, email=self.email); root ++> user; report {"id": user.id, "name": user.name}; } }.

WEBSOCKET: WebSocket endpoints use methods: ["websocket"] in __specs__ configuration. Socket notification methods include socket.notify_users(user_ids, message) for user-specific messages, socket.notify_channels(channel_names, message) for channel broadcasts, and socket.notify_clients(client_ids, message) for direct client communication.

WEBHOOKS: Webhook configuration uses __specs__ with webhook settings specifying type and name as in static has __specs__: dict = {"webhook": {"type": "header", "name": "X-Webhook-Secret"}};. The type can be header for HTTP header validation, query for query parameter validation, or body for request body validation. The endpoint path follows the pattern /webhook/walker/{name} for incoming webhook requests.

SCHEDULER: Schedule configuration uses __specs__ with schedule settings. Cron scheduling uses {"trigger": "cron", "hour": "9", "minute": "0"} for time-based execution. Interval scheduling uses {"trigger": "interval", "seconds": 30} for periodic execution. Date scheduling uses {"trigger": "date", "run_date": "2024-12-31 23:59:59"} for one-time execution. Scheduled walkers should use private: true to hide from public API as in static has __specs__: dict = {"schedule": {"trigger": "interval", "minutes": 5}, "private": true};.

ASYNC: Async walkers use async walker name { } for concurrent execution. Async functions use async def name() -> type { } with await for async calls. Task status checking uses task.__jac__.status to get current state. Task reports access uses task.__jac__.reports for collected values. Task errors use task.__jac__.error for exception information. Task queue creation uses create_task() for background execution. Example: async walker DataFetcher { has url: str; async can fetch with `root entry { data = await http_get(self.url); report data; } }.

PERMISSIONS: Permission levels include NoPerm for no access, ReadPerm for read-only access, ConnectPerm for connection ability, and WritePerm for full write access. Granting permissions uses _.allow_root(node, target_root, level) for root-level grants or grant(node, level) for simpler grants. Revoking permissions uses _.disallow_root(node, target) for root-level revocation or revoke(node) for simpler revocation. Custom access control uses __jac_access__ for fine-grained permission logic.

PERSISTENCE: Nodes automatically persist when connected to root through any path. Manual saving uses save(node) to persist a specific node. Committing uses commit() for all changes or commit(Type) for type-specific commits. Global nodes use glob for shared persistent state. References use &"n::id" syntax to reference nodes by identifier. Example: with entry { id = jid(alice); grant(secret_node, bob); save(alice); commit(); printgraph(root); }.

TESTING: Test blocks use test { } for defining test cases. Assert uses assert condition; which fails the test if false. Check uses check condition; for soft assertions that continue execution. Example: test walker_collects_data { root ++> DataNode(value=1); root ++> DataNode(value=2); root ++> DataNode(value=3); result = root spawn Collector(); assert len(result.reports) == 3; assert sum(result.reports) == 6; }.

STANDARD LIBRARY: Built-in functions include print for output, input for user input, range for numeric sequences, len for collection length, enumerate for indexed iteration, type for type checking, str int float for type conversion, list dict for collection creation. String methods include upper lower for case conversion, strip for whitespace removal, split for tokenization, join for concatenation, replace for substitution. List methods include append for adding elements, extend for merging lists, insert for positional insertion, remove for value removal, pop for index removal, sort for ordering, reverse for reversing. Dict methods include keys values items for iteration, get for safe access with default, update for merging, pop for key removal.

DEPLOYMENT: Docker deployment uses FROM python:3.11-slim as base, RUN pip install jaclang for installation, and CMD ["jac", "serve", "app.jac"] for startup. Environment variables include DATABASE_URL for database connection, JAC_SECRET_KEY for authentication secrets, and OPENAI_API_KEY for AI integration. Kubernetes deployment uses standard deployment manifests with replicas, service for load balancing, and ingress for external access.

PATTERNS: Graph traversal with collection pattern: walker Collector { has items: list = []; has max_items: int = 10; can start with `root entry { print("Starting collection"); visit [-->]; } can collect with DataNode entry { if len(self.items) < self.max_items { self.items.append(here.value); } visit [-->]; } } with entry { root ++> DataNode(value=1) ++> DataNode(value=2); walker_instance = Collector(); root spawn walker_instance; print(f"Collected {walker_instance.items}"); }. AI-powered processing pattern: import from byllm.lib { Model } glob llm = Model(model_name="gpt-4o-mini"); glob company_info = "Company: TechCorp Products: CloudDB, SecureAuth"; """Answer customer questions about our products.""" def support_agent(question: str) -> str by llm(incl_info={"company_context": company_info}); with entry { print(support_agent("What products do you offer?")); }. API endpoint walker pattern: walker get_todos { static has __specs__: dict = {"methods": ["GET"], "auth": True}; can list with `root entry { todos = [-->(`?Todo)]; report [{"title": t.title, "done": t.done} for t in todos]; } }. Caching pattern: node Cache { has data: dict = {}; has ttl: int = 3600; def get(key: str) -> any { return self.data.get(key); } def set(key: str, value: any) -> None { self.data[key] = value; } } with entry { cache = Cache(); root ++> cache; cache.set("user:1", {"name": "Alice"}); print(cache.get("user:1")); }.