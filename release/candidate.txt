# JAC LANGUAGE REFERENCE

## 1. TYPES
Primitives: int float str bool bytes any
Collections: list[T] dict[K,V] set[T] tuple[T,...]
Union: int|None; str|int
Declaration: has x: int; has y: str = "default"
Return: def f() -> int { }
Type check: type(x) == int

## 2. CONTROL
If: if cond { } elif cond { } else { }
For-each: for x in items { }
For-range: for i=0 to i<10 by i+=1 { }
While: while cond { }
Match: match x { case 1 { } case 2 { } case _ { } }
Break/continue: break; continue;

## 3. FUNCTIONS
Def: def name(p: T, q: T = default) -> R { return val; }
Lambda: |x: int| -> int { x * 2 }; |x| { x + 1 }
Glob: glob config: dict = {"debug": True};
Nested: def outer() { def inner() { } }

## 4. IMPORTS
Standard: import os; import json;
From: import from math { sqrt, floor }
Alias: import from datetime { datetime as dt }
Include: include module;
WRONG: import:py os RIGHT: import os

## 5. ARCHETYPES
Node: node N { has f: T = default; can ability with W entry { } }
Edge: edge E { has weight: float = 1.0; }
Walker: walker W { has state: T; can act with N entry { visit [-->]; } }
Object: obj O { has f: T; def method() -> R { return self.f; } }
Enum: enum E { A, B = 1, C = "val" }

node Todo { has id: str; has title: str; has done: bool = False; }
edge Knows { has since: int; has strength: float = 1.0; }
walker Finder { has target: str; can search with `root entry { visit [-->]; } }
obj Calculator { has value: int = 0; def add(n: int) -> int { self.value += n; return self.value; } }
enum Status { PENDING, ACTIVE, DONE }

## 6. ACCESS
Field: has:priv x: T; has:pub y: T; has:prot z: T;
Method: def:pub m() { }; def:priv n() { }
Ability: can:pub h with entry { }; can:priv p with N entry { }
Walker: walker:priv W { }
Only modifiers: :pub :priv :prot
WRONG: has: priv x RIGHT: has:priv x
WRONG: has :priv x RIGHT: has:priv x

## 7. GRAPH
Connect forward: a ++> b;
Connect bidirectional: a <++> b;
Connect typed: a +>:Edge:+> b;
Connect with attrs: a +>:E:weight=0.5:+> b;
Disconnect: del a --> b;
Traverse forward: [-->]
Traverse back: [<--]
Traverse typed: [-->:E:]
Traverse filter type: [-->(`?Node)]
Traverse filter attr: [-->](?attr > val)
Multi-hop: [-->:Friend:-> -->:Friend:->]

node A { has name: str; }
node B { has val: int; }
edge Link { has weight: float; }
with entry { a = A(name="x"); b = B(val=1); a ++> b; a +>:Link:weight=0.8:+> b; nodes = [a -->]; typed = [a -->:Link:]; filtered = [a -->](?val > 0); }

## 8. ABILITIES
Syntax: can name with Type entry { } or can name with Type exit { }
Requires with...entry or with...exit always
Use def for regular methods
Context vars: self=instance here=node visitor=walker root=user_root `root=root_type

node Room { can on_enter with Visitor entry { print(f"{visitor} entered {here}"); } can on_leave with Visitor exit { print(f"{visitor} left"); } }
walker Visitor { has name: str; can start with `root entry { visit [-->]; } }

WRONG: can process(x: int) { } RIGHT: def process(x: int) { }
WRONG: can act with Node { } RIGHT: can act with Node entry { }

## 9. WALKERS
Spawn: Walker() spawn node;
Visit: visit [-->]; visit [<--]; visit [-->:E:];
Visit else: visit [-->] else { print("no nodes"); }
Report: report value;
Disengage: disengage;
Skip: skip;
Results: result = W() spawn n; data = result.reports;

walker Collector { has items: list = []; can start with `root entry { visit [-->]; } can gather with Item entry { self.items.append(here.data); report here.data; } }
with entry { root ++> Item(data="a"); root ++> Item(data="b"); result = Collector() spawn root; all_items = result.reports; }

WRONG: spawn Walker() on node RIGHT: Walker() spawn node
WRONG: Walker().spawn(node) RIGHT: Walker() spawn node

## 10. BY_LLM
Basic: def f(x: str) -> str by llm;
Structured: def f() -> MyObj by llm;
Options: by llm(temperature=0.7); by llm(method="Reason"); by llm(stream=True);
Semstring: has desc: str """hint for LLM""";
Inline: result = "prompt" by llm;
No import needed; builtin

def classify(text: str) -> str by llm;
def extract_entities(text: str) -> list[str] by llm;
obj Person { has name: str """person's full name"""; has age: int """age in years"""; }
def parse_person(text: str) -> Person by llm;

WRONG: by llm() RIGHT: by llm;
WRONG: by llm("prompt") RIGHT: def f() -> T by llm;
WRONG: import llm RIGHT: (no import needed)

## 11. FILE_JSON
File: f = file.open(path, "r"); content = f.read(); f.close();
Write: f = file.open(path, "w"); f.write(data); f.close();
JSON: s = json.dumps(obj); obj = json.loads(s);

## 12. API
Start: jac start file.jac
Walker as endpoint: walker becomes HTTP endpoint automatically
Specs: obj __specs__ { static has methods: list = ["GET"]; static has auth: bool = true; static has path_prefix: str = "/api"; }

walker GetTodos { obj __specs__ { static has methods: list = ["GET"]; static has auth: bool = false; } can fetch with `root entry { report [{"id": "1", "title": "Task"}]; } }

walker CreateTodo { has title: str; obj __specs__ { static has methods: list = ["POST"]; } can create with `root entry { report {"created": self.title}; } }

WRONG: __specs__ = {"methods": ["GET"]} RIGHT: obj __specs__ { static has methods: list = ["GET"]; }
WRONG: static has methods: dict = {"GET": true} RIGHT: static has methods: list = ["GET"];

## 13. WEBSOCKET
Spec: obj __specs__ { static has methods: list = ["websocket"]; }
Notify users: socket.notify_users(user_ids, message);
Notify channels: socket.notify_channels(channel_names, message);

walker ChatStream { obj __specs__ { static has methods: list = ["websocket"]; } can stream with `root entry { socket.notify_users([root.id], {"msg": "hello"}); } }

## 14. WEBHOOKS
Spec: obj __specs__ { static has webhook: dict = {"type": "header", "name": "X-Signature"}; }
Endpoint: /webhook/walker/name
Types: header query body

walker GithubHook { obj __specs__ { static has methods: list = ["POST"]; static has webhook: dict = {"type": "header", "name": "X-Hub-Signature-256"}; } can handle with `root entry { report {"received": true}; } }

## 15. SCHEDULER
Spec: obj __specs__ { static has schedule: dict = {"trigger": "cron", "hour": "9"}; static has private: bool = true; }
Triggers: cron interval date

walker DailyCleanup { obj __specs__ { static has schedule: dict = {"trigger": "cron", "hour": "0", "minute": "0"}; static has private: bool = true; } can run with `root entry { } }

walker Heartbeat { obj __specs__ { static has schedule: dict = {"trigger": "interval", "minutes": "5"}; static has private: bool = true; } can ping with `root entry { } }

## 16. ASYNC
Async walker: async walker W { async can f with entry { await op(); } }
Async def: async def fetch() -> str { return await http_get(url); }
Task status: task.__jac__.status; task.__jac__.reports; task.__jac__.error;

async walker DataFetcher { has url: str; async can fetch with `root entry { data = await http_get(self.url); report data; } }

## 17. PERMISSIONS
Grant: node.__jac__.grant(root, WritePerm);
Revoke: node.__jac__.revoke(root);
Check: node.__jac__.check_access(root, ReadPerm);
Levels: NoPerm ReadPerm ConnectPerm WritePerm

with entry { n = MyNode(); n.__jac__.grant(other_root, ReadPerm); if n.__jac__.check_access(other_root, WritePerm) { } n.__jac__.revoke(other_root); }

## 18. PERSISTENCE
Auto-persist: nodes connected to root persist automatically
Manual: save(node); commit();
Reference: &id
Delete: del node; commit();
Glob persist: glob counter: int = 0;

with entry { root ++> Todo(title="task"); commit(); }

## 19. TESTING
Test block: test name { assert cond; check cond; }
Assert: fails test on false
Check: logs but continues

test addition { assert 1 + 1 == 2; }
test walker_works { root ++> Node(val=1); result = Collector() spawn root; assert len(result.reports) == 1; }

## 20. STDLIB
Builtins: print len range enumerate type str int float list dict set bool
String: s.upper() s.lower() s.strip() s.split(sep) sep.join(list) s.replace(a,b) s.startswith(p) s.endswith(s)
List: l.append(x) l.extend(iter) l.pop() l.pop(i) l.sort() l.reverse() l.index(x) l.count(x)
Dict: d.keys() d.values() d.items() d.get(k) d.get(k,default) d.pop(k) d.update(other)
Set: s.add(x) s.remove(x) s.discard(x) s.union(other) s.intersection(other)

## 21. JSX
Server block: sv { }
Client block: cl { }
Component: def:pub Name(props: dict) -> any { return <div>{props.value}</div>; }
State: has count: int = 0; (auto useState)
Mount: can with entry { }
Unmount: can with exit { }
Deps: can with [dep] entry { }
Events: <button onClick={handler}>text</button>
Conditional: if cond { <A /> } else { <B /> }
List: for item in items { <Item data={item} /> }

sv { walker GetData { obj __specs__ { static has methods: list = ["GET"]; } can fetch with `root entry { report {"items": [1,2,3]}; } } }

cl { def:pub Counter() -> any { has count: int = 0; def inc() { count += 1; } return <div><p>{count}</p><button onClick={inc}>+</button></div>; } }

cl { def:pub App() -> any { has data: list = []; async can with entry { result = root spawn GetData(); data = result.reports[0]["items"]; } return <ul>{for item in data { <li>{item}</li> }}</ul>; } }

## 22. DEPLOY
Dockerfile: FROM python:3.11-slim
RUN pip install jaclang
COPY . /app
WORKDIR /app
CMD ["jac", "start", "main.jac"]

Env vars: DATABASE_URL JAC_SECRET_KEY OPENAI_API_KEY

## 23. ENTRY
Module entry: with entry { }
WRONG: entry { } RIGHT: with entry { }

with entry { print("program starts here"); root ++> MyNode(); }

## PATTERNS

### Pattern 1: Fullstack Single-File Todo App
sv { node Todo { has id: str; has title: str; has done: bool = False; } walker ListTodos { obj __specs__ { static has methods: list = ["GET"]; } can list with `root entry { todos: list = []; for t in [-->(`?Todo)] { todos.append({"id": t.id, "title": t.title, "done": t.done}); } report todos; } } walker AddTodo { has title: str; obj __specs__ { static has methods: list = ["POST"]; } can add with `root entry { import uuid; t = here ++> Todo(id=str(uuid.uuid4()), title=self.title); report {"id": t[0].id, "title": t[0].title}; } } }

cl { def:pub TodoApp() -> any { has todos: list = []; has newTitle: str = ""; async can with entry { result = root spawn ListTodos(); todos = result.reports[0] if result.reports else []; } async def addTodo() { if newTitle { result = root spawn AddTodo(title=newTitle); todos = todos + [result.reports[0]]; newTitle = ""; } } return <div><input value={newTitle} onChange={|e| { newTitle = e.target.value; }} /><button onClick={addTodo}>Add</button><ul>{for t in todos { <li>{t["title"]}</li> }}</ul></div>; } def:pub app() -> any { return <TodoApp />; } }

### Pattern 2: Walker Graph Traversal
node Person { has name: str; has age: int; }
edge Knows { has since: int; }
walker FindAdults { has adults: list = []; can start with `root entry { visit [-->]; } can check with Person entry { if here.age >= 18 { self.adults.append(here.name); report here.name; } visit [-->]; } can finish with `root exit { report {"count": len(self.adults), "names": self.adults}; } }
with entry { root ++> Person(name="Alice", age=25); root ++> Person(name="Bob", age=15); root ++> Person(name="Carol", age=30); result = FindAdults() spawn root; print(result.reports); }

### Pattern 3: API Endpoint with Specs
walker UserProfile { has user_id: str; obj __specs__ { static has methods: list = ["GET"]; static has auth: bool = true; static has path_prefix: str = "/api/v1"; } can fetch with `root entry { user = [-->(`?User)](?id == self.user_id); if user { report {"id": user[0].id, "name": user[0].name, "email": user[0].email}; } else { report {"error": "not found"}; } } }

walker UpdateProfile { has name: str = ""; has email: str = ""; obj __specs__ { static has methods: list = ["PUT"]; static has auth: bool = true; } can update with `root entry { user = [-->(`?User)](?id == root.id); if user { if self.name { user[0].name = self.name; } if self.email { user[0].email = self.email; } commit(); report {"updated": true}; } } }

## QUICK REFERENCE
Entry point: with entry { }
Connect: ++> <++> +>:E:+>
Traverse: [--> ] [<--] [-->:E:] [-->(`?T)] [-->](?a>v)
Spawn: Walker() spawn node;
Report: report val; result.reports
Visit: visit [-->]; visit [-->] else { }
Context: self here visitor root `root
Access: :pub :priv :prot
LLM: def f() -> T by llm;
Specs: obj __specs__ { static has field: type = val; }
Blocks: sv { } cl { }
Test: test name { assert cond; }