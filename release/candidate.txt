JAC LANGUAGE
Jac is a onelang superset of Python/JavaScript. Compiles to Python (backend/AI) or JavaScript (frontend). Write once, deploy anywhere.

TYPES
Primitives: int float str bool bytes any. Collections: list[T] dict[K,V] set[T] tuple. Unions: int|None. Annotations: has x: T for fields, -> T for returns.

CONTROL FLOW
if cond { } elif cond { } else { }. for x in items { }. for i=0 to i<10 by i+=1 { }. while cond { }. match x { case V { } }.

FUNCTIONS
def name(p: T) -> R { body }. Lambdas: |p| -> T { body }. Globals: glob var: T = val; at module level.
# The function signature IS the specification
def classify_sentiment(text: str) -> str by llm;

# Usage - the LLM infers behavior from the name and types
with entry {
    result = classify_sentiment("I love this product!");
    # result = "positive"
}

IMPORTS
import os; import from math { sqrt }; import from datetime { datetime as dt }; include module;. No import:py prefix.

ARCHETYPES
node: graph vertex with has fields, def methods, can abilities. edge: typed connection. walker: graph traverser. obj: value object. enum: enumeration.
node DataNode {
    has value: int = 0;
}

walker DataCollector {
    can collect with DataNode entry {
        report here.value;  # Continues execution
        visit [-->];
    }
}

with entry {
    root ++> DataNode(value=1);
    result = root spawn DataCollector();
    all_values = result.reports;  # List of reported values
}
walker:priv MyWalker {
    # Runs when entering the root node
    can on_root with `root entry {
        visit [-->];
    }

    # Runs when entering any Todo node
    can on_todo with Todo entry {
        process(here);
    }

    # Runs when entering any node (generic)
    can on_any with entry {
        log("Visited a node");
    }
}

ACCESS MODIFIERS
has:priv f: T; def:pub m() { }; can:prot h with entry { }. Only :pub :priv :prot. No space between keyword and modifier.

GRAPH OPERATIONS
Connect: a ++> b forward, a <++> b bidirectional, a +>:Edge:+> b typed, a +>:E:attr=v:+> b with attrs. Disconnect: del a --> b. Traverse: [-->] forward, [<--] back, [-->:E:] typed. Filter: [-->(`?Node)] by type, [-->](?attr>v) by attr.
node Item {
    has name: str;
}

walker:priv CreateItem {
    has name: str;

    can create with `root entry {
        new_item = here ++> Item(name=self.name);
        report new_item[0];  # Report the created item
    }
}

with entry {
    # Usage
    result = root spawn CreateItem(name="New Item");
    created = result.reports[0];  # The new item
}
test walker_collects_data {
    # Setup graph
    root ++> DataNode(value=1);
    root ++> DataNode(value=2);
    root ++> DataNode(value=3);

    # Run walker
    result = root spawn Collector();

    # Verify
    assert len(result.reports) == 3;
    assert sum(result.reports) == 6;
}

ABILITIES
can name with Type entry { } or exit { }. Always requires with...entry/exit. Use def for regular methods. Keywords: self here visitor props root `root.
walker FriendFinder {
    can find with `root entry {
        visit [-->];
    }
}

with entry {
    result = FriendFinder() spawn root;
}
walker:priv DeleteWithChildren {
    has parent_id: str;

    can search with `root entry {
        visit [-->];
    }

    can delete with Todo entry {
        # Delete if this is the target or a child of the target
        if here.id == self.parent_id or here.parent_id == self.parent_id {
            del here;
        }
    }
}

WALKER CONTROL
Spawn: Walker() spawn node;. Visit: visit [-->]; visit [-->] else { }. Control: report val; disengage; skip;. Results: result.reports.
walker:priv MyWalker {
    can work with `root entry {
        report "result";
    }
}

with entry {
    response = root spawn MyWalker();

    # Available properties
    print(response.reports);    # Array of all reported values
}
walker:priv MyWalker {
    can work with `root entry {
        report ["item1", "item2"];
        report {"count": 2};
    }
}

with entry {
    result = root spawn MyWalker();

    # Bad: Magic indices
    data = result.reports[0];
    meta = result.reports[1];

    # Good: Document or structure clearly
    ...

AI INTEGRATION
def f(x: str) -> str by llm; (builtin, no import). Structured: def f() -> Obj by llm;. Params: by llm(temperature=0.7). Methods: by llm(method="Reason"). Semstrings: has desc: str """hint""";. Wrong: by llm() Right: by llm;
with entry {
    text = "Some input text";
    result = text
        |> (lambda t: str -> str: t by llm("Correct grammar"))
        |> (lambda t: str -> str: t by llm("Simplify language"))
        |> (lambda t: str -> str: t by llm("Translate to Spanish"));
}
def stream_story(prompt: str) -> str by llm(stream=True);

# Returns generator
with entry {
    for chunk in stream_story("Tell me a story") {
        print(chunk, end="");
    }
}

FILE AND JSON
f=file.open(p,"r"); f.read(); f.write(s); f.close();. json.dumps(obj); json.loads(s);.

API ENDPOINTS
jac start file.jac. Walkers become endpoints. Specs: obj __specs__ { static has methods: list=["GET"]; static has auth: bool=true; }. Wrong: __specs__={"methods":[]}.

WEBSOCKET
obj __specs__ { static has methods: list=["websocket"]; }. socket.notify_users(ids,msg); socket.notify_channels(names,msg);.

SCHEDULER
obj __specs__ { static has schedule: dict={"trigger":"cron","hour":"9"}; static has private: bool=true; }. Triggers: cron interval date.

ASYNC
async walker W { async can f with entry { await op(); } }. async def f() { }. task.__jac__.status/reports/error.
cl {
    # Safe pattern for single-report walkers
    async def example() -> None {
        result = root spawn ListTodos();
        todos = result.reports[0] if result.reports else [];
    }
}

PERMISSIONS
node.__jac__.grant(root, WritePerm); node.__jac__.revoke(root); node.__jac__.check_access(root, ReadPerm);. Levels: NoPerm ReadPerm ConnectPerm WritePerm.

PERSISTENCE
Nodes connected to root auto-persist. save(node); commit();. Reference: &id. Delete: del node; commit();. Globals: glob var: T = val;.

TESTING
test name { assert cond; check cond; }.

STANDARD LIBRARY
print len range enumerate type str int float list dict set. String: upper() lower() strip() split() join(). List: append() extend() pop() sort(). Dict: keys() values() items() get().

JSX AND FRONTEND
sv { } for backend, cl { } for frontend. Effects: can with entry { } mount, can with [dep] entry { } dependency, can with exit { } cleanup. JSX: <Tag prop={val} /> {expr} onClick={fn}.
cl {
    def:pub Timer() -> any {
        has seconds: int = 0;

        # Setup interval on mount
        can with entry {
            intervalId = setInterval(lambda -> None {
                seconds = seconds + 1;
            }, 1000);
        }

        # Cleanup on unmount
        can with exit {
            clearInterval(intervalId);
        }
    ...

PATTERNS
walker DataProcessor {
    has data: str;

    # Runs when spawned at root
    can start with `root entry {
        print("Starting from root");
        visit [-->];
    }

    # Runs when visiting a Person node
    can process with Person entry {
        print(f"Processing {here.name}");
        visit [-->];
    }

    # Runs when visiting any node
    can default with entry {
        print("At unknown node type");
        visit [-->];
    }
}
walker Collector {
    has items: list = [];
    has max_items: int = 10;

    can start with `root entry {
        print("Starting collection");
        visit [-->];
    }

    can collect with DataNode entry {
        if len(self.items) < self.max_items {
            self.items.append(here.value);
        }
        visit [-->];
    }
}
walker:priv MyWalker {
    can do_work with `root entry {
        report "first";   # reports[0]
        report "second";  # reports[1]
    }
}

with entry {
    # Spawning the walker
    response = root spawn MyWalker();
    print(response.reports);  # ["first", "second"]
}
