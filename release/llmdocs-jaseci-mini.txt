Jac: Python superset for AI+graph apps. Install: pip install jaclang. CLI: jac run file.jac, jac serve file.jac, jac test file.jac. Entry: with entry {code}. Syntax: semicolons end statements, braces blocks, f"text {var}". Types required. Files: .jac interface, .impl.jac implementation (auto-import), .test.jac tests.
Types: int str float bool any list[T] dict[K,V] set[T] tuple[T1,T2] T1|T2 T|None. Enum: enum Name {V1,V2}. Control: if/elif/else while for. Match: match v {case type() if c: code; case _: default}. Try: try {} except T as e {}. Lambda: lambda p: type: expr.
Functions: def name(p: type = default) -> ret {body}. Async: async def. Decorators: @decorator. Objects: obj Name {has attr: type; def method() {}}. Auto-constructor. Instantiate: Name(attr=val). Inheritance: obj Child(Parent) {}. Implementation: impl Name.method {code}. Postinit: def postinit {}.
Nodes (graph): node Name {has attr: type; def methods; can abilities with Walker entry|exit {}}. Keywords: here=current node, visitor=walker, self=node. Connect: ++> forward, <++> bi. Typed: +>:EdgeName:+> <+:EdgeName:<+. Filters: [node-->(`?Type)](?attr==val).
Edges: edge Name {has prop: type; can abilities}. Generic: ++> <++. Typed: +>:EdgeName(prop=val):+>. Filter: [node->:EdgeType:->] [node->:Edge:prop>val:->]. Del: del edge.
Walkers (traverse): walker Name {has state: type; can abilities}. Spawn: node spawn Walker() or root spawn Walker(). Visit: visit [-->] out, visit [<--] in, visit [<-->] both. Type: visit [-->(`?Type)]. Edge: visit [->:EdgeType:->]. Multi: visit [-->-->-->]. Control: disengage exit, skip current. Report: report val. Abilities: can ability with entry|exit, can ability with NodeType entry|exit. Root: can ability with `root entry {}.
Queries: [node-->] succ, [<--node] pred, [-->(`?Type)] type filter, [-->(`?T)](?a==v) attr filter, [->:EdgeType:->] edge filter, [-->-->] multi-hop. Combine: [-->(`?T)](?a>5)-->(`?Goal)].
Persistence: root per-user. Auto-persist if rooted. save(obj) queue, commit() flush. DB: MongoDB.
byLLM (AI): pip install byllm. import from byllm {Model,Image}. glob llm = Model(model_name="gpt-4o"). AI func: def func(params) -> ret by llm(). Docstrings+sem enhance. Image: Image("path"). Reasoning: by llm(method='Reason'). ReAct: by llm(method='ReAct', tools=[funcs]). Stream: by llm(stream=True). Structured: return obj/enum. Options: temperature max_tokens verbose max_tries.
Jac Cloud: jac serve → localhost:8000/docs. Endpoints: /walker/{name} /walker/{name}/{node_id}. Config: obj __specs__ {static has methods: list=["get","post"]; static has auth: bool=True; static has as_query: list=["param"] or "*"; static has private: bool=False; static has path: str="/custom"}. Response: {"status":200,"reports":[],"returns":[]}. WebSocket: methods:["websocket"] ws://host/websocket. Webhooks: static has webhook: dict. Scheduler: static has schedule: dict={"trigger":"cron|interval|date","hour":"0"} or {"trigger":"interval","seconds":30} or {"trigger":"date","run_date":"ISO8601"}. Upload: has file: UploadFile. Async: async walker, returns id, retrieve: wlk=&id; wlk.__jac__.status.
Environment: DATABASE_HOST DATABASE_NAME REDIS_HOST TOKEN_SECRET TOKEN_TIMEOUT UV_HOST UV_PORT LOGGER_LEVEL SHOW_ENDPOINT_RETURNS SSO_{PLATFORM}_CLIENT_ID SSO_{PLATFORM}_CLIENT_SECRET.
Permissions: NoPerm ReadPerm ConnectPerm WritePerm. Grant: _.allow_root(node,target,level) or grant(node,level). Revoke: _.disallow_root(node,target) or revoke(node). Check: _.check_read_access(node). Custom: def __jac_access__()->AccessLevel {return level}.
SSO: Platforms: APPLE GOOGLE GOOGLE_ANDROID GOOGLE_IOS FACEBOOK GITHUB. Callback: GET /sso/{provider}/register/callback?id_token={token}.
Testing: test name {assert cond; assert val==expected}. Run: jac test file.jac.
Object-Spatial: Computation moves to data. Nodes=locations, edges=relationships, walkers=mobile agents, abilities=event-driven. Order: location entry→walker entry→visits→walker exit→location exit. Queue: FIFO, visit adds, empty=deactivates at node.
Patterns: BFS: walker with visited set+queue. DFS: walker with visited set+recursive visits. RAG: node Document {has text:str; embedding:list}. def embed(text)->list. def find_similar(emb,docs)->list. def answer(q,ctx)->str by llm(). Social: node User; edge Follow; node Post. walker GetFeed visits users+follows+posts. E-commerce: node Product Order; edge Contains. walker Checkout processes cart. Task: node Task; edge DependsOn. walker Schedule checks deps. Game: def generate_level(prev,difficulty)->Level by llm(). Trading: def make_transaction(buyer,seller,item)->bool. def npc_chat(player,npc,history)->Chat by llm(method='ReAct',tools=[transaction]). Multimodal: enum QueryType. def classify()->QueryType by llm(). walker Route dispatches by type.
Common: Singleton check exists. Pagination slice results. Caching node Cache {key value expires}. Rate limit node RateLimit {user count window}. Audit log node AuditLog {action user timestamp}. Soft delete has is_deleted deleted_at. Versioning node Version. Event sourcing node Event. Multi-tenancy per-root isolation. Background async walker+schedule.
Advanced: Actor nodes=actors edges=channels. CQRS separate read/write models. Saga try/compensate. Pub-sub Event+Subscriber nodes.
Performance: Filter early [-->(`?T)](?attr>val). Batch saves then commit(). Generators for large data. Cache multi-level. Async for I/O. Limit depth+use filters.
Debugging: print(). printgraph(node,depth). walker Debug inspects. curl for API. /docs OpenAPI. Logs tail -f. Export: printgraph(dot_file="g.dot"); dot -Tpng g.dot.
Integration: Python libs, REST, DBs, queues callable from walkers.
Migration: Python class→obj/node. __init__→has. Collections→nodes/edges. Iteration→walker traversal.
Breaking v0.8+: impl not :obj:. Inheritance Class(Base) not :Base:. def for funcs, can for abilities only. visitor not here in nodes. lambda x:type:expr. Arrows ->:Edge:-> +>:Edge:+>. import from pkg {items}. Jac.perm_grant/revoke. assert in tests. global/nonlocal keywords. printgraph not dotgen. byllm Model(model_name).
Best practices: Nodes for entities, obj for values, walkers for ops. Separate .jac/.impl.jac/.test.jac. Type always. Validate inputs. Try/except errors. Report not raise in APIs. Limit depth. Index at root. Batch commits. Cache. Async heavy tasks. Auth sensitive ops. Permissions for data. Env vars for secrets. HTTPS prod. Log JSON. Monitor. Health checks. Document. Semantic strings for AI.
Keywords: with entry, has, can, def, impl, glob, obj, node, edge, walker, spawn, visit, disengage, skip, report, sem, by, `root, self, here, visitor, path, del, async/await, match/case, try/except/raise, import/from, for/while, if/elif/else, return, break/continue, and/or/not, in, is, lambda, type, enum.
CLI: jac run/serve/test/build/format/check/clean. jac tool ir ast/py. Options: --verbose --debug.
Tools: pip install jac-streamlit. jac streamlit app.jac. VS Code: jaclang-extension. Jac-Lens graph explorer. Jac Playground web IDE.
Philosophy: Scale-agnostic local/cloud. Object-Spatial computation-to-data. AI-first byLLM. Graph-native nodes/edges/walkers. Python compatible superset. Type-safe. Auto-API walkers→endpoints. Per-user root isolation. Event-driven abilities. Bidirectional polymorphism.
Quick syntax: has name:type=val. glob name=val. def name(params)->type{body}. obj Name{has;def}. node Name{has;def;can}. edge Name{has}. walker Name{has;can}. node1++>node2. [node-->]. [expr](?cond). spawn walker(). visit [nodes]. report val. import from pkg{items}. with entry{code}. test name{assert}. def func()->type by llm(). lambda x:type:expr. match val{case p:action}. try{}except E{}. impl Class.method(){}. `root or root. here visitor self path. disengage skip. del edge. save(obj) commit().
