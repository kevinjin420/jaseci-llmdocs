JAC LANGUAGE COMPREHENSIVE REFERENCE. Jac is Object-Spatial Programming language with graph-native data structures, walker-based computation, AI integration via byLLM. Python interop.
Variables: has name: type = value declares instance variable. glob varname = value declares global. static has name = value declares static class variable. Example: has count: int = 0; glob total: float = 100.5; static has instance_count = 0.
Type system: str, int, float, bool, list[type], dict[key_type, val_type], tuple[type1, type2], set[type], any. Optional types: type | None or ?type. Union: type1 | type2. Example: has name: str = "default"; has items: list[int] = []; has mapping: dict[str, int] = {}; has optional: str | None = None.
Type inference: Variables infer type from assignment when not annotated. Example: x = 5 infers int; y = "text" infers str; z = [1,2,3] infers list[int].
Constants: Use glob with uppercase. Example: glob MAX_SIZE: int = 1000; glob PI: float = 3.14159.
Operators: Arithmetic +,-,*,/,//,%,**. Comparison ==,!=,<,>,<=,>=. Logical and,or,not. Membership in, not in. Identity is, is not. Bitwise &,|,^,~,<<,>>. Assignment =,+=,-=,*=,/=,//=,%=,**=. Walrus := for inline assignment. Example: if (n := len(items)) > 5 {print(n);}.
String operations: Concatenation with +. f-strings: f"value is {var}". Methods: .upper(), .lower(), .strip(), .split(), .join(), .replace(), .find(), .startswith(), .endswith(). Example: text = f"Hello {name}"; parts = text.split(" "); joined = " ".join(parts).
String formatting: f"text {var}" or f"text {var:format}". Format specs: {x:.2f} for 2 decimals, {x:>10} right align, {x:<10} left align, {x:^10} center. Example: f"Price: ${price:.2f}"; f"Name: {name:<20}".
List operations: append(), extend(), insert(), remove(), pop(), clear(), index(), count(), sort(), reverse(). Slicing: list[start:end:step]. Comprehensions: [expr for item in iterable if condition]. Example: nums = [1,2,3]; nums.append(4); evens = [x for x in nums if x % 2 == 0]; first_two = nums[:2].
Dict operations: keys(), values(), items(), get(key, default), pop(key), update(), clear(). Comprehensions: {k:v for k,v in items if condition}. Example: data = {"a": 1}; data["b"] = 2; keys = list(data.keys()); val = data.get("c", 0); lookup = {k:v*2 for k,v in data.items()}.
Set operations: add(), remove(), discard(), union(), intersection(), difference(), symmetric_difference(). Operators: | (union), & (intersection), - (difference), ^ (symmetric difference). Example: s1 = {1,2,3}; s2 = {2,3,4}; union = s1 | s2; intersect = s1 & s2.
Tuple operations: Immutable sequences. Unpacking: a, b, c = (1, 2, 3). Named tuples: from collections import namedtuple; Point = namedtuple('Point', ['x', 'y']); p = Point(1, 2). Example: coords = (10, 20); x, y = coords; data = (1, "text", True).
Control flow if: if condition {block} elif condition {block} else {block}. Example: if score > 90 {grade = "A";} elif score > 80 {grade = "B";} else {grade = "C";}.
Control flow for: for item in iterable {block}. For index: for i in range(start, end, step) {block}. Enumerate: for idx, val in enumerate(items) {block}. Dict iteration: for key, val in dict.items() {block}. Example: for i in range(5) {print(i);}; for name in users {process(name);}; for i, item in enumerate(items) {print(f"{i}: {item}");}.
Control flow while: while condition {block}. Use break to exit, continue to skip iteration. Example: while count < 10 {count += 1; if count == 5 {continue;}; print(count);}.
Control flow match: match value {case pattern1: action1; case pattern2: action2; case _: default_action;}. Patterns: literals, types, guards. Example: match status {case "active": process(); case "pending": wait(); case _: error();}.
Pattern matching: match value {case int() as n if n > 0: positive(); case str() as s: text_handle(s); case [first, *rest]: list_handle(first, rest); case {"key": val}: dict_handle(val); case _: default();}. Example: match data {case {"type": "user", "id": uid}: load_user(uid); case {"type": "post", "content": text}: create_post(text); case _: invalid();}.
Exception handling: try {code} except ExceptionType as e {handle} except AnotherType {handle} else {no_error_code} finally {always_runs}. Raise: raise ExceptionType("message"). Custom: class MyError(Exception) {pass}. Example: try {result = risky_op();} except ValueError as e {print(f"Error: {e}");} except Exception {print("Unknown error");} finally {cleanup();}.
Context managers: with resource as var {use(var)}. Auto cleanup. Example: with open("file.txt") as f {data = f.read();}. Multiple: with open("in.txt") as fin, open("out.txt", "w") as fout {fout.write(fin.read());}.
Functions basic: def func_name(param1: type1, param2: type2 = default) -> return_type {body; return value;}. No return type if void. Example: def add(a: int, b: int) -> int {return a + b;}; def greet(name: str = "World") -> str {return f"Hello {name}";}.
Functions variadic: *args for variable positional args (tuple), **kwargs for variable keyword args (dict). Example: def sum_all(*nums: int) -> int {return sum(nums);}; def config(**opts: str) -> dict {return opts;}; sum_all(1,2,3); config(host="localhost", port=8080).
Functions nested: Define functions inside functions. Closures capture outer scope. Example: def outer(x: int) -> callable {def inner(y: int) -> int {return x + y;}; return inner;}; add5 = outer(5); result = add5(3).
Functions higher-order: Functions as first-class values. Pass functions as arguments, return functions. Example: def apply(func: callable, val: int) -> int {return func(val);}; def double(x: int) -> int {return x * 2;}; result = apply(double, 5).
Lambda functions: lambda param: type: expression creates anonymous function. Example: square = lambda x: int: x * x; result = square(4); sorted_items = sorted(items, key=lambda item: tuple: item[1]).
Decorators: @decorator syntax modifies functions. Example: def timer(func) {def wrapper(*args, **kwargs) {start = time(); result = func(*args, **kwargs); print(f"Took {time()-start}s"); return result;}; return wrapper;}; @timer def slow_func() {sleep(1);}.
Objects definition: obj ClassName {has attr1: type = default; has attr2: type; def method(self, params) -> type {body}}. Constructor auto-generated from has declarations. Example: obj Person {has name: str; has age: int = 0; def greet(self) -> str {return f"Hi, I'm {self.name}";}}.
Objects initialization: instance = ClassName(param=value, param2=value2). Params match has declarations. Example: obj Point {has x: int; has y: int;}; p = Point(x=10, y=20); print(p.x, p.y).
Objects methods: def method_name(self, params) -> return_type {body}. Access instance via self. Example: obj Calculator {has value: int = 0; def add(self, n: int) -> int {self.value += n; return self.value;}}; calc = Calculator(); calc.add(5).
Objects inheritance: obj Child(Parent) {has additional_attrs; def methods}. Inherits parent attributes and methods. Override by redefining. Example: obj Animal {has name: str; def speak(self) -> str {return "sound";}}; obj Dog(Animal) {def speak(self) -> str {return "bark";}}; d = Dog(name="Rex"); d.speak().
Objects static: static has attr = value creates class variable shared by all instances. Access via ClassName.attr or self.attr. Example: obj Counter {static has count: int = 0; has id: int; def postinit {Counter.count += 1; self.id = Counter.count;}}.
Objects special methods: postinit called after construction. Example: obj Database {has conn; def postinit {self.conn = connect();}; def predelete {self.conn.close();}}; db = Database().
Implementation separation: Define interface in file.jac, implementation in file.impl.jac (auto-imported). Example: file.jac: obj Calculator {has val: int; def add(n: int) -> int;}; file.impl.jac: impl Calculator.add(n: int) -> int {self.val += n; return self.val;}.
Implementation syntax: impl ClassName.method_name(params) -> return_type {body}. For functions: impl function_name(params) -> return_type {body}. Example: def process(data: str) -> str; impl process(data: str) -> str {return data.upper();}.
Nodes definition: node NodeName {has attributes; def methods; can abilities with WalkerType entry/exit {body}}. Nodes are graph vertices with spatial awareness. Example: node User {has username: str; has email: str; def validate(self) -> bool {return "@" in self.email;}}; node Post {has content: str; has created: str; can process with Moderator entry {visitor.check(here.content);}}.
Node abilities: can ability_name with WalkerType entry/exit {body}. Executes when WalkerType visits (entry) or leaves (exit). here=current node, visitor=walker instance. Example: node Task {has status: str; can start with Worker entry {here.status = "running"; visitor.log(f"Started {here}");}; can finish with Worker exit {here.status = "done";}}.
Edges definition: edge EdgeName {has properties; can abilities}. Edges connect nodes and can store data. Example: edge Friendship {has strength: float; has since: str;}; edge Follows {has notify: bool = True;}; edge ParentOf {}.
Edge operations: Create with connection operators. Generic: node1 ++> node2 (unidirectional), node1 <++> node2 (bidirectional). Typed: node1 +>:EdgeType:+> node2, node1 <+:EdgeType:<+ node2. With attributes: node1 +>:EdgeType:attr=val, attr2=val2:+> node2. Example: alice +>:Friendship:strength=0.9:+> bob; root <++> child; user +>:Follows:notify=True:+> celebrity.
Walkers definition: walker WalkerName {has state_vars; can abilities with NodeType entry/exit {body}}. Walkers traverse graphs and perform operations. Example: walker Crawler {has visited: list = []; has max_depth: int = 3; can crawl with Page entry {here.fetch(); visit [here --> (`?Page)];}}; walker Analyzer {has results: dict = {}; can analyze with DataNode entry {here.process(); visitor.results[here.id] = here.value;}}.
Walker abilities: can ability_name with NodeType entry/exit {body}. Entry fires on visit, exit on leave. Use here for current node, visitor in node abilities for walker, self for walker itself. Example: walker Validator {has errors: list = []; can check with Document entry {if not here.valid() {self.errors.append(here.id);}}}.
Walker spawning: node spawn WalkerName(params) spawns walker starting at node. Example: root spawn Crawler(max_depth=5); user spawn NotificationSender(message="Hello").
Walker visiting: visit [node_expression] moves walker to specified nodes. visit [list_of_nodes] visits multiple. Example: visit [here -->]; visit [here --> (`?User)](?is_active); visit [-->] else {disengage;}.
Walker reporting: report value sends value back to caller/API response. Multiple reports accumulate in list. Example: walker Query {can search with Result entry {report here.data;}}; results = root spawn Query(); access via results.
Walker control: disengage stops walker execution immediately. Example: walker FirstMatch {can find with Node entry {if here.matches() {report here; disengage;} visit [-->];}}..
Root node: `root or root references the root node of graph. Every user has own root in Jac Cloud. Example: walker Init {can setup with `root entry {profile = here ++> Profile();}}; root spawn Init().
Node references: &"node_id" or &variable creates reference to node by id. Example: friend_id = "n::123abc"; friend = &friend_id; friend.message = "Hi".
Graph connections: ++> connects nodes creating edge. <++> bidirectional. +>:Type:+> typed edge. <+:Type:<+ typed bidirectional. -[edge]-> for edge instance. Example: a ++> b; x <++> y; user +>:Follows:+> topic; post -[comment_edge]-> reply.
Traversal successors: [node -->] returns list of successor nodes. [node -->:EdgeType:->] filters by edge type. Example: children = [parent -->]; followers = [user -->:Follows:->]; all_next = [current -->].
Traversal predecessors: [<-- node] returns list of predecessor nodes. [<-:EdgeType:<- node] filters by edge type. Example: parents = [<-- child]; followed_by = [<-:Follows:<- user].
Traversal edges: [node --->] returns outgoing edges. [<--- node] returns incoming edges. Example: out_edges = [node --->]; in_edges = [<--- node]; friend_edges = [user --->:Friendship:->].
Traversal filtering by type: (`?NodeType) filters by node type, (`?EdgeType) filters by edge. Example: users = [root --> (`?User)]; posts = [user --> (`?Post)]; friendships = [person --->:(`?Friendship):->].
Traversal filtering by condition: [expr](?condition) filters results by boolean expression. Condition uses item context. Example: active_users = [root --> (`?User)](?is_active); recent_posts = [user --> (`?Post)](?created > cutoff); high_value = [-->](?value > 100).
Traversal chaining: Chain traversal expressions. Example: friends_posts = [user -->:Follows:-> (`?User) --> (`?Post)]; two_hops = [node --> --> (`?Target)]; filtered_chain = [start --> (`?Mid)](?active) --> (`?End)](?valid).
Traversal depth: Control depth with multiple -->. [node -->] is depth 1, [node --> -->] is depth 2. Example: immediate = [node -->]; two_levels = [node --> -->]; three_levels = [node --> --> -->].
Context references: here references current node in walker context, visitor references walker in node context, self references current object/walker/node, root references root node. Example: walker W {can act with Node entry {print(here.value); visitor.state = here; self.count += 1;}}; node N {can react with W entry {visitor.result = here.data;}}.
Graph modification: del node deletes node. node.attr = val modifies attribute. node1 ++> node2 creates connection. Example: old = [root --> (`?Expired)][0]; del old; user.status = "active"; new_node = Node(); root ++> new_node.
Persistence: save(obj) marks object for save. commit() saves all modified objects. commit(obj) saves specific object. Auto-save on API response in Jac Cloud. Example: node.value = 100; save(node); commit(); new_user = User(); save(new_user); commit(new_user).
Graph inspection: printgraph(node=root, bfs=True, depth=N, node_limit=N, edge_limit=N, edge_type=[], dot_file="path") generates graph visualization. Returns dict or writes dot file. Example: data = printgraph(node=root, depth=3); printgraph(node=start, dot_file="graph.dot", edge_type=["Follows"]).
Import statements: import module imports Python/Jac module. import from package {item1, item2} imports specific items. Example: import json; import from collections {defaultdict, Counter}; import from mymodule {MyClass, my_function}.
Module access: Use dot notation. Example: import math; result = math.sqrt(16); import from datetime {datetime}; now = datetime.now().
Entry point: with entry {code} defines program entry. Executes when file runs. Example: with entry {root = Root(); root spawn Setup(); print("Done");}.
Enums: enum EnumName {VALUE1, VALUE2, VALUE3}. Access: EnumName.VALUE1. Example: enum Status {PENDING, ACTIVE, DONE}; task_status = Status.PENDING; if status == Status.ACTIVE {process();}.
Assertions: assert condition raises AssertionError if false. In test blocks, reports failure instead. Optional message: assert condition, "message". Example: assert len(items) > 0; assert user.age >= 18, "Must be adult"; test check_valid {assert node.is_valid();}.
Testing: test test_name {code with assertions} defines test. Run with jac test file.jac. Example: test create_user {u = User(name="test"); assert u.name == "test"; assert u.is_valid();}; test graph_structure {root ++> Node(); children = [root -->]; assert len(children) == 1;}.
Global scope: global varname declares variable as global inside function. nonlocal varname for enclosing scope. Example: glob counter = 0; def increment() {global counter; counter += 1;}; def outer() {x = 0; def inner() {nonlocal x; x += 1;}; inner();}.
Comprehensions: [expr for item in iterable if condition] list. {expr for item in iterable if condition} set. {k:v for item in iterable if condition} dict. (expr for item in iterable) generator. Example: squares = [x*x for x in range(10)]; evens = {x for x in range(20) if x % 2 == 0}; lookup = {x: x*x for x in range(5)}.
Generator expressions: (expr for item in iterable) creates lazy iterator. Example: large = (process(x) for x in huge_list); for item in large {use(item);}.
Slicing: sequence[start:end:step]. Negative indices from end. Omit for defaults. Example: nums[2:5] gets items 2,3,4; nums[:3] first 3; nums[3:] from 3 to end; nums[-2:] last 2; nums[::2] every other; nums[::-1] reversed.
byLLM setup: import from byllm {Model}. glob llm = Model(model_name="model_id", verbose=bool, temperature=float, timeout=int). Model names: "gpt-4o", "gemini/gemini-2.0-flash", "claude-3-5-sonnet", "anthropic/claude-3-5-sonnet". Example: glob llm = Model(model_name="gpt-4o", temperature=0.7, verbose=True).
byLLM function integration: def function_name(params) -> return_type by llm(options). Auto-generates implementation via LLM. Example: def summarize(text: str) -> str by llm(); def classify(content: str) -> Category by llm(); result = summarize("long text here").
byLLM method integration: obj/node/walker methods can use by llm. Example: obj Article {has content: str; def summary(self) -> str by llm();}; a = Article(content="text"); a.summary().
byLLM reasoning: by llm(method='Reason') enables chain-of-thought reasoning. Example: def solve_math(problem: str) -> int by llm(method='Reason'); def analyze_complex(data: dict) -> Analysis by llm(method='Reason').
byLLM ReAct: by llm(method='ReAct', tools=[func1, func2]) enables agent with tools. Agent can call tools during execution. Example: def search_web(query: str) -> str {return api_call(query);}; def assistant(question: str, context: dict) -> str by llm(method='ReAct', tools=[search_web]); result = assistant("What's the weather?", {}).
byLLM streaming: by llm(stream=True) returns iterator. Example: def generate(prompt: str) -> str by llm(stream=True); for token in generate("Write story") {print(token, end="");}.
byLLM structured output: Return custom obj/enum types. LLM generates valid instances. Example: obj Person {has name: str; has age: int;}; enum Sentiment {POSITIVE, NEGATIVE, NEUTRAL}; def extract(text: str) -> Person by llm(); def analyze(text: str) -> Sentiment by llm(); person = extract("John, 25 years old"); feeling = analyze("I love this!").
byLLM context enhancement: Use docstrings for function description. sem ClassName.attr = "description" for semantic hints. by llm(incl_info={"key": "value"}) for additional context. Example: def categorize(item: str) -> Category by llm() """Categorize item into predefined categories"""; obj Product {has name: str; sem name = "product display name for customers";}; def custom(data: str) -> Result by llm(incl_info={"domain": "medical", "format": "JSON"}).
byLLM multimodal: import from byllm {Image, Video}. Pass Image/Video objects to LLM functions. Example: import from byllm {Image, Video}; def describe_image(img: Image) -> str by llm(); def analyze_video(vid: Video) -> Summary by llm(); img = Image("photo.jpg"); desc = describe_image(img); vid = Video(path="clip.mp4", fps=1); summary = analyze_video(vid).
byLLM Python usage: from byllm import Model, by. @by(llm) decorator for Python functions. Example: from byllm import Model; llm = Model(model_name="gpt-4o"); @by(llm) def extract(text: str) -> dict: ...; result = extract("data").
byLLM custom models: class MyLLM(BaseLLM) {def __infer__(self, meaning_in, **kwargs) -> str {custom_logic; return response;}}. Override prompting. Example: class LocalLLM(BaseLLM) {def __infer__(self, meaning_in, **kwargs) -> str {return local_model.generate(meaning_in);}}.
Data Spatial Programming philosophy: Organize data as spatial graphs not flat collections. Relationships are first-class. Navigate with walkers. Example: Users connected by Friendship edges, Posts connected to Users via Created edges. Walker traverses friend network to aggregate posts.
Data Spatial patterns: BFS traversal with visit [-->]. DFS with recursive visits. Accumulation via walker state. Filtering with type and condition. Example: walker BFS {has visited: set = set(); has results: list = []; can search with Node entry {if here not in self.visited {self.visited.add(here); self.results.append(here); visit [-->];}}}.
Walker state management: Use has attributes to maintain state across visits. Example: walker Counter {has count: int = 0; has total: int = 0; can process with Node entry {self.count += 1; self.total += here.value;}}.
Node entry/exit order: Walker visits node (entry abilities execute), walker leaves node (exit abilities execute). Order: walker entry → node entry → node exit → walker exit. Example: walker W {can arrive with N entry {print("walker enters");}; can leave with N exit {print("walker exits");}}; node N {can greet with W entry {print("node entry");}; can goodbye with W exit {print("node exit");}}.
Spatial queries: Combine traversal, type filters, condition filters. Example: [root --> (`?User)](?age > 18 and is_active); [user -->:Follows:-> (`?Topic)](?category == "tech"); [start --> --> (`?Goal)](?distance < max_dist).
Graph algorithms: Implement with walkers. Example Dijkstra: walker ShortestPath {has distances: dict; has unvisited: set; can traverse with Node entry {update_distances(); visit unvisited_neighbors();}}.
Jac Cloud server: jac serve file.jac --host 0.0.0.0 --port 8080 --reload. Auto-generates REST API from walkers. Example: jac serve app.jac starts server at http://localhost:8000. API docs at /docs.
Walker endpoints: walker name becomes /walker/name endpoint. Methods specified via __specs__. Example: walker create_user {has name: str; has email: str; obj __specs__ {static has methods: list = ["post"]; static has auth: bool = True;}}. Call: POST /walker/create_user with JSON body {"name": "Alice", "email": "alice@example.com"}.
Endpoint configuration: obj __specs__ {static has methods: list = ["get","post","put","delete"]; static has auth: bool = True/False; static has as_query: list = ["param"] or "*"; static has path: str = "/custom"; static has private: bool = False;}. Example: walker search {has query: str; obj __specs__ {static has methods: list = ["get"]; static has auth: bool = False; static has as_query: list = ["query"];}}. Call: GET /walker/search?query=test.
API response format: {"status": 200, "reports": [list of reported values], "returns": [return values if enabled]}. Example: walker info {can get with `root entry {report {"version": "1.0"}; report {"status": "ok"};}}. Response: {"status": 200, "reports": [{"version": "1.0"}, {"status": "ok"}]}.
Query parameters: as_query: list = ["field1", "field2"] or "*" for all. Parameters passed from URL query string. Example: walker filter {has category: str; has min_price: float; obj __specs__ {static has methods: list = ["get"]; static has as_query: list = ["category", "min_price"];}}. Call: GET /walker/filter?category=books&min_price=10.5.
Authentication: auth: bool = True requires Bearer token in Authorization header. Token from /user/login endpoint. Example: walker protected {obj __specs__ {static has auth: bool = True;}}. Call: POST /walker/protected with header "Authorization: Bearer YOUR_TOKEN".
File uploads: import from fastapi {UploadFile}. Use UploadFile type for file parameters. Example: walker upload {has file: UploadFile; has name: str; can process with `root entry {content = visitor.file.file.read(); save_file(content, self.name);}}. Call: POST /walker/upload with multipart/form-data.
Private walkers: private: bool = True hides from API, only callable internally or via scheduling. Example: walker internal_cleanup {obj __specs__ {static has private: bool = True;}}. Not accessible via HTTP.
WebSocket walkers: methods: list = ["websocket"] enables WebSocket. URL: ws://host/websocket. Example: walker chat {has message: str; obj __specs__ {static has methods: list = ["websocket"];}}. Connect: ws://localhost:8000/websocket. Send: {"type": "walker", "walker": "chat", "context": {"message": "Hello"}}.
WebSocket connection: Protocol ws. URL /websocket. Optional header Authorization: Bearer TOKEN. Optional query ?channel_id=string. Receives connection event: {"type": "connection", "data": {"client_id": "...", "root_id": "...", "channel_id": "..."}}. Example: const ws = new WebSocket("ws://localhost:8000/websocket?channel_id=room1").
WebSocket client events: Walker event: {"type": "walker", "walker": "name", "response": true, "context": {params}}. User event: {"type": "user", "root_ids": ["id1"], "data": {payload}}. Channel event: {"type": "channel", "channel_ids": ["ch1"], "data": {payload}}. Client event: {"type": "client", "client_ids": ["cl1"], "data": {payload}}. Change user: {"type": "change_user", "token": "Bearer TOKEN"}. Connection info: {"type": "connection"}. Example: ws.send(JSON.stringify({"type": "walker", "walker": "chat", "context": {"message": "hi"}})).
WebSocket server notifications: import from jac_cloud.plugin {WEBSOCKET_MANAGER as socket}. socket.notify_self(data) sends to current client. socket.notify_users([root1, root2], data) sends to users. socket.notify_channels([ch1, ch2], data) sends to channels. socket.notify_clients([cl1, cl2], data) sends to clients. Example: walker broadcast {has msg: str; can send with `root entry {socket.notify_channels(["public"], {"text": self.msg});}}.
Webhooks: walker with webhook in __specs__. obj __specs__ {static has webhook: dict = {"type": "header|query|path|body", "name": "API-KEY"}}. Endpoint: /webhook/walker/name. Example: walker webhook_handler {obj __specs__ {static has webhook: dict = {"type": "header", "name": "X-API-KEY"};}; can handle with `root entry {report here;}}. Call: POST /webhook/walker/webhook_handler with header X-API-KEY: generated_key.
Webhook key generation: POST /webhook/generate-key with body {"name": "key1", "walkers": ["walker1"], "nodes": ["root"], "expiration": {"count": 60, "interval": "days"}}. Response: {"id": "...", "name": "key1", "key": "root_id:timestamp:secret"}. Example: Generate key for external service integration.
Webhook key management: GET /webhook lists all keys. PATCH /webhook/extend/{id} with body {"count": 30, "interval": "days"} extends expiration. DELETE /webhook/delete with body {"ids": ["id1", "id2"]} deletes keys. Example: List all webhook keys to audit access.
Async walkers: async walker name {code}. Returns walker_id immediately. Retrieve results: wlk = &walker_id; wlk.__jac__.status, wlk.__jac__.reports, wlk.__jac__.error. Example: async walker heavy_task {has data: list; can process with `root entry {for item in self.data {compute(item);}}}; result = root spawn heavy_task(data=large_dataset); task_id = result; later: task = &task_id; if task.__jac__.status == "completed" {results = task.__jac__.reports;}.
Scheduling cron: obj __specs__ {static has schedule: dict = {"trigger": "cron", "hour": "0", "minute": "30", "second": "0", "day": "*", "month": "*", "year": "*", "args": [val1], "kwargs": {"key": val2}, "save": True}}. Example: walker daily_report {obj __specs__ {static has private: bool = True; static has schedule: dict = {"trigger": "cron", "hour": "9", "minute": "0", "save": True};}; can generate with `root entry {report generate_report();}}.
Scheduling interval: obj __specs__ {static has schedule: dict = {"trigger": "interval", "seconds": 30, "minutes": 0, "hours": 0, "days": 0, "weeks": 0, "save": True}}. Example: walker health_check {obj __specs__ {static has schedule: dict = {"trigger": "interval", "minutes": 5};}; can check with `root entry {status = check_services(); report status;}}.
Scheduling date: obj __specs__ {static has schedule: dict = {"trigger": "date", "run_date": "2025-12-31T23:59:00+00:00", "save": True}}. Runs once at specified datetime. Example: walker year_end {obj __specs__ {static has schedule: dict = {"trigger": "date", "run_date": "2025-12-31T23:59:59"};}; can close_year with `root entry {finalize_records();}}.
Scheduling options: max_instances: int = 1 limits concurrent runs. next_run_time: datetime sets first run. propagate: bool = False allows multiple services to trigger. save: bool = True persists walker instance. Example: walker sync {obj __specs__ {static has schedule: dict = {"trigger": "interval", "minutes": 10, "max_instances": 1, "save": True};}}.
Task queue: import from jac_cloud.plugin.implementation {create_task}. create_task(walker_instance, target_node) creates async task. Requires TASK_CONSUMER_CRON_SECOND env var. Example: walker process_item {has item_id: str; obj __specs__ {static has private: bool = True;}; can process with Node entry {process_logic();}};walker queue_work {can queue with `root entry {items = [root --> (`?Item)]; for item in items {task = create_task(process_item(item_id=item.id), item); report task;}}}.
SSO configuration: Set env vars SSO_{PLATFORM}_CLIENT_ID, SSO_{PLATFORM}_CLIENT_SECRET. Platforms: APPLE, GOOGLE, GOOGLE_ANDROID, GOOGLE_IOS, FACEBOOK, GITHUB, MICROSOFT, LINKEDIN, TWITTER, GITLAB, KAKAO, NOTION, YANDEX, FITBIT, LINE, NAVER. Example: export SSO_GOOGLE_CLIENT_ID="123.apps.googleusercontent.com"; export SSO_GOOGLE_CLIENT_SECRET="secret".
SSO Apple specific: SSO_APPLE_CLIENT_ID, SSO_APPLE_CLIENT_TEAM_ID, SSO_APPLE_CLIENT_KEY, SSO_APPLE_CLIENT_CERTIFICATE_PATH or SSO_APPLE_CLIENT_CERTIFICATE. Example: export SSO_APPLE_CLIENT_ID="com.myapp"; export SSO_APPLE_CLIENT_TEAM_ID="TEAM123".
SSO callback: GET /sso/{provider}/register/callback?id_token={token}. Provider: apple, google, google_android, google_ios, facebook, github, etc. Returns user info and auth token. Example: Frontend gets id_token from Google SDK. Call: GET /sso/google/register/callback?id_token=eyJhbG... Response: {"email": "user@gmail.com", "name": "User", "token": "jac_token"}.
Permissions levels: NoPerm (no access), ReadPerm (view only), ConnectPerm (can create edges), WritePerm (full access). Control multi-user data access. Example: Post visible to followers with ReadPerm, friends with ConnectPerm to comment.
Permission granting: _.allow_root(node, target_root, level) grants specific user access. grant(node, level) grants all users access. Example: walker share_post {has post_id: str; has friend_id: str; can share with `root entry {post = &self.post_id; friend_root = &self.friend_id; _.allow_root(post, friend_root, "READ");}}.
Permission revoking: _.disallow_root(node, target_root) revokes specific user access. revoke(node) revokes all public access. Example: walker make_private {has post_id: str; can hide with `root entry {post = &self.post_id; revoke(post);}}.
Permission checking: _.check_read_access(node, skip_custom=False) returns AccessLevel. _.check_write_access(node), _.check_connect_access(node). Example: walker can_edit {has doc_id: str; can check with `root entry {doc = &self.doc_id; level = _.check_write_access(doc); report level == AccessLevel.WRITE;}}.
Custom access control: node with def __jac_access__() -> AccessLevel {logic; return level;}. Called on access attempts. Return NoPerm, ReadPerm, ConnectPerm, WritePerm. Example: node Document {has owner_id: str; has is_public: bool; def __jac_access__() -> AccessLevel {if here.is_public {return ReadPerm;}; if _Jac.get_root().id == here.owner_id {return WritePerm;}; return NoPerm;}}.
Utility APIs: GET /util/traverse?source=jid&detailed=bool&depth=int&node_types=Type1&node_types=Type2&edge_types=Edge1. Returns {"nodes": [...], "edges": [...]}. GET /util/traverse-stream for streaming. Example: GET /util/traverse?source=n::root123&depth=2&node_types=User&node_types=Post&detailed=true returns full graph data up to 2 hops.
Database persistence: Data auto-saves on API response. Manual: save(node/edge/walker), commit() or commit(obj). Objects stored in MongoDB. Example: new_user = User(name="Alice"); save(new_user); commit(); later: user = [root --> (`?User)](?name == "Alice")[0]; user.age = 30; commit(user).
Environment DATABASE: DATABASE_HOST (MongoDB host), DATABASE_NAME (db name), DATABASE_PORT (default 27017). Example: export DATABASE_HOST="localhost"; export DATABASE_NAME="myapp_prod".
Environment REDIS: REDIS_HOST (host), REDIS_PORT (port), REDIS_PASSWORD. Used for WebSocket, task queue, caching. Example: export REDIS_HOST="redis.example.com"; export REDIS_PORT="6379".
Environment AUTH: TOKEN_SECRET (JWT secret), TOKEN_ALGORITHM (default HS256), TOKEN_TIMEOUT (seconds, default 86400). Example: export TOKEN_SECRET="random-secret-string"; export TOKEN_TIMEOUT="604800".
Environment SERVER: UV_HOST (host, default 0.0.0.0), UV_PORT (port, default 8000), UV_WORKERS (workers, default 1). Example: export UV_HOST="0.0.0.0"; export UV_PORT="8080"; export UV_WORKERS="4".
Environment API: SHOW_ENDPOINT_RETURNS (bool, default False shows walker returns in response), DISABLE_AUTO_ENDPOINT (bool), DISABLE_AUTO_CLEANUP (bool), REQUIRE_AUTH_BY_DEFAULT (bool, default True). Example: export SHOW_ENDPOINT_RETURNS="true"; export REQUIRE_AUTH_BY_DEFAULT="false".
Environment LOGGING: LOGGER_NAME (default "app"), LOGGER_LEVEL (debug|info|warning|error), LOGGER_FILE_PATH (default /tmp/jac_cloud_logs/jac-cloud.log), LOGGER_ROLLOVER_INTERVAL (M|H|D|W for minute/hour/day/week), LOGGER_MAX_BACKUP (count, -1 unlimited), LOGGER_ROLLOVER_MAX_FILE_SIZE (bytes), LOGGER_USE_UTC (bool). Example: export LOGGER_LEVEL="info"; export LOGGER_ROLLOVER_INTERVAL="D"; export LOGGER_MAX_BACKUP="30".
Logging JSON format: Logs in JSON with timestamp, level, message, request (method, path, body), response (status, body), duration, client_ip. View: tail -f /tmp/jac_cloud_logs/jac-cloud.log. Search errors: grep '"level":"ERROR"' log_file. Example: {"timestamp": "2025-01-02T10:30:00Z", "level": "INFO", "message": "Request", "request": {"method": "POST", "path": "/walker/create"}, "response": {"status": 200}, "duration": 45}.
Logging Elastic Stack: Install Filebeat. Config filebeat.yml with paths /tmp/jac_cloud_logs/*.log, output to Elasticsearch. Run filebeat -e -c filebeat.yml. Visualize in Kibana. Example: Filebeat ships logs to Elasticsearch, create Kibana dashboard for request analytics.
CLI jac run: jac run file.jac executes entry point. jac run file.jac --main false for module import. Example: jac run app.jac runs with entry block. jac run lib.jac --main false imports without entry.
CLI jac serve: jac serve file.jac --host 0.0.0.0 --port 8000 --reload. --reload auto-reloads on file changes. Example: jac serve api.jac --port 8080 --reload for development.
CLI jac test: jac test file.jac runs all test blocks. jac test dir/ runs all .test.jac files in directory. Reports pass/fail. Example: jac test app.test.jac runs tests. Output shows assertions passed/failed.
CLI jac format: jac format file.jac formats code. jac format dir/ formats all .jac files recursively. --outfile for output path. Example: jac format src/ formats all source files.
CLI jac check: jac check file.jac runs type checker. Reports type errors. Example: jac check app.jac validates type annotations.
CLI jac build: jac build file.jac compiles to .jir (Jac IR). Example: jac build app.jac generates app.jir.
CLI jac clean: jac clean removes __jac_gen__ and __pycache__ directories recursively. Example: jac clean in project root cleans all generated files.
CLI jac enter: jac enter file.jac entrypoint args calls specific function. Example: jac enter app.jac main --config prod.json calls main(config="prod.json").
CLI jac tool ir: jac tool ir ast file.jac shows AST. jac tool ir sym file.jac shows symbol table. jac tool ir py file.jac shows generated Python. jac tool ir ast. file.jac generates AST dot graph. jac tool ir cfg. file.jac generates control flow graph. Example: jac tool ir ast app.jac prints AST tree. jac tool ir ast. app.jac > ast.dot generates dot file.
Streamlit integration: pip install jac-streamlit. jac streamlit app.jac runs Streamlit app. import streamlit as st for UI. Example: jac streamlit dashboard.jac starts web UI. import streamlit as st; st.title("Dashboard"); st.button("Click"); st.text_input("Name").
Streamlit session state: st.session_state.key stores persistent state across reruns. Example: if "count" not in st.session_state {st.session_state.count = 0;}; if st.button("Increment") {st.session_state.count += 1;}; st.write(f"Count: {st.session_state.count}").
Streamlit forms: with st.form("form_name") {inputs; submitted = st.form_submit_button("Submit"); if submitted {process();}}. Example: with st.form("login") {username = st.text_input("Username"); password = st.text_input("Password", type="password"); if st.form_submit_button("Login") {authenticate(username, password);}}.
Streamlit API calls: Use requests to call Jac Cloud API. Example: import requests; token = st.session_state.get("token"); response = requests.post("http://localhost:8000/walker/query", json={"text": query}, headers={"Authorization": f"Bearer {token}"}); data = response.json(); st.write(data["reports"]).
Docker deployment: Dockerfile: FROM python:3.12, COPY . /app, RUN pip install -r requirements.txt, CMD ["jac", "serve", "app.jac", "--host", "0.0.0.0"]. Build: docker build -t myapp .. Run: docker run -p 8000:8000 myapp. Example: Deploy Jac Cloud app in container with dependencies isolated.
Kubernetes deployment: Create deployment.yaml with spec: replicas, containers (image, ports, env), service (LoadBalancer/ClusterIP). Apply: kubectl apply -f deployment.yaml. Scale: kubectl scale deployment myapp --replicas=5. Example: Deploy Jac Cloud app with ConfigMap for env vars, Secret for API keys, Service for load balancing.
Testing patterns: test test_name {setup; assertions; teardown}. Use assert for checks. Test walker behavior, graph structure, API responses. Example: test user_creation {root spawn create_user(name="test"); user = [root --> (`?User)](?name == "test")[0]; assert user exists; assert user.name == "test";}; test graph_traversal {a = Node(); b = Node(); a ++> b; children = [a -->]; assert len(children) == 1; assert children[0] == b;}.
Graph algorithm BFS: walker BFS {has queue: list; has visited: set = set(); can search with Node entry {if here not in self.visited {self.visited.add(here); self.queue.extend([here -->]); process(here);}; if self.queue {visit [self.queue.pop(0)];}}}.
Graph algorithm DFS: walker DFS {has visited: set = set(); can search with Node entry {if here not in self.visited {self.visited.add(here); process(here); for child in [here -->] {if child not in self.visited {visit [child];}}}}}.
Graph algorithm shortest path: walker ShortestPath {has target_id: str; has distances: dict; has previous: dict; has unvisited: set; can search with Node entry {update_distances(); if here.id == self.target_id {report reconstruct_path(); disengage;}; visit unvisited_with_min_distance();}}.
Social network pattern: node User {has username: str; has bio: str;}; edge Follow {has since: str;}; node Post {has content: str; has created: str;}; edge Likes {}; edge Comments {}. Walker for feed: walker GetFeed {has posts: list = []; can collect with User entry {visit [here --> (`?Post)]; visit [here -->:Follow:-> (`?User) --> (`?Post)];}; can gather with Post entry {visitor.posts.append(here);}}.
Document RAG pattern: node Document {has text: str; has embedding: list;}; def embed_text(text: str) -> list {return model.encode(text);}; def find_similar(query_embedding: list, docs: list) -> list {return sorted(docs, key=lambda d: cosine_similarity(query_embedding, d.embedding), reverse=True)[:5];}; def answer_question(question: str, context: list[Document]) -> str by llm(). Example: query = "what is X?"; q_emb = embed_text(query); docs = [root --> (`?Document)]; similar = find_similar(q_emb, docs); answer = answer_question(query, similar).
E-commerce pattern: node Product {has name: str; has price: float; has stock: int;}; node Order {has status: str; has total: float;}; edge Contains {has quantity: int;}; walker Checkout {has cart_items: list; can process with `root entry {order = here ++> Order(status="pending", total=0); for item in self.cart_items {product = &item["id"]; if product.stock >= item["qty"] {order +>:Contains:quantity=item["qty"]:+> product; order.total += product.price * item["qty"]; product.stock -= item["qty"];}; save(order); save(product);} order.status = "confirmed"; commit();}}.
Task management pattern: node Task {has title: str; has status: str; has priority: int;}; edge DependsOn {}; walker ScheduleTasks {has result: list = []; can schedule with Task entry {deps = [<-:DependsOn:<- here]; if all(d.status == "done" for d in deps) {if here.status == "pending" {here.status = "ready"; self.result.append(here);}}; visit [-->];}}.
Game level generation: obj Level {has difficulty: int; has width: int; has height: int; has num_enemies: int;}; obj Map {has level: Level; has walls: list; has enemies: list;}; def generate_level(prev_levels: list[Level], difficulty: int) -> Level by llm(); def generate_map(level: Level) -> Map by llm(). Example: manager = LevelManager(); for i in range(5) {level = generate_level(manager.history, i+1); map = generate_map(level); manager.history.append(level); render(map);}.
Trading system pattern: obj Item {has name: str; has price: float;}; obj Person {has name: str; has money: float; has inventory: list[Item];}; def make_transaction(buyer: Person, seller: Person, item: Item) -> bool {if buyer.money >= item.price and item in seller.inventory {buyer.money -= item.price; seller.money += item.price; buyer.inventory.append(item); seller.inventory.remove(item); return True;}; return False;}; obj Chat {has person: str; has message: str;}; def npc_chat(player: Person, npc: Person, history: list[Chat]) -> Chat by llm(method='ReAct', tools=[make_transaction]). Example: Conversational trading with AI agent that can execute transactions.
Multimodal chatbot pattern: enum QueryType {RAG, WEB_SEARCH, IMAGE, VIDEO, GENERAL}; def classify(query: str, has_files: bool) -> QueryType by llm(); walker Route {has query: str; has files: list; can route with `root entry {qtype = classify(self.query, len(self.files) > 0); if qtype == QueryType.RAG {visit [-->:RAGHandler:->];} elif qtype == QueryType.IMAGE {visit [-->:ImageHandler:->];} elif qtype == QueryType.VIDEO {visit [-->:VideoHandler:->];}}}; node RAGHandler {can handle with Route entry {docs = search_docs(visitor.query); answer = generate_answer(visitor.query, docs); report answer;}}; node ImageHandler {can handle with Route entry {img = Image(visitor.files[0]); desc = analyze_image(img); report desc;}}.
Breaking changes v0.8.0: impl keyword for implementations. impl ClassName.method(params) instead of :obj:Class:def:method. Inheritance: Class(Base) instead of Class :Base:. def for functions/methods, can only for abilities. visitor for walker in node context. Lambda: lambda x: type: expr. Arrows: ->:Edge:-> and +>:Edge:+>. Import: import from pkg {items}. Permissions: Jac.perm_grant/perm_revoke. Testing: assert in test blocks. Global: global x, nonlocal y. printgraph not dotgen. byLLM: import from byllm {Model}; Model(model_name="provider/model").
Breaking changes v0.8.1: printgraph replaces dotgen function. ignore feature removed, use walker state: has ignored: list = []; visit [n for n in [-->] if n not in self.ignored]. Example: walker Traverse {has visited: set = set(); can visit_node with Node entry {self.visited.add(here); visit [n for n in [-->] if n not in self.visited];}}.
Breaking changes v0.8.4: global/nonlocal keywords replace :global:/:g:/:nonlocal:/:nl:. byLLM unified Model class: import from byllm {Model}; Model(model_name="gpt-4o") or Model(model_name="gemini/gemini-2.0-flash"). No separate Gemini/OpenAI classes.
Breaking changes v0.8.8: check keyword removed. Use assert in test blocks. assert reports failures in tests, raises AssertionError in regular code. Example: test validate {node = Node(val=5); assert node.val == 5; assert node.valid();}.
File structure best practice: app.jac defines interfaces (node/walker/obj declarations, can signatures). app.impl.jac defines implementations (impl statements). app.test.jac defines tests. Auto-import: impl file loaded automatically. Example: user.jac: node User {has name: str; def validate() -> bool;}; walker CreateUser {has name: str; can create with `root entry;}. user.impl.jac: impl User.validate() -> bool {return len(self.name) > 0;}; impl CreateUser.create {user = here ++> User(name=self.name); report user;}. user.test.jac: test user_validation {u = User(name="test"); assert u.validate(); u2 = User(name=""); assert not u2.validate();}.
Best practices data modeling: Use nodes for entities with identity and relationships. Use obj for value objects and data transfer. Use edges for meaningful relationships with properties. Example: node Person (entity), obj Address (value), edge LivesAt {has since: str;} (relationship). Person +>:LivesAt:since="2020":+> Address_node.
Best practices API design: Separate read (GET) and write (POST/PUT) endpoints. Use as_query for filters on GET. Require auth for mutations. Return structured reports. Example: walker list_items {has category: str; obj __specs__ {static has methods: list = ["get"]; static has auth: bool = False; static has as_query: list = ["category"];}; can list with `root entry {items = [root --> (`?Item)](?category == self.category); report [i.to_dict() for i in items];}}; walker create_item {has name: str; obj __specs__ {static has methods: list = ["post"]; static has auth: bool = True;}; can create with `root entry {item = here ++> Item(name=self.name); save(item); report item.to_dict();}}.
Best practices error handling: Validate inputs at walker entry. Use try/except for external calls. Report errors via report, don't raise in API walkers. Log errors. Example: walker process {has data: str; can handle with `root entry {if not self.data {report {"error": "data required"}; disengage;}; try {result = external_api(self.data); report {"result": result};} except Exception as e {print(f"Error: {e}"); report {"error": "processing failed"};}}}.
Best practices graph design: Keep graph depth reasonable (< 5-10 levels). Index frequently accessed nodes at root level. Use typed edges for different relationships. Clean up orphaned nodes. Example: root --> User --> [Posts, Friends, Settings] rather than deep nesting. Periodic cleanup walker to remove deleted nodes.
Best practices testing: Test each walker independently. Test graph structure after operations. Test edge cases and errors. Use fixtures for common setups. Example: test setup {root ++> Node(id="test1"); root ++> Node(id="test2");}; test walker_behavior {root spawn MyWalker(); results = [...]; assert len(results) == 2;}; test error_handling {walker = MyWalker(invalid_data=None); try {root spawn walker;} except {...}}.
Best practices AI integration: Provide clear docstrings for context. Use semantic strings for domain terms. Pass relevant data via incl_info. Test AI outputs with multiple inputs. Handle AI failures gracefully. Example: def extract_entities(text: str) -> list[Entity] by llm() """Extract named entities from text. Return list of Entity objects with name and type."""; obj Entity {has name: str; has entity_type: str; sem entity_type = "category: PERSON, ORG, LOCATION, DATE";}.
Best practices performance: Limit traversal depth with conditions. Use filters early in traversal chain. Batch database commits. Cache expensive computations. Use async walkers for heavy tasks. Example: walker Query {has max_depth: int = 3; has depth: int = 0; can search with Node entry {if self.depth >= self.max_depth {disengage;}; self.depth += 1; visit [here --> (`?Target)](?active);}}; Batch saves: nodes = [...]; for n in nodes {save(n);}; commit().
Best practices security: Always require auth for sensitive operations. Validate all inputs. Use permissions for data access control. Rotate TOKEN_SECRET regularly. Use environment variables for secrets. HTTPS in production. Example: walker admin_action {obj __specs__ {static has auth: bool = True;}; can execute with `root entry {user = [root --> (`?User)][0]; if not user.is_admin {report {"error": "unauthorized"}; disengage;}; perform_admin_task();}}.
Best practices deployment: Use environment-specific configs. Set proper logging levels (info for prod). Configure resource limits in K8s. Enable health checks. Monitor metrics. Use secrets for API keys. Example: Production .env: LOGGER_LEVEL=info, TOKEN_TIMEOUT=86400, UV_WORKERS=4, DATABASE_HOST=prod-mongo.example.com. Kubernetes: resources: limits: memory: 512Mi, livenessProbe: httpGet: path: /health.
Common patterns singleton node: Use single instance at root. Example: node Config {has settings: dict;}; walker GetConfig {can get with `root entry {configs = [here --> (`?Config)]; if not configs {config = here ++> Config(settings=load_defaults()); report config;} else {report configs[0];}}}.
Common patterns pagination: Use skip and limit. Example: walker ListItems {has page: int = 1; has per_page: int = 10; can list with `root entry {all_items = [here --> (`?Item)]; start = (self.page - 1) * self.per_page; end = start + self.per_page; page_items = all_items[start:end]; report {"items": page_items, "page": self.page, "total": len(all_items)};}}.
Common patterns caching: Store computed results. Example: node Cache {has key: str; has value: str; has expires: float;}; walker GetCached {has key: str; can get with `root entry {caches = [here --> (`?Cache)](?key == self.key); if caches and caches[0].expires > time() {report caches[0].value;} else {if caches {del caches[0];}; value = compute_expensive(self.key); cache = here ++> Cache(key=self.key, value=value, expires=time()+3600); report value;}}}.
Common patterns rate limiting: Track request counts. Example: node RateLimit {has user_id: str; has count: int; has window_start: float;}; walker CheckLimit {has user_id: str; can check with `root entry {limits = [here --> (`?RateLimit)](?user_id == self.user_id); if limits {limit = limits[0]; if time() - limit.window_start > 60 {limit.count = 0; limit.window_start = time();}; if limit.count >= 100 {report {"error": "rate limit exceeded"}; disengage;}; limit.count += 1;} else {here ++> RateLimit(user_id=self.user_id, count=1, window_start=time());} proceed();}}.
Common patterns audit logging: Track changes. Example: node AuditLog {has action: str; has user_id: str; has timestamp: float; has details: dict;}; walker LogAction {has action: str; has details: dict; can log with `root entry {user = get_current_user(); here ++> AuditLog(action=self.action, user_id=user.id, timestamp=time(), details=self.details); commit();}}.
Common patterns soft delete: Mark as deleted instead of removing. Example: node Item {has name: str; has is_deleted: bool = False; has deleted_at: float | None = None;}; walker DeleteItem {has item_id: str; can delete with `root entry {item = &self.item_id; item.is_deleted = True; item.deleted_at = time(); save(item); commit(); report {"deleted": True};}}; walker ListActive {can list with `root entry {items = [here --> (`?Item)](?not is_deleted); report items;}}.
Common patterns versioning: Track entity versions. Example: node Document {has version: int = 1; has content: str;}; node DocumentVersion {has version: int; has content: str; has created: float;}; walker UpdateDocument {has doc_id: str; has new_content: str; can update with `root entry {doc = &self.doc_id; doc ++> DocumentVersion(version=doc.version, content=doc.content, created=time()); doc.version += 1; doc.content = self.new_content; commit(doc);}}.
Common patterns event sourcing: Store events, replay for state. Example: node Event {has type: str; has data: dict; has timestamp: float;}; walker ApplyEvent {has event_type: str; has data: dict; can apply with `root entry {event = here ++> Event(type=self.event_type, data=self.data, timestamp=time()); save(event); update_state(event); commit();}}; walker ReplayEvents {has events: list = []; can replay with `root entry {events = [here --> (`?Event)]; for evt in sorted(events, key=lambda e: e.timestamp) {apply(evt);}}}.
Common patterns multi-tenancy: Separate by root. Example: Each user has own root. Data isolated. walker GetUserData {can get with `root entry {data = [here --> (`?UserData)][0]; report data;}}. Each API call authenticated, operates on user's root.
Common patterns background jobs: Use async walkers with scheduling. Example: async walker ProcessQueue {obj __specs__ {static has private: bool = True; static has schedule: dict = {"trigger": "interval", "seconds": 30};}; can process with `root entry {jobs = [here --> (`?Job)](?status == "pending"); for job in jobs {job.status = "processing"; execute_job(job); job.status = "completed";} commit();}}.
Advanced pattern actor model: Nodes as actors, edges as message channels. Example: node Actor {has inbox: list = []; def receive(msg: dict) {self.inbox.append(msg);};}; walker SendMessage {has to_id: str; has msg: dict; can send with `root entry {actor = &self.to_id; actor.receive(self.msg);}}.
Advanced pattern CQRS: Separate read and write models. Example: node WriteModel {has data: dict;}; node ReadModel {has cached_view: dict;}; walker Command {can write with `root entry {write = [here --> (`?WriteModel)][0]; write.data = update(write.data); save(write); rebuild_read_model();}}; walker Query {can read with `root entry {read = [here --> (`?ReadModel)][0]; report read.cached_view;}}.
Advanced pattern saga: Distributed transaction pattern. Example: walker OrderSaga {has steps_completed: list = []; can execute with `root entry {try {reserve_inventory(); self.steps_completed.append("inventory"); charge_payment(); self.steps_completed.append("payment"); send_confirmation(); report {"success": True};} except Exception as e {for step in reversed(self.steps_completed) {compensate(step);}; report {"success": False, "error": str(e)};}}}.
Advanced pattern pub-sub: Events and subscribers. Example: node Event {has topic: str; has data: dict;}; node Subscriber {has topics: list;}; walker Publish {has topic: str; has data: dict; can publish with `root entry {subs = [here --> (`?Subscriber)](?self.topic in topics); for sub in subs {notify(sub, self.data);} event = here ++> Event(topic=self.topic, data=self.data); save(event);}}.
Memory optimization: Delete unreferenced nodes. Limit walker state. Clear large lists after processing. Example: walker Cleanup {can clean with `root entry {old = [here --> (`?Item)](?created < cutoff); for item in old {del item;}; orphans = [here --> (`?Node)](?len([<-- here]) == 0); for o in orphans {del o;} commit();}}.
Performance optimization traversal: Use early filtering. Example: Inefficient: items = [root -->]; filtered = [i for i in items if i.value > 100]. Efficient: items = [root -->](?value > 100). Use type filters: [root --> (`?Item)] instead of [root -->] then filter.
Performance optimization batching: Batch operations and commits. Example: Inefficient: for item in items {process(item); commit();}. Efficient: for item in items {process(item); save(item);}; commit(). Reduces DB calls.
Performance optimization lazy evaluation: Use generators for large datasets. Example: def process_all() -> list {results = []; for chunk in chunks {results.extend(process_chunk(chunk));}; return results;}. Better: def process_all() -> generator {for chunk in chunks {for item in process_chunk(chunk) {yield item;}}}; for result in process_all() {use(result);}.
Performance optimization caching strategies: Cache at multiple levels. In-memory for hot data, Redis for distributed, DB for persistence. Example: node MemCache {has store: dict = {};}; def get_cached(key: str) -> any {mem = [root --> (`?MemCache)][0]; if key in mem.store {return mem.store[key];}; val = redis_get(key); if val {mem.store[key] = val; return val;}; val = db_query(key); redis_set(key, val, ttl=300); mem.store[key] = val; return val;}.
Debugging techniques: Use print() for logs. printgraph() to visualize structure. Debug walkers to inspect state. Example: walker Debug {can inspect with Node entry {print(f"Node: {here.id}, Type: {type(here)}, Attrs: {here.__dict__}"); print(f"Successors: {[here -->]}"); print(f"Predecessors: {[<-- here]}");}}.
Debugging API: Test endpoints with curl or Postman. Check /docs for OpenAPI spec. View logs for errors. Example: curl -X POST http://localhost:8000/walker/test -H "Content-Type: application/json" -d '{"param": "value"}'. Check response and logs.
Debugging graph: Use printgraph to export, visualize with Graphviz. Example: jac run app.jac; In code: data = printgraph(node=root, depth=3); write_file("graph.json", json.dumps(data)). Or: printgraph(node=root, dot_file="graph.dot"); Then: dot -Tpng graph.dot -o graph.png.
MCP Model Context Protocol: Architecture for AI agents with tools. Server exposes tools, client calls them. Example: MCP server provides search_documents, search_web. AI agent uses tools during ReAct reasoning. Jac integrates via jac-mcp package.
Integration patterns external APIs: Call from walkers. Example: import requests; walker FetchData {has url: str; can fetch with `root entry {response = requests.get(self.url); data = response.json(); report data;}}.
Integration patterns databases: Use Python DB libraries. Example: import psycopg2; walker QueryDB {has sql: str; can query with `root entry {conn = psycopg2.connect(DB_URL); cursor = conn.execute(self.sql); results = cursor.fetchall(); conn.close(); report results;}}.
Integration patterns message queues: Publish/consume from RabbitMQ, Kafka. Example: from pika import BlockingConnection; walker PublishEvent {has event: dict; can publish with `root entry {conn = BlockingConnection(...); channel = conn.channel(); channel.basic_publish(exchange='', routing_key='events', body=json.dumps(self.event)); conn.close();}}.
Migration from Python: Classes → obj/node. Functions → def. Methods → def in obj/node or impl. self works same. __init__ → auto-generated from has. Example: Python: class User: def __init__(self, name): self.name = name; def greet(self): return f"Hi {self.name}". Jac: obj User {has name: str; def greet(self) -> str {return f"Hi {self.name}";}}.
Migration collections to graphs: Lists/dicts → nodes and edges. Iteration → walker traversal. Example: Python: users = [User(...), User(...)]; for user in users: process(user). Jac: root ++> User(...); root ++> User(...); walker Process {can handle with User entry {process(here);}}.
Quick reference syntax: Variable: has name: type = val. Global: glob name = val. Function: def name(params) -> type {body}. Object: obj Name {has attrs; def methods}. Node: node Name {has attrs; def methods; can abilities}. Edge: edge Name {has attrs}. Walker: walker Name {has state; can abilities}. Connect: node1 ++> node2. Traverse: [node -->]. Filter: [expr](?cond). Spawn: node spawn walker(). Visit: visit [nodes]. Report: report val. Import: import from pkg {items}. Entry: with entry {code}. Test: test name {assert cond}. AI: def func() -> type by llm(). Lambda: lambda x: type: expr. Match: match val {case p: action}. Try: try {code} except E {handle}. Class: obj Class(Base) {body}. Method impl: impl Class.method(params) {body}.
