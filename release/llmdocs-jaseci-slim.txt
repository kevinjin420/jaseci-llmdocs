Jac: Python superset for AI-powered graph applications. Install: pip install jaclang. CLI: jac run file.jac, jac serve file.jac (API server), jac test file.jac. Files: .jac interface, .impl.jac implementation, .test.jac tests. Entry: with entry {code}. Syntax: semicolons end statements, braces for blocks, f"text {var}" formatting. Types required: var: type = value. Global: glob var: type = value.
Types: int str float bool any. Collections: list[T] dict[K,V] set[T] tuple[T1,T2]. Union: T1|T2. Optional: T|None. Enum: enum Name {VAL1, VAL2}. Control: if/elif/else, while, for item in collection, for i=start to end by step. Match: match val {case type() if cond: code; case _: default}. Try: try {} except Type as e {}. Lambda: lambda p: type: expr.
Functions: def name(p: type = default) -> ret {body}. Async: async def name() {await op}. Decorators: @decorator. Higher-order: pass/return functions. Map/filter/sorted built-in.
Objects: obj Name {has attr: type; def method() {}}. Auto-constructor from has. Instantiate: Name(attr=val). Inheritance: obj Child(Parent) {}. Methods: def method() {self.attr}. Implementation: impl Name.method {code}. Postinit: def postinit {} runs after construction.
Nodes (graph vertices): node Name {has attr: type; def methods; can abilities}. Abilities: can ability_name with WalkerType entry|exit {here, visitor, self}. here=current node, visitor=walker, self=node. Connect: node1 ++> node2 (forward), node1 <++> node2 (bi). Type filters: [node --> (`?Type)]. Attr filters: [node --> (`?Type)](?attr==val).
Edges (relationships): edge Name {has prop: type; can abilities}. Generic: ++> <++ <++>. Typed: node1 +>:EdgeName(prop=val):+> node2. Bidirectional: <+:EdgeName:<+. Filter: [node ->:EdgeType:->], [node ->:Edge:prop>val:->]. Delete: del edge.
Walkers (mobile computation): walker Name {has state: type; can abilities}. Spawn: node spawn Walker() or root spawn Walker(). Visit: visit [-->] outgoing, visit [<--] incoming, visit [<-->] both. Type filter: visit [-->(`?NodeType)]. Edge filter: visit [->:EdgeType:->]. Multi-hop: visit [--> --> -->]. Control: disengage exits, skip skips current. Report: report value streams to caller. Abilities: can ability with entry|exit, can ability with NodeType entry|exit. Order: location entry → walker entry → visits → walker exit → location exit. Root entry: can ability with `root entry {}.
Queries: [node -->] successors, [<-- node] predecessors. Type: [-->(`?Type)]. Attribute: [-->(`?T)](?attr==val). Edge: [->:EdgeType:->]. Combine: [-->(`?T)](?a>5) --> -->(`?Goal)].
Persistence: root per-user anchor. Auto-persist: connected to root. save(obj) queue, commit() flush, commit(archetype) specific. Database: nodes/edges/walkers stored MongoDB.
byLLM (AI): pip install byllm. import from byllm {Model, Image}. glob llm = Model(model_name="gpt-4o"). AI function: def func(params) -> ret by llm(). Docstrings enhance prompts. Semantic: sem Class.attr = "meaning". Image: Image("path.jpg") multimodal. Reasoning: by llm(method='Reason'). ReAct: by llm(method='ReAct', tools=[funcs]). Streaming: by llm(stream=True). Structured: return custom obj/enum types. Options: temperature max_tokens top_k top_p verbose max_tries.
Jac Cloud: jac serve main.jac → localhost:8000/docs. Endpoints: /walker/{name}, /walker/{name}/{node_id}. Config: obj __specs__ {static has methods: list = ["get","post"]; static has auth: bool = True; static has as_query: list = ["param"] or "*"; static has private: bool = False; static has path: str = "/custom"}. Response: {"status": 200, "reports": [], "returns": []}. WebSocket: methods: ["websocket"], URL: ws://host/websocket. Webhooks: static has webhook: dict. Scheduler: static has schedule: dict = {"trigger": "cron|interval|date", "hour": "0", "minute": "0"} or {"trigger": "interval", "seconds": 30} or {"trigger": "date", "run_date": "ISO8601"}. File upload: has file: UploadFile. Async walker: async walker Name {}, returns walker_id, retrieve: wlk = &walker_id; wlk.__jac__.status.
Environment: DATABASE_HOST DATABASE_NAME REDIS_HOST REDIS_PORT TOKEN_SECRET TOKEN_TIMEOUT UV_HOST UV_PORT LOGGER_LEVEL SHOW_ENDPOINT_RETURNS DISABLE_AUTO_ENDPOINT.
Permissions: NoPerm ReadPerm ConnectPerm WritePerm. Grant: _.allow_root(node, target_root, level) or grant(node, level) public. Revoke: _.disallow_root(node, target_root) or revoke(node). Check: _.check_read_access(node). Custom: def __jac_access__() -> AccessLevel {logic; return level}.
SSO: Env: SSO_{PLATFORM}_CLIENT_ID SSO_{PLATFORM}_CLIENT_SECRET. Platforms: APPLE GOOGLE GOOGLE_ANDROID GOOGLE_IOS FACEBOOK GITHUB. Callback: GET /sso/{provider}/register/callback?id_token={token}.
Testing: test name {assert condition; assert val == expected}. Run: jac test file.jac. Assertions fail in tests, raise in code.
Implementation separation: file.jac declares interfaces. file.impl.jac defines implementations with impl Cls.method {}. Auto-imported.
Object-Spatial Programming: Computation moves to data (not data to computation). Nodes=locations with abilities, edges=first-class relationships, walkers=mobile agents, abilities=event-driven, bidirectional polymorphism.
Execution order: Walker arrives → location entry abilities → walker entry abilities → visit statements → walker exit abilities → location exit abilities → walker moves. Edge abilities: visitor reaches edge, edge entry runs, destination node auto-queued, edge exit runs, walker moves to node.
Queue: FIFO destination queue. visit adds to queue. Empty queue at node = deactivates walker. Path collections: [node1, node2, ...] ordered sequence, visit [path] traverses all.
Semantic programming: Docstrings + sem + type hints = AI context. No prompt engineering, function signatures → prompts. Multimodal: Image Audio combined with text.
Deployment: Local: jac run. Server: jac serve. Docker: FROM python:3.12, pip install, CMD jac serve. Kubernetes: deployment.yaml with replicas, ConfigMap, Secrets. Scale-agnostic: same code local/cloud. Auto-API: walkers → REST endpoints.
Patterns: CRUD: walkers for operations. State machines: nodes=states walkers=transitions. Workflows: nodes=steps edges=flow. Social graph: users=nodes relationships=edges. Knowledge graph: concepts=nodes relations=edges. RAG: documents=nodes similarity=edges walker queries. BFS: walker with visited set queue. DFS: walker with visited set recursive visits. Shortest path: walker with distances dict priority queue.
Graph algorithms: walker BFS {has visited: set; has queue: list; can search with Node entry {if here not in self.visited {self.visited.add(here); self.queue.extend([here -->]); process(here);}; if self.queue {visit [self.queue.pop(0)];}}}. walker DFS {has visited: set; can search with Node entry {if here not in self.visited {self.visited.add(here); process(here); for child in [here -->] {if child not in self.visited {visit [child];}}}}}. walker ShortestPath {has target_id: str; has distances: dict; has unvisited: set; can search with Node entry {update_distances(); if here.id == self.target_id {report path; disengage;}; visit min_distance_unvisited();}}.
Real examples: RAG chatbot: node Document {has text: str; has embedding: list}. def embed(text: str) -> list {model.encode(text)}. def find_similar(query_emb, docs) -> list {sorted by cosine_similarity}. def answer(question: str, context: list[Document]) -> str by llm(). Social network: node User {has username: str}; edge Follow {has since: str}; node Post {has content: str}. walker GetFeed {has posts: list = []; can collect with User entry {visit [here --> (`?Post)]; visit [here ->:Follow:-> (`?User) --> (`?Post)];}; can gather with Post entry {visitor.posts.append(here);}}. E-commerce: node Product {has name: str; price: float; stock: int}; node Order {has status: str; total: float}; edge Contains {has quantity: int}. walker Checkout {has items: list; can process with `root entry {order = here ++> Order(status="pending", total=0); for item in self.items {product = &item["id"]; if product.stock >= item["qty"] {order +>:Contains:quantity=item["qty"]:+> product; order.total += product.price * item["qty"]; product.stock -= item["qty"]; save(order); save(product);}}; order.status = "confirmed"; commit();}}.
Task management: node Task {has title: str; status: str; priority: int}; edge DependsOn {}. walker Schedule {has result: list = []; can schedule with Task entry {deps = [<-:DependsOn:<- here]; if all(d.status == "done" for d in deps) {if here.status == "pending" {here.status = "ready"; self.result.append(here);}}; visit [-->];}}.
Game level gen: obj Level {has difficulty: int; width: int; height: int; enemies: int}; obj Map {has level: Level; walls: list; enemies: list}. def generate_level(prev: list[Level], difficulty: int) -> Level by llm(). def generate_map(level: Level) -> Map by llm().
Trading system: obj Item {has name: str; price: float}; obj Person {has name: str; money: float; inventory: list[Item]}. def make_transaction(buyer, seller, item) -> bool {if buyer.money >= item.price and item in seller.inventory {buyer.money -= item.price; seller.money += item.price; buyer.inventory.append(item); seller.inventory.remove(item); return True}; return False}. obj Chat {has person: str; message: str}. def npc_chat(player: Person, npc: Person, history: list[Chat]) -> Chat by llm(method='ReAct', tools=[make_transaction]).
Multimodal chatbot: enum QueryType {RAG, WEB, IMAGE, VIDEO, GENERAL}. def classify(query: str, has_files: bool) -> QueryType by llm(). walker Route {has query: str; files: list; can route with `root entry {qtype = classify(self.query, len(self.files) > 0); match qtype {case QueryType.RAG: visit [-->:RAGHandler:->]; case QueryType.IMAGE: visit [-->:ImageHandler:->]; case QueryType.VIDEO: visit [-->:VideoHandler:->];}}}.
Common patterns: Singleton: node at root, check exists before create. Pagination: slice [start:end] on query results. Caching: node Cache {has key: str; value: any; expires: float}. Rate limiting: node RateLimit {has user_id: str; count: int; window_start: float}. Audit log: node AuditLog {has action: str; user_id: str; timestamp: float; details: dict}. Soft delete: has is_deleted: bool = False; has deleted_at: float | None. Versioning: node Version {has version: int; content: str; created: float}. Event sourcing: node Event {has type: str; data: dict; timestamp: float}. Multi-tenancy: per-user root isolation. Background jobs: async walker with schedule.
Advanced patterns: Actor model: nodes=actors, edges=message channels. CQRS: separate WriteModel and ReadModel nodes. Saga: walker with steps_completed list, try/compensate pattern. Pub-sub: node Event {has topic: str}, node Subscriber {has topics: list}.
Performance: Early filtering: [-->(`?Type)](?attr>val) not [-->] then filter. Batching: for item in items {save(item)}; commit() not commit() each. Lazy eval: generators for large datasets. Caching: multi-level (memory, Redis, DB). Async: async def for I/O ops. Query optimization: limit depth, use type/attr filters early.
Debugging: print() for logs. printgraph(node=root, depth=N) visualize. walker Debug {can inspect with Node entry {print(f"{here.id} {type(here)} {here.__dict__}"); print(f"Succ: {[here -->]} Pred: {[<-- here]}")}}. curl/Postman for API testing. /docs for OpenAPI spec. Logs: tail -f /tmp/jac_cloud_logs/jac-cloud.log. Graph export: printgraph(node=root, dot_file="g.dot"); dot -Tpng g.dot -o g.png.
Integration: Python libs: import any package. REST APIs: import requests. Databases: import psycopg2 or pymongo. Message queues: import pika for RabbitMQ. External APIs: call from walkers.
Migration from Python: class → obj/node. def → def. __init__ → has auto-constructor. self same. Collections → nodes/edges. Iteration → walker traversal. Example: Python class User: def __init__(self, name): self.name = name → Jac obj User {has name: str}.
Breaking changes v0.8+: impl keyword not :obj:Class:def:. Inheritance Class(Base) not Class :Base:. def for functions/methods, can only for abilities. visitor not here in node context. Lambda lambda x: type: expr not with x: type can expr. Arrows ->:Edge:-> +>:Edge:+> not -:Edge:-> +:Edge:+>. Import import from pkg {items} not import from pkg, items. Permissions Jac.perm_grant/perm_revoke not restrict/unrestrict. Testing assert in test blocks not check. Global global x nonlocal y not :global: :nonlocal:. printgraph not dotgen. byLLM import from byllm {Model}; Model(model_name="gpt-4o") not separate classes.
Best practices: Use nodes for entities with relationships. Use obj for value objects/DTOs. Use walkers for operations/traversal. Separate interface (.jac) from implementation (.impl.jac). Test walkers and graph structure (.test.jac). Type annotations always. Validate inputs at entry. Handle errors with try/except. Report errors via report not raise in API walkers. Limit graph depth (<10 levels). Index frequent nodes at root. Clean orphaned nodes. Batch DB commits. Cache expensive ops. Use async for heavy tasks. Require auth for sensitive ops. Use permissions for data access. Environment variables for secrets. HTTPS in production. Log structured JSON. Monitor metrics/errors. Health checks. Document with docstrings. Use semantic strings for AI. Test AI outputs with varied inputs.
File structure: main.jac entry point. models/ domain objects. utils/ helpers. tests/ test files. .impl.jac implementations auto-imported. Organize by feature or layer.
Keywords: with entry, has, can, def, impl, glob, obj, node, edge, walker, spawn, visit, disengage, skip, report, sem, by, `root, self, here, visitor, path, del, async/await, match/case, try/except/raise, import/from, include, for/while, if/elif/else, return, break/continue, and/or/not, in, is, lambda, type, enum.
CLI tools: jac main entry. jac run <file> execute. jac serve <file> start server. jac test <file> run tests. jac build <file> compile. jac format <file> format code. jac check <file> type check. jac clean remove cache. jac enter <file> <func> call function. jac tool ir ast <file> show AST. jac tool ir py <file> show Python. Options: --verbose --debug --help --version.
Streamlit: pip install jac-streamlit. jac streamlit app.jac. import streamlit as st. st.title() st.button() st.text_input(). st.session_state.key for state. with st.form("name") {} for forms. Call Jac Cloud API with requests.
VS Code: Install jaclang-extension. Syntax highlighting, completion, errors, graph visualization, debugging.
Jac-Lens: Visual graph explorer. Interactive node/edge inspection. Real-time updates. Development tool.
Jac Playground: Web IDE. No install. Try in browser. Example programs. Share links. Learning tool.
Library mode: Import Jac in Python. import jac_module. Access classes/functions. Hybrid Python/Jac.
Content: Jac Book 20 chapters: intro, syntax, control, functions, objects, nodes, edges, walkers, queries, persistence, AI, multimodal, cloud, auth, advanced, testing, performance, examples, integration, internals. Tutorials, how-tos, references, videos. Community projects, examples, showcase.
Philosophy: Scale-agnostic: same code local/cloud. Object-Spatial: computation to data. AI-first: byLLM integration. Graph-native: nodes/edges/walkers. Python compatible: superset. Type-safe: static typing. Auto-API: walkers → endpoints. Per-user isolation: root nodes. Event-driven: abilities. Bidirectional polymorphism: nodes+walkers define interaction.
Quick reference: Variable has name: type = val. Global glob name = val. Function def name(params) -> type {body}. Object obj Name {has attrs; def methods}. Node node Name {has attrs; def methods; can abilities}. Edge edge Name {has attrs}. Walker walker Name {has state; can abilities}. Connect node1 ++> node2. Traverse [node -->]. Filter [expr](?cond). Spawn node spawn walker(). Visit visit [nodes]. Report report val. Import import from pkg {items}. Entry with entry {code}. Test test name {assert cond}. AI def func() -> type by llm(). Lambda lambda x: type: expr. Match match val {case p: action}. Try try {code} except E {handle}. Impl impl Class.method(params) {body}. Root `root or root. References here visitor self path. Control disengage skip. Delete del edge. Persistence save(obj) commit().
