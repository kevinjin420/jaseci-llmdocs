Jac: Python superset for AI+graph. pip install jaclang. jac run file.jac, jac serve file.jac, jac test file.jac. with entry {code}. Files: .jac .impl.jac .test.jac. Types required: var: type = value.
Types: int str float bool any. list[T] dict[K,V] set[T] tuple[T1,T2]. T1|T2 T|None. enum Name {VAL1, VAL2}. if/elif/else, while, for item in collection. match val {case type() if cond: code; case _: default}. try {} except Type as e {}. lambda p: type: expr.
def name(p: type = default) -> ret {body}. async def name() {await op}. @decorator. obj Name {has attr: type; def method() {}}. Name(attr=val). obj Child(Parent) {}. impl Name.method {code}. def postinit {}.
node Name {has attr: type; def methods; can abilities}. here=current node, visitor=walker, self=node. can ability_name with WalkerType entry|exit {code}. node1 ++> node2, node1 <++> node2. +>:EdgeName(prop=val):+> <+:EdgeName:<+. [node --> (`?Type)](?attr==val).
edge Name {has prop: type; can abilities}. ++> <++ <++>. node1 +>:EdgeName(prop=val):+> node2. [node ->:EdgeType:->], [node ->:Edge:prop>val:->]. del edge.
walker Name {has state: type; can abilities}. node spawn Walker() or root spawn Walker(). visit [-->] outgoing, visit [<--] incoming, visit [<-->] both. visit [-->(`?NodeType)]. visit [->:EdgeType:->]. disengage exits, skip skips. report value. can ability with entry|exit. can ability with `root entry {}.
[node -->] successors, [<-- node] predecessors. [-->(`?Type)] type filter. [-->(`?T)](?attr==val) attr filter. [->:EdgeType:->] edge filter. [-->(`?T)](?a>5) --> -->(`?Goal)] combine.
root per-user. save(obj) queue, commit() flush. MongoDB stores nodes/edges/walkers.
pip install byllm. import from byllm {Model, Image}. glob llm = Model(model_name="gpt-4o"). def func(params) -> ret by llm(). Image("path.jpg") multimodal. by llm(method='Reason') reasoning. by llm(method='ReAct', tools=[funcs]) ReAct. by llm(stream=True) streaming. return custom obj/enum types. Options: temperature max_tokens top_k top_p verbose max_tries.
jac serve main.jac → localhost:8000/docs. /walker/{name}, /walker/{name}/{node_id}. obj __specs__ {static has methods: list = ["get","post"]; static has auth: bool = True; static has as_query: list = ["param"] or "*"; static has private: bool = False; static has path: str = "/custom"}. {"status": 200, "reports": [], "returns": []}. methods: ["websocket"], ws://host/websocket. webhook: dict. schedule: dict = {"trigger": "cron|interval|date", "hour": "0"}. has file: UploadFile. async walker returns walker_id, retrieve: wlk = &walker_id; wlk.__jac__.status.
DATABASE_HOST DATABASE_NAME REDIS_HOST REDIS_PORT TOKEN_SECRET TOKEN_TIMEOUT UV_HOST UV_PORT LOGGER_LEVEL SHOW_ENDPOINT_RETURNS DISABLE_AUTO_ENDPOINT. SSO_{PLATFORM}_CLIENT_ID SSO_{PLATFORM}_CLIENT_SECRET.
NoPerm ReadPerm ConnectPerm WritePerm. _.allow_root(node, target_root, level) or grant(node, level). _.disallow_root(node, target_root) or revoke(node). _.check_read_access(node). def __jac_access__() -> AccessLevel {logic; return level}.
SSO Platforms: APPLE GOOGLE GOOGLE_ANDROID GOOGLE_IOS FACEBOOK GITHUB. GET /sso/{provider}/register/callback?id_token={token}.
test name {assert condition; assert val == expected}. jac test file.jac.
file.jac declares interfaces. file.impl.jac defines impl Cls.method {}. Auto-imported.
Object-Spatial: Computation moves to data. Nodes=locations, edges=relationships, walkers=mobile agents, abilities=event-driven. Walker arrives → location entry → walker entry → visit statements → walker exit → location exit. FIFO queue. visit adds to queue.
BFS: walker BFS {has visited: set; has queue: list; can search with Node entry {if here not in self.visited {self.visited.add(here); self.queue.extend([here -->]); process(here);}; if self.queue {visit [self.queue.pop(0)];}}}. DFS: walker DFS {has visited: set; can search with Node entry {if here not in self.visited {self.visited.add(here); process(here); for child in [here -->] {if child not in self.visited {visit [child];}}}}}. ShortestPath: walker with distances dict unvisited set.
RAG: node Document {has text: str; has embedding: list}. def embed(text: str) -> list. def find_similar(query_emb, docs) -> list. def answer(question: str, context: list[Document]) -> str by llm(). Social: node User edge Follow node Post. walker GetFeed {can collect with User entry {visit [here --> (`?Post)]; visit [here ->:Follow:-> (`?User) --> (`?Post)];}; can gather with Post entry {visitor.posts.append(here);}}. E-commerce: node Product Order edge Contains. walker Checkout {for item in items {order +>:Contains:quantity=qty:+> product; order.total += price * qty; product.stock -= qty; save(order); save(product);}; commit();}. Task: node Task edge DependsOn. walker Schedule checks deps.
Game: def generate_level(prev: list[Level], difficulty: int) -> Level by llm(). def generate_map(level: Level) -> Map by llm(). Trading: def make_transaction(buyer, seller, item) -> bool. def npc_chat(player: Person, npc: Person, history: list[Chat]) -> Chat by llm(method='ReAct', tools=[make_transaction]). Multimodal: enum QueryType {RAG, WEB, IMAGE, VIDEO}. def classify(query: str, has_files: bool) -> QueryType by llm(). walker Route {can route with `root entry {qtype = classify(query, files); match qtype {case QueryType.RAG: visit rag; case QueryType.IMAGE: visit img;}}}.
Singleton: check exists before create. Pagination: slice [start:end]. Caching: node Cache {has key: str; value: any; expires: float}. Rate limiting: node RateLimit {has user_id: str; count: int; window_start: float}. Audit: node AuditLog {has action: str; user_id: str; timestamp: float}. Soft delete: has is_deleted: bool = False; has deleted_at: float | None. Versioning: node Version {has version: int; content: str}. Event sourcing: node Event {has type: str; data: dict}. Multi-tenancy: per-user root. Background: async walker with schedule.
Actor: nodes=actors, edges=channels. CQRS: WriteModel and ReadModel nodes. Saga: walker with try/compensate. Pub-sub: node Event Subscriber.
Performance: Early filter [-->(`?Type)](?attr>val). Batch: save(item); commit() not commit() each. Generators for large data. Cache multi-level. async def for I/O. Limit depth, use filters.
print() printgraph(node=root, depth=N). walker Debug {can inspect with Node entry {print(here.id, type(here), here.__dict__); print([here -->], [<-- here])}}. curl for API. /docs OpenAPI. tail -f /tmp/jac_cloud_logs/jac-cloud.log. printgraph(dot_file="g.dot"); dot -Tpng g.dot -o g.png.
Python libs: import any package. REST: import requests. Databases: import psycopg2 or pymongo. Queues: import pika. Call from walkers.
Migration: class → obj/node. def → def. __init__ → has. self same. Collections → nodes/edges. Iteration → walker.
v0.8+ Breaking: impl ClassName.method {code} not :obj:. Class(Base) not :Base:. def for functions, can only for abilities. visitor not here in nodes. lambda x: type: expr. ->:Edge:-> +>:Edge:+>. import from pkg {items}. Jac.perm_grant/perm_revoke. assert in tests. global nonlocal. printgraph not dotgen. Model(model_name="gpt-4o").
Best practices: nodes for entities, obj for values, walkers for ops. .jac/.impl.jac/.test.jac. Type annotations. Validate inputs. try/except. report not raise in APIs. Limit graph depth. Index at root. Clean orphans. Batch commits. Cache. async for heavy. Auth sensitive. Permissions multi-user. Env vars for secrets. HTTPS prod. Log JSON. Monitor. Health checks. Document. Semantic strings for AI.
Keywords: with entry, has, can, def, impl, glob, obj, node, edge, walker, spawn, visit, disengage, skip, report, sem, by, `root, self, here, visitor, path, del, async/await, match/case, try/except/raise, import/from, for/while, if/elif/else, return, break/continue, and/or/not, in, is, lambda, type, enum.
jac run/serve/test/build/format/check/clean file.jac. jac tool ir ast/py file.jac. --verbose --debug --help.
Streamlit: pip install jac-streamlit. jac streamlit app.jac. st.title() st.button() st.text_input(). VS Code: jaclang-extension. Jac-Lens graph explorer. Jac Playground web IDE.
Docker: FROM python:3.12; pip install; CMD jac serve app.jac. Kubernetes: deployment.yaml replicas, ConfigMap, Secrets, Service, Ingress. kubectl apply/scale.
Scale-agnostic local/cloud. Object-Spatial computation-to-data. AI-first byLLM. Graph-native nodes/edges/walkers. Python superset. Type-safe. Auto-API walkers→endpoints. Per-user root isolation. Event-driven abilities. Bidirectional polymorphism.
has name:type=val. glob name=val. def name(params)->type{body}. obj Name{has;def}. node Name{has;def;can}. edge Name{has}. walker Name{has;can}. node1++>node2. [node-->]. [expr](?cond). spawn walker(). visit [nodes]. report val. import from pkg{items}. with entry{code}. test name{assert}. def func()->type by llm(). lambda x:type:expr. match val{case:action}. try{}except E{}. impl Class.method(){}. `root. here visitor self path. disengage skip. del edge. save(obj) commit().
