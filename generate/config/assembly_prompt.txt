You are assembling a Jac language reference. Jac is a onelang that supersets Python/JavaScript for fullstack apps (frontend compiles to JS, backend/AI compiles to Python).

TARGET: 12-15KB. Terse reference format, not prose.

FORMAT RULES:
- Short declarative statements, not explanations
- Show syntax, then example. No "as in" or "for example"
- Group related items with semicolons
- Code inline, no fences
- One line per concept where possible
- WRONG/RIGHT pairs: show only the code, minimal words

STRUCTURE EACH TOPIC:
Topic: brief definition
Syntax: pattern
Example: code
(Optional) Common error: wrong -> right

HIGH-FAILURE SYNTAX (must be exact):
- CLI: jac start file.jac (not jac serve, serve does not exist); jac check file.jac to validate syntax
- Entry: with entry { } not entry { }
- Spawn: node spawn Walker(); (node first, then spawn Walker)
- Import: import from module { sym } (no semicolon after }); import module; (no import:py)
- LLM: def f() -> T by llm; (semicolon, no parens, no import needed)
- Access: has:priv x (no space); only :pub :priv :protect
- Permissions: node.__jac__.grant(root, Perm)
- Specs: obj __specs__ { static has methods: list = [...]; } not dict literal
- Methods: use can for abilities (with entry/exit), use def for regular methods
- Optionals: str | None, not str?
- Booleans: True/False capitalized, not true/false
- Docstrings: before declarations, not inside function bodies
- Lambdas: lambda x: T -> T { body }, not |x| { }
- Tuple unpacking: (a, b) = func(); parentheses required around left side
- No pass keyword: use empty block {} or comment
- Enumerate unpacking: for (i, x) in enumerate(items) { }; parentheses required
- Typed edges: a ++> EdgeType() ++> b; edge must be instantiated with (), not a +>:EdgeType:+> b
- Connection returns list: a ++> Node() returns list; use a[0] to get single node for chaining
- Ability names: never name abilities list/dict/str/int or other builtins; use fetch/get/handle instead

TOPICS (cover all concisely):

1. TYPES: int float str bool bytes any; list[T] dict[K,V] set[T]; int|None for unions; has x: type; -> return

2. CONTROL: if cond { } elif { } else { }; for x in items { }; for i=0 to i<10 by i+=1 { }; while cond { }; match x { case V { } }

3. FUNCTIONS: def name(p: T) -> R { }; lambdas: lambda p: T -> R { }; glob var: T = val; at module level

4. IMPORTS: import os; import from math { sqrt }; import from datetime { datetime as dt }; include module; packages require __init__.jac like Python's __init__.py

5. ARCHETYPES: node N { has f: T; def m() { } can on_v with W entry { } }; edge E { has f: T; }; walker W { has s: T; can act with N entry { visit [-->]; } }; obj O { has f: T; def m() { } }; enum E { A, B=1 }

6. ACCESS: has:priv f: T; def:pub m() { }; can:protect h with entry { }; only :pub :priv :protect

7. GRAPH: a ++> b; a <++> b; a ++> Edge() ++> b (typed connection requires edge instance); del a --> b; [-->] forward; [<--] back; [-->:E:] typed traversal; [-->(`?Node)] filter type; [-->](?attr>v) filter attr

8. ABILITIES: can name with Type entry { } or exit { }; always requires with...entry/exit; use def for regular methods; self=instance here=node visitor=walker props=walker_props root=user_root `root=root_type

9. WALKERS: node spawn Walker(); visit [-->]; visit [-->] else { }; report val; disengage; skip; result.reports for collected

10. BY_LLM: def f(x: str) -> str by llm; (builtin, no import); def f() -> Obj by llm; for structured; by llm(temperature=0.7); by llm(method="Reason"); has desc: str = "" """hint"""; for semstrings (default value required); wrong: by llm() right: by llm;

11. FILE_JSON: f=file.open(p,"r"); f.read(); f.write(s); f.close(); json.dumps(obj); json.loads(s)

12. API: jac start file.jac; walker becomes endpoint; walker W { has d: str; obj __specs__ { static has methods: list=["GET"]; static has auth: bool=true; static has path_prefix: str="/api"; } can h with `root entry { report {"k":v}; } }; wrong: __specs__={"methods":[]}

13. WEBSOCKET: obj __specs__ { static has methods: list=["websocket"]; }; socket.notify_users(ids,msg); socket.notify_channels(names,msg)

14. WEBHOOKS: obj __specs__ { static has webhook: dict={"type":"header","name":"X-Sig"}; }; endpoint /webhook/walker/name

15. SCHEDULER: obj __specs__ { static has schedule: dict={"trigger":"cron","hour":"9"}; static has private: bool=true; }; triggers: cron interval date

16. ASYNC: async walker W { async can f with entry { await op(); } }; async def f() { }; task.__jac__.status/reports/error

17. PERMISSIONS: node.__jac__.grant(root, WritePerm); node.__jac__.revoke(root); node.__jac__.check_access(root, ReadPerm); levels: NoPerm ReadPerm ConnectPerm WritePerm

18. PERSISTENCE: nodes connected to root auto-persist; save(node); commit(); &id for reference; del node; commit(); glob var: T = val; for persistent globals

19. TESTING: test name { assert cond; check cond; }

20. STDLIB: print len range enumerate type str int float list dict set; s.upper() lower() strip() split() join(); l.append() extend() pop() sort(); d.keys() values() items() get()

21. JSX: sv { walker W { obj __specs__ { static has methods: list=["get"]; } can f with `root entry { report {}; } } } cl { def:pub App() -> any { has count: int=0; can with entry { } can with [dep] entry { } can with exit { } def inc() { count+=1; } return <div><p>{count}</p><button onClick={inc}>+</button></div>; } }

22. DEPLOY: docker: FROM python:3.11-slim; pip install jaclang; jac start main.jac; env: DATABASE_URL JAC_SECRET_KEY OPENAI_API_KEY

PATTERNS (include 2-3 complete examples):
- Fullstack single-file with sv{} and cl{}
- Walker graph traversal with visit/report
- API endpoint with __specs__

---

EXTRACTED CONTENT:
{content}

---

Generate terse reference. No markdown. No blank lines. Show syntax and examples, minimize explanation. All topics required. ~12-15KB target.
