You are assembling a Jac language reference from extracted signatures and examples.

TARGET: 25-30KB. Balance thoroughness with conciseness.

MANDATORY SECTIONS (include all):

## 1. Syntax & Types
- Primitives: int, float, str, bool, bytes, any
- Collections: list, dict, set, tuple, frozenset
- Type unions: int | None, str | int
- Type annotations: has x: type, -> return_type
- Control flow: if/elif/else, for, while, match/case
- Functions: def with params, returns, defaults
- Lambdas: |params| -> type { body }
- Entry point: with entry { }

## 2. Imports
- Simple: import os;
- Multiple: import sys, json;
- Alias: import datetime as dt;
- From: import from math { sqrt, pi }
- Python interop: import:py from module { func }

## 3. Archetypes
- node: has, can, def, inheritance
- edge: has, typed connections
- walker: has, can with entry/exit, visit, spawn
- obj: value objects, postinit
- enum: enumerations with values

## 4. Access Modifiers
- :pub (public, default)
- :priv (private)
- :prot (protected)

## 5. Graph Operations
- Connect: ++>, <++, <++>, +>:Edge:+>, <+:Edge:+>
- Disconnect: del
- Traverse: [-->], [<--], [<-->]
- Typed traverse: [-->:EdgeType:]
- Node filter: [-->(`?NodeType)]
- Attribute filter: (?attr == val)

## 6. Abilities & Events
- can name with Type entry { }
- can name with Type exit { }
- can name with entry/exit { } (generic)
- Execution order: node entry -> walker entry -> walker exit -> node exit
- Keywords: self, here, visitor, root, `root

## 7. Walker Control
- spawn: walker() spawn node
- visit: visit [-->], visit [-->] else { }
- disengage: stop walker
- report: return values
- skip: skip current node

## 8. AI Integration
- by llm(): basic LLM function
- by llm(method="Reason"): reasoning
- by llm(method="ReAct"): reasoning with actions
- by llm(model=model_var): model selection
- by llm(tools=[funcs]): tool use
- glob llm = Model(model_name="...")
- Semstrings: """description""" and :sem:
- Structured output with enums/objects
- Image/Video: Image(url=), Video(path=, fps=)

## 9. File I/O & JSON
- file.open(path, mode), file.read(), file.write()
- json.dumps(obj), json.loads(str)

## 10. Cloud & API (jac serve)
- jac serve file.jac
- Walker as endpoint
- __specs__: auth, methods, path, as_query
- static has, report for response
- File upload with UploadFile

## 11. WebSocket
- methods: ["websocket"] in __specs__
- Connection events, client events
- socket.notify_users(), notify_channels(), notify_clients()

## 12. Webhooks
- __specs__ webhook config: type (header/query/body), name
- Generate webhook keys via API
- Webhook endpoint: /webhook/walker/{name}

## 13. Scheduler
- __specs__ schedule config
- Cron triggers: {"trigger": "cron", "hour": "9", "minute": "0"}
- Interval triggers: {"trigger": "interval", "seconds": 30}
- Date triggers: {"trigger": "date", "run_date": "..."}
- private: true for scheduled walkers

## 14. Async & Concurrency
- async walker, async def, await
- Task status: task.__jac__.status, reports, error
- Task queue with create_task()

## 15. Permissions
- Levels: NoPerm, ReadPerm, ConnectPerm, WritePerm
- Grant: _.allow_root(node, target_root, level), grant(node, level)
- Revoke: _.disallow_root(node, target), revoke(node)
- Custom: def __jac_access__() -> AccessLevel

## 16. Persistence
- Automatic persistence if connected to root
- save(node), commit(), commit(Type)
- glob for global nodes
- References: &"n::id"

## 17. Testing
- test { } blocks
- assert, check statements

## 18. Standard Library
- print, input, range, len, enumerate
- str/list/dict methods

## 19. Deployment
- Docker: FROM python, jac serve
- Kubernetes: deployment, service, ingress
- Environment variables for config

## 20. Patterns (4-5 complete examples)
- Graph traversal with collection
- AI-powered processing with by llm()
- API endpoint walker with __specs__
- Multi-agent orchestration
- Caching pattern

FORMAT GUIDELINES:
1. Use tables for operators, keywords, and type references
2. Code examples: 5-15 lines each, one per concept unless critical
3. Combine related features in single examples where possible
4. Minimal prose - let code speak for itself
5. Use inline code for simple syntax: `node Name { has x: type; }`

CRITICAL - MUST PRESERVE EXACTLY:
- Edge operators: ++>, <++, <++>, -->, <-->, +>, <+, +>:Edge:+>, <+:Edge:+>
- Keywords: spawn, visit, disengage, report, skip, here, self, visitor, root, `root
- Abilities: can, with entry, with exit
- LLM: by llm(), glob llm, Model, Image, Video, :sem:, method="Reason", method="ReAct"
- Types: has, def, ->, |
- Specs: __specs__, static has, auth, methods, path, as_query, private, schedule, webhook
- Permissions: NoPerm, ReadPerm, ConnectPerm, WritePerm, _.allow_root, _.disallow_root
- File: file.open, json.dumps, json.loads
- Test: test { }, assert, check
- Async: async walker, __jac__.status, create_task

---

EXTRACTED CONTENT:
{content}

---

Generate the complete reference document. Ensure all 20 sections are present.

Each section needs:
1. A reference table or syntax summary
2. One working code example (more only for critical features like graph ops, walkers, AI)

Do not skip any section. Prioritize accuracy over verbosity.
