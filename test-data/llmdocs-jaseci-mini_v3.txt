Jac: Py superset for AI+graph. Install: pip install jaclang. CLI: jac run/serve/test file.jac. Entry: with entry {code}. Syntax: ; for statements, {} for blocks, f"text {var}". Types required. Comments: # single, #* multi *#. Files: .jac, .impl.jac, .test.jac.
Types: int, str, float, bool, any, list[T], dict[K,V], set[T], tuple[T1,T2], T1|T2, T|None. Enum: enum E {V1,V2}. Control: if/elif/else, while, for item in iter, for i=0 to i<10 by i+=1. Match: match v {case T(): code; case _: ...}. Try: try {} except E as e {}. Lambda: lambda p: type: expr.
Funcs: def n(p:t=v)->r{...}. async def. @dec. Objs: obj N{has a:t; def m(){...}}. N(a=v). Inherit: obj C(P). Access: :pub, :priv, :protect. Impl: impl N.m{...}. Post-init: def postinit{...}. Glob: glob v:t=val; access :g:v.
Nodes: node N{has a:t; def m; can ab with W entry|exit{...}}. Keywords: here, visitor, self. Connect: ++>, <++>. Typed: +>:E:+>, <+:E:<+. Filter: [n-->(`?T)](?a==v).
Edges: edge E{has p:t; can ab}. Generic: ++>, <++>. Typed: +>:E(p=v):+>. Filter: [n->:E:->], [n->:E:p>v:->]. Del: del edge.
Walkers: walker W{has s:t; can ab}. Spawn: n spawn W(). Visit: visit [-->], [<--], [<-->], visit [-->] else {disengage;}. Typed: visit [-->(`?T)], visit [->:E:->]. Control: disengage, skip, report v. Abilities: can ab with NodeType entry|exit{code}; can ab with `root entry{code}. Entry/exit order: node entry -> walker entry -> visits -> walker exit -> node exit.
Queries: [n-->] succ, [<--n] pred, [-->(`?T)] type filter, [-->(`?T)](?a==v) attr filter, [->:E:->] edge filter. Multi-hop: [-->-->]. Edges: [n--->] outgoing, [<---n] incoming.
Persistence: root per-user. Auto-persists if rooted. save(o) queue, commit() flush, commit(Type) flush specific. DB: MongoDB. Refs: obj=&"n::id"; obj.attr="val".
byLLM: pip install byllm. import from byllm{Model,Image,Video}. llm=Model(model_name="gpt-4o", temperature=0.7). AI func: def f(p:t)->r by llm(); def f(p)->r by llm(method='Reason|ReAct', tools=[...]). Context: Docstrings, sem strings. Structured: return obj/enum types. Stream: by llm(stream=True); for token in f("x") {print(token, end="")}. Multi-modal: Image("path"), Video("path", fps=1). Opts: temperature, max_tokens, incl_info={}.
Jac Cloud: jac serve → localhost:8000/docs. Endpoints: /walker/{n}, /walker/{n}/{id}. Config: obj __specs__{static has methods:list=["post"], auth:bool=True, as_query:list=["param"]|"*", path:str="/api/custom", private:bool=False}. Response: {"status":200, "reports":[...], "returns":[...]}. File upload: import from fastapi{UploadFile}; has file:UploadFile. WebSocket: methods:["websocket"]; events: {"type":"walker", "walker":"name", "context":{}}. Async: async walker; result=spawn w(); id=result; task=&id; task.__jac__.status|reports|error.
Permissions: NoPerm, ReadPerm, ConnectPerm, WritePerm. Grant: grant(n,l) or _.allow_root(n,t,l). Revoke: revoke(n) or _.disallow_root(n,t). Check: _.check_read_access(n). Custom: def __jac_access__()->L{...}.
Testing: test "name"{assert cond; assert v==expected}. Run: jac test file.jac.
Obj-Spatial: Compute→data. n=loc, e=rel, w=agent. Order: loc entry→w entry→visits→w exit→loc exit. Utils: printgraph(node, depth) visualize graph.
Patterns: BFS: w{visited:set, queue:list}. DFS: w{visited:set, recursive visits}. RAG: node Doc{txt, emb}. embed(), find_similar(), answer() by llm. Social: n User; e Follow; n Post. w GetFeed. E-commerce: n Product/Order; e Contains; w Checkout. Task mgmt: n Task; e DependsOn; w Schedule. AI: game level gen by llm, NPC chat by llm(method='ReAct', tools=[trade]), multimodal routing.
Best Practices: nodes=entities, obj=values, walkers=ops. Separate files. Type everything. Validate inputs. try/except. report not raise. Limit depth. Batch commits. Cache. async for heavy. Auth sensitive. Permissions multi-user.
Keywords: with entry, has, can, def, impl, glob, obj, node, edge, walker, spawn, visit, disengage, skip, report, sem, by, `root, self, here, visitor, del, async/await, match/case, try/except, import/from.
Quick Syntax: has n:t=v. def n(p:t=d)->r{...}. obj N{has;def}. node N{has;def;can}. edge E{has}. walker W{has;can}. n1++>n2. n1+>:E:p=v:+>n2. spawn w(). visit [-->]. report v. def f(p)->r by llm(). lambda x:t:e. match v{case p:...}. impl C.m{...}. test "n"{assert}.
