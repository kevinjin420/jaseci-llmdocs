# Jac Language Documentation (Condensed Edition)

**This is a significantly condensed version of the Jac language documentation.**

The original 40,447-line documentation contained substantial duplication across:
- Tutorial sections (Jac Book vs Beginners Guide ~70% overlap)
- Object-Spatial Programming explanations (repeated 10+ times)
- Installation guides (4 duplicate versions)
- Code examples (same patterns with minor variations)
- Setup instructions (repeated in every section)

## What's Included

**Essential Documentation (Fully Preserved):**
- âœ… Breaking Changes & Migration Guides
- âœ… Release Notes & Roadmap
- âœ… Complete Internals & Architecture Documentation
- âœ… Symbol Tables & Planning Specifications
- âœ… Plugin Development Guides
- âœ… Jac-byLLM AI Integration (complete)
- âœ… Jac Cloud Deployment (complete)
- âœ… Core Jac Book Tutorial Chapters (1, 4, 5, 7, 8, 9, 10, 12, 17, 18, 21)
- âœ… Learning Resources & Keywords Reference
- âœ… CLI Tools Documentation

**Condensed Sections:**
- ðŸ“ Beginners Guide (intro only, references Jac Book)
- ðŸ“ Data Spatial FAQ (questions only, brief answers)
- ðŸ“ Duplicate code examples removed

**Removed (High Duplication):**
- âŒ installation.md (merged into getting_started.md)
- âŒ jac_in_a_flash.md (content in Tour section)
- âŒ Non-core Jac Book chapters (2, 3, 6, 11, 13-16, 19-20)
- âŒ Example README files (content in implementation files)
- âŒ Duplicate "What is Jac" explanations

## Using This Documentation

For the most efficient learning path:
1. Start with **Getting Started** for installation
2. Follow **Jac Book Core Chapters** (1â†’4â†’5â†’7â†’8â†’9â†’10â†’12) for progressive learning
3. Reference **Keywords** and **CLI Tools** as needed
4. Use **Jac-byLLM** for AI integration
5. Deploy with **Jac Cloud** documentation

---



================================================================================
FILE: docs/communityhub/breaking_changes.md
================================================================================


# Breaking Changes

This page documents significant breaking changes in Jac and Jaseci that may affect your existing code or workflows. Use this information to plan and execute updates to your applications.

## Latest Breaking Changes

MTLLM library is now deprecated and replaced by the byLLM package. In all place where `mtllm` was used before can be replaced with `byllm`.

### Version 0.8.8

#### 1. `check` Keyword Removed - Use `assert` in Test Blocks

The `check` keyword has been removed from Jaclang. All testing functionality is now unified under `assert` statements, which behave differently depending on context: raising exceptions in regular code and reporting test failures within `test` blocks.

**Before**

```jac
glob a: int = 5;
glob b: int = 2;

test test_equality {
    check a == 5;
    check b == 2;
}

test test_comparison {
    check a > b;
    check a - b == 3;
}

test test_membership {
    check "a" in "abc";
    check "d" not in "abc";
}

test test_function_result {
    check almostEqual(a + b, 7);
}
```

**After**

```jac
glob a: int = 5;
glob b: int = 2;

test test_equality {
    assert a == 5;
    assert b == 2;
}

test test_comparison {
    assert a > b;
    assert a - b == 3;
}

test test_membership {
    assert "a" in "abc";
    assert "d" not in "abc";
}

test test_function_result {
    assert almostEqual(a + b, 7);
}
```

**Key Changes:**
- Replace all `check` statements with `assert` statements in test blocks
- `assert` statements in test blocks report test failures without raising exceptions
- `assert` statements outside test blocks continue to raise `AssertionError` as before
- Optional error messages can be added: `assert condition, "Error message";`

This change unifies the testing and validation syntax, making the language more consistent while maintaining all testing capabilities.

### Version 0.8.4

#### 1. Global, Nonlocal Operators Updated to `global`, `nonlocal`

This renaming aims to make the operator's purpose align with python, as `global`, `nonlocal` more aligned with python.

**Before**

```jac
glob x = "Jaclang ";

def outer_func -> None {
    :global: x; # :g: also correct

    x = 'Jaclang is ';
    y = 'Awesome';
    def inner_func -> tuple[str, str] {
        :nonlocal: y; #:nl: also correct

        y = "Fantastic";
        return (x, y);
    }
    print(x, y);
    print(inner_func());
}

with entry {
    outer_func();
}
```

**After**

```jac
glob x = "Jaclang ";

def outer_func -> None {
    global x;

    x = 'Jaclang is ';
    y = 'Awesome';
    def inner_func -> tuple[str, str] {
        nonlocal y;

        y = "Fantastic";
        return (x, y);
    }
    print(x, y);
    print(inner_func());
}

with entry {
    outer_func();
}
```

#### 2. `mtllm.llms` Module Replaced with Unified `mtllm.llm {Model}`

The mtllm library now uses a single unified Model class under the `mtllm.llm` module, instead of separate classes like `Gemini` and `OpenAI`. This simplifies usage and aligns model loading with HuggingFace-style naming conventions.

**Before**

```jac
import from mtllm.llms { Gemini, OpenAI }

glob llm1 = Gemini(model_name="gemini-2.0-flash");
glob llm2 = OpenAI();
```

**After**

```jac
import from mtllm.llm { Model }

glob llm1 = Model(model_name="gemini/gemini-2.0-flash");
glob llm2 = Model(model_name="gpt-4o");
```

### Version 0.8.1

#### 1. `dotgen` builtin function is now name `printgraph`

This renaming aims to make the function's purpose clearer, as `printgraph` more accurately reflects its action of outputting graph data, similar to how it can also output in JSON format. Also other formats may be added (like mermaid).

**Before**

```jac
node N {has val: int;}
edge E {has val: int = 0;}

with entry {
    end = root;
    for i in range(0, 2) {
        end +>: E : val=i :+> (end := [ N(val=i) for i in range(0, 2) ]);
    }
    data = dotgen(node=root);
    print(data);
}
```

**After**

```jac
node N {has val: int;}
edge E {has val: int = 0;}

with entry {
    end = root;
    for i in range(0, 2) {
        end +>: E : val=i :+> (end := [ N(val=i) for i in range(0, 2) ]);
    }
    data = printgraph(node=root);
    print(data);
}
```

#### 2. `ignore` feature is removed

This removal aims to avoid being over specifc with data spatial features.

**Before**

```jac
node MyNode {
    has val:int;
}

walker MyWalker {
    can func1 with MyNode entry {
        ignore [here];
        visit [-->]; # before
        print(here);
    }
}

with entry {
    n1 = MyNode(5);
    n1 ++> MyNode(10) ++> MyNode(15) ++> n1; # will result circular
    n1 spawn MyWalker();
}
```

**After**

```jac
node MyNode {
    has val:int;
}

walker MyWalker {
    has Ignore: list = [];

    can func1 with MyNode entry {
        self.Ignore.append(here); # comment here to check the circular graph
        visit [i for i in [-->] if i not in self.Ignore]; # now
        print(here);
    }
}

with entry {
    n1 = MyNode(5);
    n1 ++> MyNode(10) ++> MyNode(15) ++> n1; # will result circular
    n1 spawn MyWalker();
}
```

### Version 0.8.0 (Main branch since 5/5/2025)

#### 1. `impl` keyword introduced to simplify Implementation

The new `impl` keyword provides a simpler and more explicit way to implement abilities and methods for objects, nodes, edges, and other types. This replaces the previous more complex colon-based syntax for implementation.

**Before (v0.7.x):**
```jac
:obj:Circle:def:area -> float {
    return math.pi * self.radius * self.radius;
}

:node:Person:can:greet with Room entry {
    print("Hello, I am " + self.name);
}

:def:calculate_distance(x: float, y: float) -> float {
    return math.sqrt(x*x + y*y);
}
```

**After (v0.8.0+):**
```jac
impl Circle.area -> float {
    return math.pi * self.radius * self.radius;
}

impl Person.greet with Room entry {
    return "Hello, I am " + self.name;
}

impl calculate_distance(x: float, y: float) -> float {
    return math.sqrt(x*x + y*y);
}
```

This change makes the implementation syntax more readable, eliminates ambiguity, and better aligns with object-oriented programming conventions by using the familiar dot notation to indicate which type a method belongs to.

#### 2. Inheritance base classes specification syntax changed

The syntax for specifying inheritance has been updated from using colons to using parentheses, which better aligns with common object-oriented programming languages.

**Before (v0.7.x):**
```jac
obj Vehicle {
    has wheels: int;
}

obj Car :Vehicle: {
    has doors: int = 4;
}

node BaseUser {
    has username: str;
}

node AdminUser :BaseUser: {
    has is_admin: bool = true;
}
```

**After (v0.8.0+):**
```jac
obj Vehicle {
    has wheels: int;
}

obj Car(Vehicle) {
    has doors: int = 4;
}

node BaseUser {
    has username: str;
}

node AdminUser(BaseUser) {
    has is_admin: bool = true;
}
```

This change makes the inheritance syntax more intuitive and consistent with languages like Python, making it easier for developers to understand class hierarchies at a glance.

#### 3. `def` keyword introduced

Instead of using `can` keyword for all functions and abilities, `can` statements are only used for object-spatial abilities and `def` keyword must be used for traditional python like functions and methods.

**Before (v0.7.x and earlier):**
```jac
can add(x: int, y: int) -> int {
    return x + y;
}

node Person {
    has name;
    has age;

    can get_name {
        return self.name;
    }

    can greet with speak_to {
        return "Hello " + visitor.name + ", my name is " + self.name;
    }

    can calculate_birth_year {
        return 2025 - self.age;
    }
}
```

**After (v0.8.0+):**
```jac
def add(x: int, y: int) -> int {
    return x + y;
}

node Person {
    has name;
    has age;

    def get_name {
        return self.name;
    }

    can greet with speak_to entry {
        return "Hello " + visitor.name + ", my name is " + self.name;
    }

    def calculate_birth_year {
        return 2025 - self.age;
    }
}
```

#### 4. `visitor` keyword introduced

Instead of using `here` keyword to represent the other object context while `self` is the self referencial context. Now `here` can only be used in walker abilities to reference a node or edge, and `visitor` must be used in nodes/edges to reference the walker context.

**Before (v0.7.x and earlier):**
```jac
node Person {
    has name;

    can greet {
        self.name = self.name.upper();
        return "Hello, I am " + self.name;
    }

    can update_walker_info {
        here.age = 25;  # 'here' refers to the walker
    }
}

walker PersonVisitor {
    has age;

    can visit: Person {
        here.name = "Visitor";  # 'here' refers to the current node
        report here.greet();
    }
}
```

**After (v0.8.0+):**
```jac
node Person {
    has name;

    can greet {
        self.name = self.name.upper();
        return "Hello, I am " + self.name;
    }

    can update_walker_info {
        visitor.age = 25;  # 'visitor' refers to the walker
    }
}

walker PersonVisitor {
    has age;

    can visit: Person {
        here.name = "Visitor";  # 'here' still refers to the current node in walker context
        report here.greet();
    }
}
```

This change makes the code more intuitive by clearly distinguishing between:
- `self`: The current object (node or edge) referring to itself
- `visitor`: The walker interacting with a node/edge
- `here`: Used only in walker abilities to reference the current node/edge being visited

#### 5. Changes to lambda syntax and `lambda` instroduced

Instead of using the `with x: int can x;` type syntax the updated lambda syntax now replaces `with` and `can` with `lambda` and `:` repsectively.

**Before (v0.7.x):**
```jac
# Lambda function syntax with 'with' and 'can'
with entry {
    square_func = with x: int can x * x;
}
```

**After (v0.8.0+):**
```jac
# Updated lambda
with entry {
    square_func = lambda x: int: x * x;
}
```

This change brings Jac's lambda syntax closer to Python's familiar `lambda parameter: expression` pattern, making it more intuitive for developers coming from Python backgrounds while maintaining Jac's type annotations.

#### 6. Data spatial arrow notation updated

The syntax for typed arrow notations are updated as `-:MyEdge:->` and `+:MyEdge:+>` is now `->:MyEdge:->` and `+>:MyEdge:+> for reference and creations.

**Before (v0.7.x):**
```jac
friends = [-:Friendship:->];
alice <+:Friendship:strength=0.9:+ bob;
```

**After (v0.8.0+):**
```jac
friends = [->:Friendship:->];
alice <+:Friendship:strength=0.9:<+ bob;
```

This change was made to eliminate syntax conflicts with Python-style list slicing operations (e.g., `my_list[:-1]` was forced to be written `my_list[: -1]`). The new arrow notation provides clearer directional indication while ensuring that object-spatial operations don't conflict with the token parsing for common list operations.

#### 7. Import `from` syntax updated for clarity

The syntax for importing specific modules or components from a package has been updated to use curly braces for better readability and to align with modern language conventions.

**Before (v0.7.x):**
```jac
import from pygame_mock, color, display;
import from utils, helper, math_utils, string_formatter;
```

**After (v0.8.0+):**
```jac
import from pygame_mock { color, display };
import from utils { helper, math_utils, string_formatter };
```

This new syntax using curly braces makes it clearer which modules are being imported from which package, especially when importing multiple items from different packages.

#### 8. Import statement are auto resolved (no language hints needed)

The language-specific import syntax has been simplified by removing the explicit language annotations (`:py` and `:jac`). The compiler now automatically resolves imports based on context and file extensions.

**Before (v0.7.x):**
```jac
import:py requests;
import:jac graph_utils;
import:py json, os, sys;
```

**After (v0.8.0+):**
```jac
import requests;
import graph_utils;
import json, os, sys;
```

This change simplifies the import syntax, making code cleaner while still maintaining the ability to import from both Python and Jac modules. The Jac compiler now intelligently determines the appropriate language context for each import.

#### 9. `restrict` and `unrestrict` Interfaces to Jac Machine now `perm_grant` and `perm_revoke`

The permission management API has been renamed to better reflect its purpose and functionality.

**Before (v0.7.x):**
```jac
walker create_item {
    can create with `root entry {
        new_item = spawn Item(name="New Item");
        Jac.unrestrict(new_item, level="CONNECT");  # Grant permissions
        Jac.restrict(new_item, level="WRITE");      # Revoke permissions
    }
}
```

**After (v0.8.0+):**
```jac
walker create_item {
    can create with `root entry {
        new_item = spawn Item(name="New Item");
        Jac.perm_grant(new_item, level="CONNECT");  # Grant permissions
        Jac.perm_revoke(new_item, level="WRITE");   # Revoke permissions
    }
}
```

This change makes the permission management API more intuitive by using verbs that directly describe the actions being performed.



================================================================================
FILE: docs/communityhub/content_pieces.md
================================================================================


--8<-- "jac/examples/shopping_cart/shopping_cart.md"

--8<-- "jac/examples/medical/medical.md"



================================================================================
FILE: docs/communityhub/fun/p1.md
================================================================================


## Project Idea: Rebuilding Aider with Jac and Agentic Object-Spatial Programming

This project proposes enhancing Aider's architecture using Jac's object-spatial programming paradigm and byLLM (`by <llm>`) features to optimize multi-file editing, token handling, and repository understanding through graph-based representations.

### Core Concepts

#### Aider's Functionality

Aider assists developers by:

1.  **Understanding Code Structure:** Analyzing the existing codebase to build a mental model.
2.  **Responding to Prompts:** Taking user requests (e.g., "add a new feature," "fix this bug," "refactor this code").
3.  **Generating Code Changes:** Producing code snippets or entire file modifications.
4.  **Applying Changes:** Integrating the generated code into the existing codebase.
5.  **Iterative Refinement:** Allowing users to review, accept, or reject changes, and provide further instructions.

#### Jac's Object-Spatial Programming

In Jac, a codebase can be represented as a graph.

*   **Nodes:** Represent files, classes, functions, variables, comments, and other code constructs. Each node can have properties (e.g., file path, function signature, variable type, code content).
*   **Edges:** Represent relationships between these constructs (e.g., a function `calls` another function, a class `contains` a method, a file `imports` another file, a variable is `defined in` a function).
*   **Walkers:** Can traverse this code graph to understand its structure, identify relevant sections for a given prompt, and even apply modifications.

#### Jac's byLLM (`by <llm>`)

The `by <llm>` feature allows Jac to delegate complex reasoning and generation tasks to Large Language Models.

*   **Natural Language Understanding:** An LLM can interpret user prompts for Aider.
*   **Code Generation:** An LLM can generate code snippets based on the prompt and the context derived from the code graph.
*   **Decision Making:** An LLM can decide which parts of the code graph are most relevant to a user's request.

#### Understanding Aider's Current Architecture

Aider's success comes from several key architectural decisions:

*   **Tree-sitter Based Repository Map:** Uses tree-sitter to parse source code into ASTs, extracting symbol definitions and references to create a concise map of the codebase.
*   **Graph Ranking Algorithm:** Analyzes dependencies between files as a graph, using ranking algorithms to select the most relevant portions of the repo_map that fit within token budgets (default 1k tokens via `--map-tokens`).
*   **Multiple Edit Formats:** Supports different edit formats (diff, whole, udiff, diff-fenced, editor-*) optimized for different LLM capabilities and use cases.
*   **Architect/Editor Mode:** Separates high-level reasoning (architect) from detailed code editing (editor), allowing optimal model pairing (e.g., o1 + GPT-4o).
*   **Context Management:** Dynamically adjusts repo_map size based on chat state, expanding when no files are in context, contracting when specific files are being edited.
*   **Git Integration:** Automatic commits, diff management, and change tracking through git integration.

#### Jac OSP Value Proposition

Where Jac's Object-Spatial Programming can enhance this proven architecture:

*   **Richer Graph Representation:** While Aider uses file-level dependency graphs for ranking, OSP can represent finer-grained relationships (function calls, variable usage, type dependencies) as first-class spatial relationships.
*   **Advanced Traversal Patterns:** Jac walkers can implement sophisticated traversal algorithms for context gathering that go beyond simple graph ranking.
*   **Multi-File Change Coordination:** OSP's spatial relationships can help ensure consistency across complex refactoring that spans multiple files.
*   **Query-Based Context Selection:** Instead of purely algorithmic ranking, enable semantic queries like "find all functions that handle user authentication" through spatial traversal.
*   **Incremental Graph Updates:** Maintain live graph representation that updates as code changes, enabling more sophisticated change impact analysis.

### Proposed OSP Mode Implementation

Building upon Aider's proven architecture, we propose specific enhancements using Jac's object-spatial programming:

1.  **Enhanced Repository Graph with OSP:**
    *   Extend Aider's existing tree-sitter based repo_map with Jac's spatial graph capabilities.
    *   Create a dynamic, queryable codebase graph where nodes represent code entities (files, classes, functions, variables) and edges represent relationships (calls, imports, dependencies, inheritance).
    *   Use Jac's native graph traversal to optimize the current graph ranking algorithm that selects relevant portions of the repository map.

2.  **Intelligent Context Retrieval with Spatial Walkers:**
    *   Implement specialized walkers that can traverse the codebase graph to gather contextually relevant information.
    *   `ContextGatheringWalker` - navigates from a starting point to collect related code entities based on semantic distance and dependency relationships.
    *   `ImpactAnalysisWalker` - determines which files/functions would be affected by proposed changes.
    *   `DependencyWalker` - maps function call chains and import dependencies for better context understanding.

3.  **byLLM-Optimized Architect and Editor Pipeline:**
    *   Enhance Aider's existing architect/editor mode with OSP-optimized prompting.
    *   `ArchitectLLM` - analyzes user requests and proposes high-level changes using the spatial graph context.
    *   `EditorLLM` - translates architectural decisions into specific code edits, optimized for Aider's existing edit formats (diff, whole, udiff).
    *   Use Jac's `by <llm>` syntax to create specialized abilities for different aspects of code understanding and generation.

4.  **Enhanced Token Budget Management:**
    *   Implement dynamic token allocation using spatial graph analysis.
    *   `TokenBudgetOptimizer` - walker that prioritizes which parts of the repo_map to include based on relevance scores derived from graph centrality and user context.
    *   Smart context windowing that expands/contracts based on the complexity of the requested changes.

5.  **Multi-File Change Coordination:**
    *   `ChangeCoordinator` - walker that ensures consistency across multi-file edits.
    *   Implements change propagation logic to maintain code integrity across file boundaries.
    *   Validates that changes in one file don't break contracts expected by dependent files.

6.  **OSP-Enhanced Mode:**
    *   Introduce a new `/genius` mode that leverages full OSP capabilities.
    *   This mode builds and maintains a live graph of the codebase, updating it as changes are made.
    *   Provides advanced querying capabilities like "find all functions that depend on this API" or "show me the call chain for this error path".

### Key OSP Optimizations for Aider's Core Components

#### 1. Repository Map Enhancement

### Proposed OSP Mode Implementation

Building upon Aider's existing chat modes (code, architect, ask, help), introduce a new `/genius` mode

#### Integration with Existing Aider Commands

Extend existing commands with spatial awareness:

```bash
# Enhanced /add command with spatial context
/add --spatial file.py  # Automatically add related files based on dependencies

# Enhanced repository understanding
/genius find "error handling"  # Find all error handling code
/genius trace payment_flow     # Trace payment processing dependencies
/genius impact "database schema change"  # Analyze impact of schema changes

# Context expansion based on spatial relationships
/expand --spatial  # Add files related to current context via graph traversal
```

### Expected Benefits and Improvements

#### 1. Better Multi-File Editing
- **Current Issue:** Aider sometimes misses dependent files that need updates when making complex changes
- **OSP Solution:** Spatial traversal ensures all related code is identified and considered
- **Example:** When refactoring an API, automatically identify all client code that needs updates

#### 2. Optimized Token Usage
- **Current Issue:** Fixed token budgets may include irrelevant code or miss important context
- **OSP Solution:** Dynamic context selection based on spatial relevance and user intent
- **Example:** For authentication changes, prioritize auth-related code over unrelated utilities

#### 3. Enhanced Code Understanding
- **Current Issue:** Limited to file-level dependencies and tree-sitter symbol extraction
- **OSP Solution:** Function-level dependencies, usage patterns, and semantic relationships
- **Example:** Understanding that error handling functions are related even across different modules

#### 4. Improved Change Impact Analysis
- **Current Issue:** Manual identification of files that might be affected by changes
- **OSP Solution:** Automated impact analysis using graph traversal
- **Example:** Changing a database model automatically identifies all services, controllers, and tests that use it

### Performance Benchmarks and Metrics

To validate the OSP enhancements, we would measure:

1. **Multi-File Change Success Rate:** Percentage of complex changes that don't require manual fixes
2. **Context Relevance Score:** How often included context is actually used in generated changes
3. **Token Efficiency:** Amount of relevant context per token in the budget
4. **Change Completeness:** Percentage of dependent changes automatically identified
5. **User Satisfaction:** Reduced number of iterations needed to complete complex tasks

### Practical Implementation Strategy

#### Phase 1: Proof of Concept
```jac
# Basic spatial graph representation
node CodeFile {
    has path: str;
    has content: str;
    has symbols: list[str];
    has imports: list[str];
}

edge FileRelation {
    has relation_type: str; // imports, calls, references
}

walker BasicSpatialMapper {
    can build_file_graph(repo_path: str) -> 'SpatialGraph';
    can find_related_files(target_file: str) -> list[str];
}
```

#### Phase 2: Integration with Aider
- Create Jac plugin that integrates with Aider's existing repo_map generation
- Implement basic spatial queries for context enhancement
- Add `/genius` command support to Aider's CLI

#### Phase 3: byLLM Optimization
- Implement LLM-powered context selection and summarization
- Enhance architect/editor pipeline with spatial context
- Add intelligent token budget allocation

#### Phase 4: Advanced Features
- Multi-file change coordination
- Impact analysis and change propagation
- Performance optimization and caching

### Getting Started

For contributors interested in this project:

1. **Understand Aider's Architecture:** Study the repo_map implementation, graph ranking algorithms, and architect/editor modes
2. **Learn Jac OSP:** Familiarize with Jac's spatial programming concepts, walkers, and graph traversal
3. **Experiment with byLLM:** Practice using Jac's `by <llm>` features for code analysis tasks
4. **Start Small:** Begin with a simple spatial graph representation of a small codebase
5. **Benchmark Early:** Establish baseline measurements for context relevance and change success rates

### Advantages of the OSP-Enhanced Approach

*   **Builds on Proven Architecture:** Leverages Aider's successful tree-sitter based repo_map and graph ranking algorithms while enhancing them with OSP capabilities.
*   **Optimized Token Management:** Smart context selection using spatial graph analysis ensures maximum relevance within token budgets.
*   **Multi-File Coherence:** OSP's spatial relationships help maintain consistency across complex multi-file changes.
*   **Scalable Architecture:** Graph-based approach scales better with repository size compared to linear approaches.
*   **Enhanced Architect/Editor Pipeline:** byLLM optimization of Aider's existing two-stage approach for better reasoning and editing separation.
*   **Advanced Query Capabilities:** Spatial queries enable sophisticated code understanding ("find all callers", "trace data flow", "impact analysis").
*   **Extensible Framework:** New walkers and capabilities can be easily added for different types of code analysis and modification patterns.

This project would demonstrate Jac's capabilities in enhancing existing AI-powered development tools while providing significant improvements to multi-file editing, context management, and repository understanding. The OSP approach offers a principled way to represent and navigate complex codebases that could benefit the broader AI-assisted development ecosystem.

### References and Further Reading

- [Aider Documentation](https://aider.chat/docs/) - Understanding current architecture and capabilities
- [Repository Map with Tree-sitter](https://aider.chat/2023/10/22/repomap.html) - Aider's approach to code context
- [Architect/Editor Mode](https://aider.chat/2024/09/26/architect.html) - Separating reasoning from editing
- [Jac Documentation](https://www.jac-lang.org/) - Object-Spatial Programming concepts
- [byLLM Framework](https://github.com/jaseci-labs/jaseci/tree/main/jac-byllm) - AI integration in Jac





================================================================================
FILE: docs/communityhub/fun/p2.md
================================================================================


## Project Idea: Codebase Genius

Welcome to the **Codebase Genius** project.
The goal of this project is to build an **AI-powered, agentic system** capable of autonomously generating **comprehensive documentation** for any given software repository from GitHub.

This project is built around a **multi-agent architecture**, where each intelligent agent is responsible for a distinct task such as file structure parsing, semantic understanding, diagram generation, and final documentation writing. These agents **collaborate in a pipeline** to analyze and document codebases effectively.

This document outlines the **project's scope, agent-based architecture**, and **core functionalities** to guide you in your development process.

---

## Project Scope

The primary objective is to create an agentic system that accepts a **GitHub repository URL** and produces **quality markdown documentation**.
The system should be particularly effective for repositories written in **Python** and **Jac**.

A key feature will be the **automatic generation of visual diagrams** to represent the codebase's structure and flow.

---

## Core Functionalities

The final application should be able to perform the following tasks:

- **Clone a Repository**: Fetch the source code from a given GitHub URL.
- **Analyze File Structure**: Understand and map the complete directory and file layout.
- **Analyze Code Relationships**: Parse the code to understand how different parts of the system interact (e.g., which functions call others, how classes are related). This is also known as building a **Code Context Graph (CCG)**.
- **Generate Documentation**: Create a final markdown document that includes descriptions of the code and visual aids.

---

## High-Level Workflow

The process can be broken down into a sequence of clear steps. The agent will first understand the **"what" and "where"** of the code and then dive deeper to understand the **"how."**

```mermaid
flowchart LR
    A[Clone the Repo] --> B[Get File and Folder Structure]
    B --> C[Retrieve and Analyze README.md]
    C --> D[Pass to LLM for High-Level Planning]
    D --> E[Iteratively Analyze Code Content]
    E --> F[Generate Final Documentation]
```

### Workflow Steps

1. **Clone the Repo**
   Clone the target GitHub repository to access its files.

2. **Get File and Folder Structure**
   Generate a map of the entire repository to understand the layout.

3. **Retrieve and Analyze `README.md`**
   Use the README file for a high-level project summary.

4. **High-Level Planning**
   An LLM uses this initial data to create a plan for which parts of the codebase to document first.

5. **Iteratively Analyze Code Content**
   Parse source files to understand logic, structure, and relationships.

6. **Generate the Documentation**
   Assemble a comprehensive markdown document with visual diagrams.

---

## Proposed Architecture: A Multi-Agent System

To accomplish this, a **multi-agent architecture** will be used. Think of it as a team of specialized AI agents managed by a supervisor.

<img src="/assets/p2_arch.png" alt="Architecture" width="800"/>

### Components

- **Supervisor Agent**:  Manages the workflow and orchestrates the agents.

- **Worker Agents**:  Each with a distinct role:
    - **Repo Mapper**: Analyzes structure and README.
    - **Code Analyzer**: Parses and understands source code.
    - **DocGenie**: Produces the documentation and diagrams.

---

## Agent Responsibilities

### Code Genius Agent (Supervisor)

- Oversees the entire workflow.
- Manages execution order and integration of all worker agents.
- Ensures final output is cohesive and complete.

---

### Repo Mapper

Responsible for high-level repository mapping:

- **File Tree Generator**: Builds a structured view of the file system, ignoring unnecessary files and folders (e.g., `.git`, `node_modules`, etc.).
- **Readme Summarizer**: Extracts a concise summary from the `README.md` file to provide context for the documentation process.

---

### Code Analyzer

Performs in-depth code analysis:

- Uses tools such as Tree-sitter for parsing.
- Identifies functions, classes, and their relationships.
- Builds the foundation for understanding code logic and interaction.

---

### DocGenie

Responsible for generating documentation:

- Converts structured code insights into human-readable markdown.
- Integrates visual diagrams to enhance clarity and comprehension.

---

## Documentation Strategy

To ensure that the documentation is both clear and complete, follow this three-phase strategy:

### 1. Initial Mapping

- Begin with a full map of the repository structure.
- Helps understand the overall layout of the codebase.

### 2. Prioritized Exploration

- Focus on high-impact files (e.g., `main.py`, `app.py`, entry points).
- Document these areas first for maximum value.

### 3. Backfill Coverage

- Complete documentation for remaining utility and support files.
- Ensures completeness without sacrificing efficiency.

---

## Inputs & Outputs

**Input**: A GitHub repository URL (public repo for MVP)
**Output**: Markdown (`.md`) files saved locally, containing comprehensive documentation of the repository

---

## Final Notes

- The output should be **quality markdown files**.
- It must be readable, logically structured, and visually aided with diagrams where applicable.
- The system should be generalizable but optimized for **Python** and **Jac** repositories.
- If you are able to support additional programming languages beyond Python and Jac, feel free to extend the system's capabilities to handle them as well.

---

### Good Luck!

Build smart, write clean, and may your agents generate world-class documentation! âœ¨




================================================================================
FILE: docs/communityhub/fun/p3.md
================================================================================


## Project Idea: Auto-Adaptive Fine-tuning for Jac byLLM using RPG Game Generation

This project focuses on creating an intelligent byLLM system that automatically collects training data from large model interactions and continuously fine-tunes smaller, local models to replace them. Using RPG game level generation as the primary use case, the system will learn to replicate the performance of large models with efficient, locally-running alternatives.

### Problem Statement

Current byLLM implementations rely heavily on expensive, cloud-based large language models for complex structured data generation tasks. This creates several challenges:

* **High API Costs:** Continuous use of large models for repetitive structured generation tasks becomes prohibitively expensive
* **Latency Issues:** Network calls to external APIs introduce delays in real-time applications
* **Dependency Risk:** Applications become dependent on external service availability and pricing changes

### **Proposed Solution**

1. **Dataset Generation Using Large Models**

    *   **Complex Use Case Selection:** Focus on RPG game level generation as a representative complex structured data generation task that requires:
        - Understanding of game mechanics and spatial relationships
        - Generation of valid, interconnected game objects (players, enemies, terrain)
        - Adherence to strict structural constraints and playability rules

    *   **Automated Game Level Generation Pipeline:**
        - Implement Jac abilities that use large models (GPT-4, Claude, Gemini Pro) via `by <llm>` calls to generate complete RPG game levels
        - Execute multiple generation runs to create a diverse corpus of level designs
        - Each generation includes the original prompt context and the structured level output from `by <llm>` call sites

    *   **Automated Evaluation and Filtering (Optional):**
        - Develop generalized automated evaluation methodologies that can assess output quality across different structured generation tasks
        - For RPG levels specifically, implement optional filtering that validates:
            - Presence of required player spawn points
            - Inclusion of appropriate enemy placements
            - Reachability analysis ensuring all areas are accessible
            - Structural integrity of the level layout
        - The system should support both filtered high-quality datasets and unfiltered comprehensive datasets depending on use case requirements

2. **Small LLM Training Pipeline**

    *   **Model Selection:** Use TinyLLaMA as the target model for fine-tuning due to its balance of capability and efficiency for local deployment.

    *   **Training Methodology:**
        - Implement LoRA (Low-Rank Adaptation) and QLoRA (Quantized LoRA) techniques for parameter-efficient fine-tuning
        - Utilize the dataset of RPG level generation examples from `by <llm>` interactions
        - Apply quantization techniques to further optimize model size and inference speed

3. **byLLM Plugin Integration**

    *   **Automatic Data Collection:**
        - Integrate data collection capabilities directly into the byLLM plugin
        - Automatically capture prompt-response pairs from successful large model `by <llm>` interactions
        - Continuously expand the training dataset in the background

    *   **Dynamic Model Training:**
        - Implement background training processes that periodically fine-tune local models using accumulated data
        - Schedule training during low-usage periods to minimize system impact

    *   **Intelligent Model Switching:**
        - Develop logic to automatically switch from large models to fine-tuned local models when confidence thresholds are met
        - Implement per-`by <llm>`-call-site model caching, allowing different call locations to use specialized models

    *   **Model Persistence:**
        - Cache and save trained models specific to each `by <llm>` call site
        - Enable model versioning and rollback capabilities

4. **Evaluation Framework**

    *   **Manual Correctness Assessment:**
        - Establish systematic manual evaluation protocols for generated RPG levels
        - Create scoring rubrics that assess:
            - Gameplay viability and fun factor
            - Structural correctness and consistency
            - Adherence to specified constraints and themes
        - Compare performance between large model outputs and fine-tuned local model outputs from respective `by <llm>` calls

This approach transforms byLLM from a static large-model-dependent system into an intelligent, self-improving platform that automatically optimizes for cost, speed, and performance while maintaining output quality across all `by <llm>` interactions.



================================================================================
FILE: docs/communityhub/fun/projects.md
================================================================================


# Project Ideas for the Jac Community

This page lists potential projects that can be built using Jac and Jaseci to facilitate learning and experimentation!

| Project Name                                      | Description                                                                                                | Link                        |
| :------------------------------------------------ | :--------------------------------------------------------------------------------------------------------- | :-------------------------- |
| Rebuilding Aider with Jac                         | Rebuilding Aider, the AI pair programming tool, using Jac and its object-spatial programming paradigm.       | [p1.md](./p1.md)            |
| Codebase Genius - AI Documentation Generator      | An agentic system that ingests a GitHub repo and generates rich Markdown documentation using Jac and byLLM.  | [p2.md](./p2.md)            |
| Fine-tuning TinyLLaMA for Jac byLLM Performance | Fine-tuning TinyLLaMA to improve its ability to handle Jac's byLLM `by <llm>` calls.                        | [p3.md](./p3.md)            |


Join our discord to ask questions and engage (https://discord.gg/6j3QNdtcN6)



================================================================================
FILE: docs/communityhub/release_notes.md
================================================================================


# Release Notes

This document provides a summary of new features, improvements, and bug fixes in each version of Jac and Jaseci. For details on changes that might require updates to your existing code, please refer to the [Breaking Changes](./breaking_changes.md) page.


## jaclang 0.8.9 / jac-cloud 0.2.9 / byllm 0.4.4 (Unreleased)

- **Typed Context Blocks (OSP)**: Fully implemented typed context blocks (`-> NodeType { }` and `-> WalkerType { }`) for Object-Spatial Programming, enabling conditional code execution based on runtime types.
- **Triple Quoted F-String Support**: Added support for triple quoted f-strings in the language, enabling multi-line formatted strings with embedded expressions (e.g., `f"""Hello {name}"""`).
- **`is` Keyword for Semstrings**: Added support for using `is` as an alternative to `=` in semantic string declarations (e.g., `sem MyObject.value is "A value stored in MyObject"`).
- **Library Mode Interface**: Added new `jaclang.lib` module that provides a clean, user-friendly interface for accessing JacMachine functionality in library mode. This module auto-exposes all static methods from `JacMachineInterface` as module-level functions, making it easier to use Jac as a Python library.
- **New `jac2lib` CLI Command**: Introduced `jac2lib` command that generates cleaner Python code suitable for library use. Unlike `jac2py` which uses aliased imports (e.g., `_jl.Walker`), `jac2lib` generates direct imports from `jaclang.lib` (e.g., `from jaclang.lib import Walker`), producing more readable and maintainable Python output.
- **byLLM Plugin Interface Improved**: Enhanced the byLLM plugin interface with `get_mtir` function hook interface and refactored the `by` decorator to use the plugin system, improving integration and extensibility.

## jaclang 0.8.8 / jac-cloud 0.2.8 / byllm 0.4.3

- **Better Syntax Error Messages**: Initial improvements to syntax error diagnostics, providing clearer and more descriptive messages that highlight the location and cause of errors (e.g., `Missing semicolon`).
- **Check Statements Removed**: The `check` keyword has been removed from Jaclang. All testing functionality previously provided by `check` statements is now handled by `assert` statements within test blocks. Assert statements now behave differently depending on context: in regular code they raise `AssertionError` exceptions, while within `test` blocks they integrate with Jac's testing framework to report test failures. This unification simplifies the language by using a single construct for both validation and testing purposes.
- **Jac Import of Python Files**: This upgrade allows Python files in the current working directory to be imported using the Jac import system by running `export JAC_PYFILE_RAISE=true`. To extend Jac import functionality to all Python files, including those in site-packages, developers can enable it by running `export JAC_PYFILE_RAISE_ALL=true`.
- **Consistent Jac Code Execution**: Fixed an issue allowing Jac code to be executed both as a standalone program and as an application. Running `jac run` now executes the `main()` function, while `jac serve` launches the application without invoking `main()`.
- **Run transformed pytorch codes**: With `export JAC_PREDYNAMO_PASS=true`, pytorch breaking if statements will be transformed into non breaking torch.where statements. It improves the efficiency of pytorch programs.
- **Complete Python Function Parameter Syntax Support**: Added full support for advanced Python function parameter patterns including positional-only parameters (`/` separator), keyword-only parameters (`*` separator without type hints), and complex parameter combinations (e.g., `def foo(a, b, /, *, c, d=1, **kwargs): ...`). This enhancement enables seamless Python-to-Jac conversion (`py2jac`) by supporting the complete Python function signature syntax.
- **Type Checking Enhancements**:
  - Added support for `Self` type resolution
  - Enabled method type checking for tools
  - Improved inherited symbol resolution (e.g., `Cat` recognized as subtype of `Animal`)
  - Added float type validation
  - Implemented parameterâ€“argument matching in function calls
  - Enhanced call expression parameter type checking
  - Enhanced import symbol type resolution for better type inference and error detection
- **VSCE Improvements**:
  - Language Server can now be restarted without requiring a full VS Code window reload
  - Improved environment handling: prompts users to select a valid Jac environment instead of showing long error messages
- **Formatter Bug Fixes**:
  - Fixed `if/elif/else` expression formatting
  - Improved comprehension formatting (list/dict/set/gen)
  - Corrected decorator and boolean operator formatting
  - Fixed function args/calls formatting (removed extra commas/spaces)
  - Fixed index slice spacing and redundant atom units
- **byLLM Enhancements**:
  - Fixed bug with Enums without values not being properly included in prompts (e.g., `enum Tell { YES, NO }` now works correctly).

## jaclang 0.8.7 / jac-cloud 0.2.7 / byllm 0.4.2 (Latest Release)

- **byLLM transition**: MTLLM has been transitioned to byLLM and PyPi package is renamed to `byllm`. Github actions are changed to push byllm PyPi. Alongside an mtllm PyPi will be pushed which installs latest `byllm` and produces a deprecation warning when imported as `mtllm`.
- **Fix `jac run same_name_of_jac.py`**- there was a bug which only runs jac file if both jac and python files were having same name. It was fixed so that developers run python files which has same name as jac with `jac run` command. (Ex: `jac run example.jac`, `jac run example.py`)
- **Fix `jac run pythonfile.py` bugs**: Few bugs such as `init` is not found, `SubTag` ast node issue, are fixed. So that developers can run `jac run` of python files without these issues.
- **Fix `lambda self injection in abilities`**: Removed unintended `self` parameter in lambdas declared inside abilities/methods.
- **Fix `jac2py lambda annotations`**: Stripped type annotations from lambda parameters during jac2py conversion to ensure valid Python output while keeping them in Jac AST for type checking.
- **byLLM Feature Methods as Tools**: byLLM now supports adding methods of classes as tools for the llm using such as `tools=[ToolHolder.tool]`

- **TypeChecker Diagnostics**: Introduced type checking capabilities to catch errors early and improve code quality! The new type checker pass provides static analysis including:
  - **Type Annotation Validation**: Checks explicit type annotations in variable assignments for type mismatches
  - **Type Inference**: Simple type inference for assignments with validation against declared types
  - **Member Access Type Checking**: Type checking for member access patterns (e.g., `obj.field.subfield`)
  - **Import Symbol Type Checking**: Type inference for imported symbols (Basic support)
  - **Function Call Return Type Validation**: Return type checking for function calls (parameter validation not yet supported)
  - **Magic Method Support**: Type checking for special methods like `__call__`, `__add__`, `__mul__`
  - **Binary Operation Type Checking**: Operator type validation with simple custom operator support
  - **Class Instantiation**: Type checking for class constructor calls and member access
  - **Cyclic Symbol Detection**: Detection of self-referencing variable assignments
  - **Missing Import Detection**: Detection of imports from non-existent modules

  Type errors now appear in the Jac VS Code extension (VSCE) with error highlighting during editing.

- **VSCE Semantic Token Refresh Optimization**: Introduced a debounce mechanism for semantic token refresh in the Jac Language Server, significantly improving editor responsiveness:
  - Reduces redundant deep checks during rapid file changes
  - Optimizes semantic token updates for smoother editing experience

- **Windows LSP Improvements**: Fixed an issue where outdated syntax and type errors persisted on Windows. Now, only current errors are displayed

## jaclang 0.8.6 / jac-cloud 0.2.6 / byllm 0.4.1

- **byLLM transition**: MTLLM has been transitioned to byLLM and PyPi package is renamed to `byllm`. Github actions are changed to push byllm PyPi. Alongside an mtllm PyPi will be pushed which installs latest `byllm` and produces a deprecation warning when imported as `mtllm`.

## jaclang 0.8.5 / jac-cloud 0.2.5 / mtllm 0.4.0

- **Jac Cloud Hot Reload**: Introduced the ability to enable development mode like uvicorn by adding `--reload` in `jac serve`. This supports targetting specific directories by using `--watch path/to/dir1,path/to/dir2` (comma separated).
- **Dynamic Runtime Walker Endpoint**: Fixes auto-generated endpoints for walkers created at runtime.
- **Removed LLM Override**: `function_call() by llm()` has been removed as it was introduce ambiguity in the grammer with LALR(1) shift/reduce error. This feature will be reintroduced in a future release with a different syntax.
- **Enhanced Python File Support**: The `jac run` command now supports direct execution of `.py` files, expanding interoperability between Python and Jac environments.
- **Jac-Streamlit Plugin**: Introduced comprehensive Streamlit integration for Jac applications with two new CLI commands:
  - `jac streamlit` - Run Streamlit applications written in Jac directly from `.jac` files
  - `jac dot_view` - Visualize Jac graph structures in interactive Streamlit applications with both static (pygraphviz)
- **Improved Windows Compatibility**: Fixed file encoding issues that previously caused `UnicodeDecodeError` on Windows systems, ensuring seamless cross-platform development.
- **Jac Clouds Traverse API**: Introduced the ability to traverse graph. This API support control of the following:
  - source - Starting node/edge. Defaults to root
  - detailed - If response includes archetype context. Defaults to False
  - depth - how deep the traversal from source. Count includes edges. Defaults to 1
  - node_types - Node filter by name. Defaults to no filter
  - edge_types - Edge filter by name. Defaults to no filter
- **Dedicated Memory commit interface.**: Introduced the interface to commit memory to db at runtime. Previously, we only have it on jac-cloud but we generalized it and support it for both jac and jac-cloud.

- **Fixed CFG inaccuracies**: Fixed issues when handling If statements with no Else body where the else edge was not captured in the CFG (as a NOOP) causing a missing branch on the CFG of the UniiR. Also fixed inaccuracies when terminating CFG branches where return statements and HasVariables had unexpected outgoing edges which are now being removed. However, the return still keeps connected to following code which are in the same scope(body) which are dead-code.

- **CFG print tool for CLI**: The CFG for a given program can be printed as a dot graph by running `jac tool ir cfg. filename.jac` CLI command.

## jaclang 0.8.4 / jac-cloud 0.2.4 / mtllm 0.3.9

- **Support Spawning a Walker with List of Nodes and Edges**: Introduced the ability to spawn a walker on a list of nodes and edges. This feature enables initiating traversal across multiple graph elements simultaneously, providing greater flexibility and efficiency in handling complex graph structures.
- **save(...) should not override root in runtime**: The previous version bypassed access validation because the target archetype root was overridden by the current root, simulating ownership of the archetype.
- **Support Custom Access Validation**: Introduced the ability to override access validation. `Node`/`Edge` can override `__jac_access__` reserved function (`builtin`) to have a different way of validating access. Either you cross-check it by current attribute, check from db or global vars or by just returning specific access level. [PR#1524](https://github.com/jaseci-labs/jaseci/pull/1524)
- **Get all Root Builtin Method**: Introduced `allroots` builtin method to get all the roots available in the memory. Developers can get all the roots in the memory/ database by calling `allroots()` method.
- **Permission Update Builtin Methods**: Introduced `grant`, `revoke` builtin methods, `NoPerm`, `ReadPerm`, `ConnectPerm`, `WritePerm` builtin enums, to give the permission to a node or revoke the permission. Developers can use them by calling `grant(node_1, ConnectPerm)` or `revoke(node_1)` method.
- **`jac create_system_admin` cli now support local db**: `DATABASE_HOST` are now not required when creating system admin.

- **Bug fix on supporting while loop with else part**: Now we are supporting while loop with else part.

## jaclang 0.8.3 / jac-cloud 0.2.3 / mtllm 0.3.8

- **Semantic Strings**: Introduced `sem` strings to attach natural language descriptions to code elements like functions, classes, and parameters. These semantic annotations can be used by Large Language Models (LLMs) to enable intelligent, AI-powered code generation and execution. (mtllm)
- **LLM Function Overriding**: Introduced the ability to override any regular function with an LLM-powered implementation at runtime using the `function_call() by llm()` syntax. This allows for dynamic, on-the-fly replacement of function behavior with generative models. (mtllm)
- **JacMachine Interface Reorganization**: The machine and interface have been refactored to maintain a shared global stateâ€”similar to Python's `sys.modules`â€”removing the need to explicitly pass execution context and dramatically improving performance.
- **Async Walker Support**: Introduced comprehensive async walker functionality that brings Python's async/await paradigm to object-spatial programming. Async walkers enable non-blocking spawns during graph traversal, allowing for concurrent execution of multiple walkers and efficient handling of I/O-bound operations.
- **Native Jac Imports**: Native import statements can now be used to import Jac modules seamlessly into python code, eliminating the need to use `_.jac_import()`.
- **Unicode String Literal Support**: Fixed unicode character handling in string literals. Unicode characters like "âœ“", "â—‹", emojis, and other international characters are now properly preserved during compilation instead of being corrupted into byte sequences.
- **Removed Ignore Statements**: The `ignore` keyword and ignore statements have been removed as this functionality can be achieved more elegantly by modifying path collection expressions directly in visit statements.

## jaclang 0.8.1 / jac-cloud 0.2.1 / mtllm 0.3.6

- **Function Renaming**: The `dotgen` built-in function has been renamed to `printgraph`. This change aims to make the function's purpose clearer, as `printgraph` more accurately reflects its action of outputting graph data. It can output in DOT format and also supports JSON output via the `as_json=True` parameter. Future enhancements may include support for other formats like Mermaid.
- **Queue Insertion Index for Visit Statements**: Visit statements now support queue insertion indices (e.g., `visit:0: [-->]` for depth-first, `visit:-1: [-->]` for breadth-first) that control where new destinations are inserted in the walker's traversal queue. Any positive or negative index can be used, enabling fine-grained control over traversal patterns and supporting complex graph algorithms beyond simple depth-first or breadth-first strategies.
- **Edge Ability Execution Semantics**: Enhanced edge traversal behavior with explicit edge references. By default, `[-->]` returns connected nodes, while `[edge -->]` returns edge objects. When walkers visit edges explicitly using `visit [edge -->]`, abilities are executed on both the edge and its connected node. Additionally, spawning a walker on an edge automatically queues both the edge and its target node for processing, ensuring complete traversal of the topological structure.
- **Jac Imports Execution**: Jac imports (`Jac.jac_import`) now run in a Python-like interpreter mode by default. Full compilation with dependency inclusion can only occur when explicitly calling `compile` from the `JacProgram` object.
- **Concurrent Execution with `flow` and `wait`**: Introduced `flow` and `wait` keywords for concurrent expressions. `flow` initiates parallel execution of expressions, and `wait` synchronizes these parallel operations. This enables efficient parallel processing and asynchronous operations directly within Jac with separate (and better) semantics than python's async/await.

## Version 0.8.0

- **`impl` Keyword for Implementation**: Introduced the `impl` keyword for a simpler, more explicit way to implement abilities and methods for objects, nodes, edges, and other types, replacing the previous colon-based syntax.
- **Updated Inheritance Syntax**: Changed the syntax for specifying inheritance from colons to parentheses (e.g., `obj Car(Vehicle)`) for better alignment with common object-oriented programming languages.
- **`def` Keyword for Functions**: The `def` keyword is now used for traditional Python-like functions and methods, while `can` is reserved for object-spatial abilities.
- **`visitor` Keyword**: Introduced the `visitor` keyword to reference the walker context within nodes/edges, replacing the ambiguous use of `here` in such contexts. `here` is now used only in walker abilities to reference the current node/edge.
- **Lambda Syntax Update**: The lambda syntax has been updated from `with x: int can x;` to `lambda x: int: x * x;`, aligning it more closely with Python's lambda syntax.
- **Object-Spatial Arrow Notation Update**: Typed arrow notations `-:MyEdge:->` and `+:MyEdge:+>` are now `->:MyEdge:->` and `+>:MyEdge:+>` respectively, to avoid conflicts with Python-style list slicing.
- **Import `from` Syntax Update**: The syntax for importing specific modules from a package now uses curly braces (e.g., `import from utils { helper, math_utils }`) for improved clarity.
- **Auto-Resolved Imports**: Removed the need for explicit language annotations (`:py`, `:jac`) in import statements; the compiler now automatically resolves imports.
- **Permission API Renaming**: The `Jac.restrict` and `Jac.unrestrict` interfaces have been renamed to `Jac.perm_revoke` and `Jac.perm_grant` respectively, for better clarity on their actions.
- **Permission API Renaming**: The `Jac.restrict` and `Jac.unrestrict` interfaces have been renamed to `Jac.perm_revoke` and `Jac.perm_grant` respectively, for better clarity on their actions.




================================================================================
FILE: docs/communityhub/roadmap.md
================================================================================


# Jac and Jaseci Development Roadmap

# Jac (The Language)
* Jac JSX as drop in replacement for TSC with built in
* Best in class Type Checking
* Jac to LLVM IR for native compilation pipeline

# Jaseci (The Runtime)
* Self spawning in K8s enviornment
* In memory caching layer

# Jac and Jaseci Research
* Full Featured MTP and Ghost in the Shell
* UniIR for AI IR (Fx graphs to start)
* Future Data Access Predictor for Spatial Locality Optimizations




================================================================================
FILE: docs/index.md
================================================================================


# Welcome

This page redirects to the introduction.



================================================================================
FILE: docs/internals/contrib.md
================================================================================


# Contrib and Codebase Guide

## General Setup and Information

To get setup run
```bash
# Install black
python3 -m venv ~/.jacenv/
source ~/.jacenv/bin/activate
pip3 install pre-commit
pre-commit install
```

To understand our linting and mypy type checking have a look at our pre-commit actions. You can set up your enviornment accordingly. For help interpreting this if you need it, call upon our friend Mr. ChatGPT or one of his colleagues.

??? Grock "Our pre-commit process"
    ```yaml linenums="1"
    --8<-- ".pre-commit-config.yaml"
    ```

This is how we run checks on demand.

```bash
--8<-- "scripts/check.sh"
```

This is how we run our tests.

```bash
--8<-- "scripts/tests.sh"
```

## Run docs site locally

This is how we run the docs.

```bash
--8<-- "scripts/run_docs.sh"
```


## Build VSCode Extention

```bash
--8<-- "scripts/build_vsce.sh"
```


## Release Flow (for the empowered)

* Version bump jac, jac-cloud, byllm
  * Remember to version bump requirement of jaclang in jac-cloud and byllm
* Update release notes (unreleased becomes released)
* Push to main
* Go to GitHub, run `Release jaclang to PYPI` action manually
* After success
  * Run `Release jac-cloud to PYPI` action manually
  * Run `Release jac-byllm to PYPI` action manually
  * Run `RElease jac-mtllm to PYPI` action manually, for deprecated library
* If All success, W for you!!



================================================================================
FILE: docs/internals/internals.md
================================================================================


# Jaclang Internals

This document provides a comprehensive guide to the internal design and implementation of the Jaclang compiler and runtime stack. It's intended for developers who want to contribute to the Jaclang project or understand its architecture in depth.

## Architecture Overview

Jaclang is composed of two main components:

1. **Compiler**: Transforms Jac source code into Python bytecode through a series of passes
2. **Runtime**: Provides the execution environment for compiled Jac programs

The system follows a modular design that separates concerns between compilation and execution, allowing for flexibility and extensibility.

```mermaid
flowchart LR
    A[Jac Source] --> B[Compiler]
    B --> C[Bytecode]
    C --> D[Execution]
    D --> E[Runtime]
    E --> F[Results]

    style A fill:#2d3748,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style B fill:#3182ce,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style C fill:#3182ce,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style D fill:#38a169,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style E fill:#38a169,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style F fill:#2d3748,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
```

## Compiler Components

The compiler transforms Jac source code into Python bytecode through a series of passes. Each pass performs a specific transformation on the code.

### Compilation Pipeline

The compiler transforms Jac source code into Python bytecode through a series of passes:

```mermaid
flowchart TD
    A[Jac Source Code] --> B[Parsing]
    B --> C[Symbol Table Building]
    C --> D[Import Resolution]
    D --> E[Type Checking]
    E --> F[Python AST Generation]
    F --> G[Bytecode Generation]
    G --> H[Python Bytecode]

    style A fill:#2d3748,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style B fill:#3182ce,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style C fill:#3182ce,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style D fill:#3182ce,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style E fill:#3182ce,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style F fill:#3182ce,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style G fill:#3182ce,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style H fill:#2d3748,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
```

1. **Parsing**: Converts Jac source code into an Abstract Syntax Tree (AST)
2. **Symbol Table Building**: Creates symbol tables for scopes and resolves symbols
3. **Import Resolution**: Processes import statements and loads external modules
4. **Type Checking**: Performs type checking and inference
5. **Python AST Generation**: Converts Jac AST to Python AST
6. **Bytecode Generation**: Generates Python bytecode from the Python AST

### Key Compiler Components

#### JacProgram

`JacProgram` is the central component that orchestrates the compilation process. It maintains a collection of modules and manages the compilation pipeline.

```python
class JacProgram:
    """JacProgram to handle the Jac program-related functionalities."""

    def __init__(self, main_mod: Optional[uni.ProgramModule] = None) -> None:
        """Initialize the JacProgram object."""
        self.mod: uni.ProgramModule = main_mod if main_mod else uni.ProgramModule()
        self.last_imported: list[Module] = []
        self.py_raise_map: dict[str, str] = {}
        self.errors_had: list[Alert] = []
        self.warnings_had: list[Alert] = []
```

Key methods:
- `get_bytecode()`: Retrieves bytecode for a specific module
- `compile()`: Compiles a Jac file to an AST
- `compile_from_str()`: Compiles Jac code from a string
- `run_pass_schedule()`: Executes the compilation passes on a module
- `run_whole_program_schedule()`: Runs passes that require whole-program analysis

#### Unitree

The `unitree` module defines the AST node types used in the compilation process. The AST is a hierarchical representation of the program's structure.

Key classes:
- `UniNode`: Base class for all AST nodes
- `UniScopeNode`: Represents a scope with a symbol table
- `Module`: Represents a Jac module
- `Archetype`: Represents a Jac archetype (object, node, edge, walker)
- `Ability`: Represents a Jac ability (method)

#### Compiler Components Relationship

```mermaid
classDiagram
    class JacProgram {
        +ProgramModule mod
        +list[Module] last_imported
        +dict py_raise_map
        +list errors_had
        +list warnings_had
        +get_bytecode()
        +compile()
        +compile_from_str()
        +run_pass_schedule()
        +run_whole_program_schedule()
    }

    class UniNode {
        +UniNode parent
        +list[UniNode] kid
        +CodeGenTarget gen
        +CodeLocInfo loc
    }

    class Module {
        +str name
        +Source source
        +list body
        +bool stub_only
        +list impl_mod
        +list test_mod
        +list terminals
        +PyInfo py_info
    }

    class Transform {
        +ir_in
        +ir_out
        +list errors_had
        +list warnings_had
    }

    JacProgram --> Module : manages
    Module --|> UniNode : inherits
    Transform --> UniNode : transforms

    note for JacProgram "Orchestrates the compilation process"
    note for UniNode "Base class for all AST nodes"
    note for Module "Represents a Jac module"
    note for Transform "Base class for compiler passes"
```

#### Compiler Passes

Compiler passes are transformations applied to the AST. Each pass is responsible for a specific aspect of the compilation process.

```mermaid
flowchart LR
    A[JacParser] --> B[SymTabBuildPass]
    B --> C[JacImportPass]
    C --> D[JacTypeCheckPass]
    D --> E[PyastBuildPass]
    E --> F[PyBytecodeGenPass]

    style A fill:#3182ce,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style B fill:#3182ce,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style C fill:#3182ce,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style D fill:#3182ce,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style E fill:#3182ce,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style F fill:#3182ce,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
```

Main passes:
- `JacParser`: Parses Jac source code into an AST
- `SymTabBuildPass`: Builds symbol tables for scopes
- `JacImportPass`: Resolves import statements
- `JacTypeCheckPass`: Performs type checking
- `PyastBuildPass`: Converts Jac AST to Python AST
- `PyBytecodeGenPass`: Generates Python bytecode

## Runtime Components

The runtime system executes compiled Jac programs and provides the necessary infrastructure for Jac's features.

```mermaid
classDiagram
    class JacMachine {
        +load_module()
        +get_bytecode()
        +list_modules()
        +update_walker()
        +get()
    }

    class JacMachine {
        +dict loaded_modules
        +str base_path
        +str base_path_dir
        +JacProgram jac_program
        +bool interp_mode
        +ExecutionContext exec_ctx
    }

    class ExecutionContext {
        +JacMachine mach
        +Memory mem
        +list reports
        +Any custom
        +NodeAnchor system_root
        +NodeAnchor root
        +NodeAnchor entry_node
        +init_anchor()
        +set_entry_node()
        +close()
        +get_root()
    }

    JacMachine --> JacMachine : uses
    JacMachine --> ExecutionContext : contains
    JacMachine --> JacProgram : contains

    note for JacMachine "Core runtime component"
    note for JacMachine "Maintains runtime state"
    note for ExecutionContext "Execution environment"
```

### JacMachine

`JacMachine` is the core runtime component that manages the execution environment for Jac programs. It handles module loading, execution context, and provides the runtime API for Jac features.

```python
class JacMachine(
    JacClassReferences,
    JacAccessValidation,
    JacNode,
    JacEdge,
    JacWalker,
    JacBuiltin,
    JacCmd,
    JacBasics,
    JacUtils,
):
    """Jac Feature."""
```

Key responsibilities:
1. **Module Management**: Loads and manages Jac modules
2. **Context Management**: Maintains execution context for Jac programs
3. **Runtime API**: Provides the API for Jac features like node/edge operations, walker operations, etc.
4. **Dynamic Updates**: Enables runtime updates to components like walkers

### JacMachine

`JacMachine` maintains the state of the Jac machine during execution. It includes loaded modules, the execution context, and the Jac program.

```python
class JacMachine:
    """Jac Machine State."""

    def __init__(
        self,
        base_path: str = "",
        session: Optional[str] = None,
        root: Optional[str] = None,
        interp_mode: bool = False,
    ) -> None:
        """Initialize JacMachine."""
        self.loaded_modules: dict[str, types.ModuleType] = {}
        if not base_path:
            base_path = os.getcwd()
        # Ensure the base_path is a list rather than a string
        self.base_path = base_path
        self.base_path_dir = (
            os.path.dirname(base_path)
            if not os.path.isdir(base_path)
            else os.path.abspath(base_path)
        )
        self.jac_program: JacProgram = JacProgram()
        self.interp_mode = interp_mode
        self = ExecutionContext(session=session, root=root, mach=self)
```

### ExecutionContext

`ExecutionContext` represents the execution environment for a Jac program. It includes the memory, reports, and root nodes.

```python
class ExecutionContext:
    """Execution Context."""

    mach: JacMachine
    mem: Memory
    reports: list[Any]
    custom: Any = MISSING
    system_root: NodeAnchor
    root: NodeAnchor
    entry_node: NodeAnchor
```

## Memory Management

Jaclang uses a memory management system to store and retrieve objects during execution.

### Memory

The `Memory` class is a generic memory handler that stores objects by ID. It provides methods to find, set, and remove objects.

```python
@dataclass
class Memory(Generic[ID, TANCH]):
    """Generic Memory Handler."""

    __mem__: dict[ID, TANCH] = field(default_factory=dict)
    __gc__: set[TANCH] = field(default_factory=set)
```

### ShelfStorage

`ShelfStorage` extends `Memory` to provide persistent storage using Python's `shelve` module. It synchronizes memory with disk storage.

```python
@dataclass
class ShelfStorage(Memory[UUID, Anchor]):
    """Shelf Handler."""

    __shelf__: Shelf[Anchor] | None = None
```

## Archetypes and Anchors

Jaclang uses archetypes and anchors to represent objects in the runtime system.

```mermaid
classDiagram
    class Archetype {
        +list _jac_entry_funcs_
        +list _jac_exit_funcs_
        +Anchor __jac__
    }

    class NodeArchetype {
        +__jac_base__: bool
    }

    class EdgeArchetype {
        +__jac_base__: bool
    }

    class WalkerArchetype {
        +__jac_base__: bool
    }

    class ObjectArchetype {
        +__jac_base__: bool
    }

    class Anchor {
        +Archetype archetype
        +UUID id
        +UUID root
        +Permission access
        +bool persistent
        +int hash
        +is_populated()
        +make_stub()
        +populate()
    }

    class NodeAnchor {
        +NodeArchetype archetype
        +list edges
    }

    class EdgeAnchor {
        +EdgeArchetype archetype
        +NodeAnchor source
        +NodeAnchor target
        +bool is_undirected
    }

    class WalkerAnchor {
        +WalkerArchetype archetype
        +list path
        +list next
        +list ignores
        +bool disengaged
    }

    Archetype <|-- NodeArchetype : inherits
    Archetype <|-- EdgeArchetype : inherits
    Archetype <|-- WalkerArchetype : inherits
    Archetype <|-- ObjectArchetype : inherits

    Anchor <|-- NodeAnchor : inherits
    Anchor <|-- EdgeAnchor : inherits
    Anchor <|-- WalkerAnchor : inherits

    Archetype --> Anchor : has
    NodeArchetype --> NodeAnchor : has
    EdgeArchetype --> EdgeAnchor : has
    WalkerArchetype --> WalkerAnchor : has

    NodeAnchor --> EdgeAnchor : contains
    EdgeAnchor --> NodeAnchor : references
```

### Archetype

`Archetype` is the base class for all Jac objects. It defines the common interface for all archetypes.

```python
@dataclass(eq=False, repr=False, kw_only=True)
class Archetype:
    """Archetype Protocol."""

    _jac_entry_funcs_: ClassVar[list[DataSpatialFunction]] = []
    _jac_exit_funcs_: ClassVar[list[DataSpatialFunction]] = []

    @cached_property
    def __jac__(self) -> Anchor:
        """Create default anchor."""
        return Anchor(archetype=self)
```

Specialized archetypes:
- `NodeArchetype`: Represents a node in a graph
- `EdgeArchetype`: Represents an edge in a graph
- `WalkerArchetype`: Represents a walker that traverses a graph
- `ObjectArchetype`: Represents a generic object

### Anchor

`Anchor` is a wrapper around an archetype that provides additional metadata and functionality.

```python
@dataclass(eq=False, repr=False, kw_only=True)
class Anchor:
    """Object Anchor."""

    archetype: Archetype
    id: UUID = field(default_factory=uuid4)
    root: Optional[UUID] = None
    access: Permission = field(default_factory=Permission)
    persistent: bool = False
    hash: int = 0
```

Specialized anchors:
- `NodeAnchor`: Wraps a `NodeArchetype` and maintains a list of connected edges
- `EdgeAnchor`: Wraps an `EdgeArchetype` and maintains references to source and target nodes
- `WalkerAnchor`: Wraps a `WalkerArchetype` and maintains walker state

## Module System

Jaclang has a sophisticated module system that handles importing Jac and Python modules.

```mermaid
flowchart TD
    A[Import Request] --> B{Is Python Module?}
    B -->|Yes| C[PythonImporter]
    B -->|No| D[JacImporter]
    C --> E[importlib.import_module]
    D --> F[Resolve Module Path]
    F --> G[Create Module]
    G --> H[Compile Module]
    H --> I[Execute Module]
    I --> J[Update Module Registry]
    E --> J

    style A fill:#2d3748,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style B fill:#c53030,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style C fill:#3182ce,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style D fill:#3182ce,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style E fill:#38a169,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style F fill:#38a169,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style G fill:#38a169,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style H fill:#38a169,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style I fill:#38a169,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style J fill:#2d3748,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
```

```mermaid
classDiagram
    class Importer {
        +JacMachine jac_machine
        +ImportReturn result
        +run_import()
    }

    class JacImporter {
        +get_sys_mod_name()
        +handle_directory()
        +create_jac_py_module()
        +run_import()
    }

    class PythonImporter {
        +run_import()
    }

    class ImportPathSpec {
        +str target
        +str base_path
        +bool absorb
        +str mdl_alias
        +str override_name
        +str language
        +dict items
        +get_caller_dir()
    }

    class ImportReturn {
        +types.ModuleType ret_mod
        +list ret_items
        +Importer importer
        +process_items()
        +load_jac_mod_as_item()
    }

    Importer <|-- JacImporter : inherits
    Importer <|-- PythonImporter : inherits
    Importer --> ImportPathSpec : uses
    Importer --> ImportReturn : returns
```

### Importers

The module system uses importers to load modules:

- `JacImporter`: Loads Jac modules
- `PythonImporter`: Loads Python modules

```python
class Importer:
    """Abstract base class for all importers."""

    def __init__(self, jac_machine: JacMachine) -> None:
        """Initialize the Importer object."""
        self.jac_machine = jac_machine
        self.result: Optional[ImportReturn] = None

    def run_import(self, spec: ImportPathSpec) -> ImportReturn:
        """Run the import process."""
        raise NotImplementedError
```

### Import Process

The import process involves:

1. Resolving the module path
2. Loading the module
3. Compiling the module (for Jac modules)
4. Executing the module
5. Updating the module registry

## Dynamic Updates

One of the most powerful features of `JacMachine` is the ability to dynamically update components at runtime, particularly walkers.

```mermaid
sequenceDiagram
    participant User
    participant JacMachine
    participant JacImporter
    participant Module
    participant Walker

    User->>JacMachine: update_walker(module_name, items)
    JacMachine->>JacMachine: Check if module exists
    JacMachine->>JacImporter: Create importer
    JacMachine->>JacImporter: Create ImportPathSpec
    JacImporter->>JacImporter: run_import(spec, reload=True)
    JacImporter->>Module: Load updated module
    JacMachine->>Module: Get old module
    JacMachine->>Module: Update specific items
    Module->>Walker: Replace walker implementation
    JacMachine-->>User: Return updated items

    note over JacMachine,Walker: Only the specified walkers are updated, not the entire module
```

### Updating Walkers

Walkers can be updated during runtime without reloading the entire module. This is useful for debugging, live code updates, and reactive programming.

```python
@staticmethod
def update_walker(
    mach: JacMachine,
    module_name: str,
    items: Optional[dict[str, Union[str, Optional[str]]]],
) -> tuple[types.ModuleType, ...]:
    """Reimport the module."""
    from .importer import JacImporter, ImportPathSpec

    if module_name in mach.loaded_modules:
        try:
            old_module = mach.loaded_modules[module_name]
            importer = JacImporter(mach)
            spec = ImportPathSpec(
                target=module_name,
                base_path=mach.base_path,
                absorb=False,
                mdl_alias=None,
                override_name=None,
                lng="jac",
                items=items,
            )
            import_result = importer.run_import(spec, reload=True)
            ret_items = []
            if items:
                for item_name in items:
                    if hasattr(old_module, item_name):
                        new_attr = getattr(import_result.ret_mod, item_name, None)
                        if new_attr:
                            ret_items.append(new_attr)
                            setattr(
                                old_module,
                                item_name,
                                new_attr,
                            )
            return (old_module,) if not items else tuple(ret_items)
        except Exception as e:
            logger.error(f"Failed to update module {module_name}: {e}")
    else:
        logger.warning(f"Module {module_name} not found in loaded modules.")
    return ()
```

## Access Control

Jaclang has a sophisticated access control system that manages permissions for objects.

```mermaid
classDiagram
    class AccessLevel {
        <<enumeration>>
        NO_ACCESS
        READ
        CONNECT
        WRITE
        +cast()
    }

    class Access {
        +dict anchors
        +check()
    }

    class Permission {
        +AccessLevel all
        +Access roots
    }

    class Anchor {
        +Permission access
    }

    Permission --> AccessLevel : uses
    Permission --> Access : contains
    Anchor --> Permission : has

    note for AccessLevel "Defines access levels"
    note for Access "Maps anchors to access levels"
    note for Permission "Defines permissions for an anchor"
```

```mermaid
flowchart TD
    A[Access Request] --> B{Check Access Level}
    B --> C{Is System Root?}
    C -->|Yes| D[Grant WRITE Access]
    C -->|No| E{Is Same Root?}
    E -->|Yes| D
    E -->|No| F{Is Target Anchor?}
    F -->|Yes| D
    F -->|No| G{Check access.all}
    G --> H{Check target root's access.all}
    H --> I{Check target root's allowed roots}
    I --> J{Check target's allowed roots}
    J --> K[Return Final Access Level]

    style A fill:#2d3748,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style B fill:#c53030,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style C fill:#c53030,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style D fill:#38a169,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style E fill:#c53030,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style F fill:#c53030,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style G fill:#c53030,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style H fill:#c53030,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style I fill:#c53030,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style J fill:#c53030,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style K fill:#2d3748,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
```

### Permission

The `Permission` class defines access levels for objects:

```python
@dataclass
class Permission:
    """Anchor Access Handler."""

    all: AccessLevel = AccessLevel.NO_ACCESS
    roots: Access = field(default_factory=Access)
```

### AccessLevel

`AccessLevel` defines the levels of access:

```python
class AccessLevel(IntEnum):
    """Access level enum."""

    NO_ACCESS = -1
    READ = 0
    CONNECT = 1
    WRITE = 2
```

## Contributing to Jaclang

### Understanding the Codebase

The Jaclang codebase is organized into several key directories:

```mermaid
graph TD
    A[jaclang] --> B[compiler]
    A --> C[runtimelib]
    A --> D[utils]
    A --> E[cli]
    A --> F[langserve]

    B --> B1[passes]
    B --> B2[unitree.py]
    B --> B3[program.py]
    B --> B4[parser.py]

    C --> C1[archetype.py]
    C --> C2[machine.py]
    C --> C3[memory.py]
    C --> C4[importer.py]

    style A fill:#2d3748,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style B fill:#3182ce,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style C fill:#38a169,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style D fill:#805ad5,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style E fill:#805ad5,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style F fill:#805ad5,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style B1 fill:#3182ce,stroke:#e2e8f0,stroke-width:1px,color:#e2e8f0
    style B2 fill:#3182ce,stroke:#e2e8f0,stroke-width:1px,color:#e2e8f0
    style B3 fill:#3182ce,stroke:#e2e8f0,stroke-width:1px,color:#e2e8f0
    style B4 fill:#3182ce,stroke:#e2e8f0,stroke-width:1px,color:#e2e8f0
    style C1 fill:#38a169,stroke:#e2e8f0,stroke-width:1px,color:#e2e8f0
    style C2 fill:#38a169,stroke:#e2e8f0,stroke-width:1px,color:#e2e8f0
    style C3 fill:#38a169,stroke:#e2e8f0,stroke-width:1px,color:#e2e8f0
    style C4 fill:#38a169,stroke:#e2e8f0,stroke-width:1px,color:#e2e8f0
```

- `jaclang/compiler`: Contains the compiler components
- `jaclang/runtimelib`: Contains the runtime components
- `jaclang/utils`: Contains utility functions
- `jaclang/cli`: Contains the command-line interface
- `jaclang/langserve`: Contains the language server components

### Development Workflow

```mermaid
flowchart LR
    A[Setup] --> B[Testing]
    B --> C[Implementation]
    C --> D[Documentation]
    D --> E[Pull Request]
    E --> F[Code Review]
    F --> G[Merge]

    style A fill:#2d3748,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style B fill:#3182ce,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style C fill:#3182ce,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style D fill:#3182ce,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style E fill:#38a169,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style F fill:#38a169,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style G fill:#38a169,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
```

1. **Setup**: Clone the repository and install dependencies
2. **Testing**: Run tests to ensure your changes don't break existing functionality
3. **Implementation**: Make your changes following the project's coding standards
4. **Documentation**: Update documentation to reflect your changes
5. **Pull Request**: Submit a pull request with your changes
6. **Code Review**: Address feedback from reviewers
7. **Merge**: Once approved, your changes will be merged into the main codebase

### Best Practices

- Follow the existing code style and architecture
- Write tests for new functionality
- Document your code with docstrings
- Keep changes focused and minimal
- Discuss major changes with the community before implementation

## Conclusion

This document provides an overview of the Jaclang internals. For more detailed information, refer to the source code and other documentation. If you have questions or need help, feel free to reach out to the Jaclang community.




================================================================================
FILE: docs/internals/jac_plugins.md
================================================================================


# **Jac Plugins**

## What is a JAC Plugin?
JAC is a powerful language that can be extended with plugins. JAC plugins are Python packages that extend the functionality of JAC. You can create custom commands, functions, and modules that can be used in JAC scripts.

> **TLDR**
> Checkout the examples in the [JAC Plugin Examples](https://github.com/Jaseci-Labs/jaclang/tree/main/examples/plugins) directory.

## How to Create a JAC Plugin?

Let's create a simple plugin that will add a new command to Jac CLI. The command will be called `hello` and will print `Hello, World!` to the console.

**Step 1: Create a new directory for your plugin.** I will call mine `my_plugin`.
```bash
mkdir my_plugin
cd my_plugin
```

**Step 2: Install necessary dependencies.** (It is recommended to use a virtual environment)
```bash
pip install poetry
```

**Step 3: Create a new Python package.**
```bash
poetry init
# Fill in the details
# for compatible python version, use 3.12
```

**Step 4: Add necessary dependencies.**
```bash
poetry add jaclang
poetry add pytest --group dev
```

**Step 5: Create the necessary folders and files.**
```bash
mkdir my_plugin # Use the name of your plugin. This is where the plugin code will go.
touch my_plugin/__init__.py
touch my_plugin/plugin.py
```

**Step 6: Link your plugin to Jaclang.**
Open the `pyproject.toml` file and add the following lines before `[build-system]`
```toml
[tool.poetry.plugins."jac"]
"my_plugin" = "my_plugin.plugin:JacCmd"
```

**Step 7: Implement the plugin.**
Open `my_plugin/plugin.py` and add the following code.
```python
from jaclang.cli.cmdreg import cmd_registry
from jaclang.runtimelib.default import hookimpl

class JacCmd:
    """Jac CLI."""

    @staticmethod
    @hookimpl
    def create_cmd() -> None:
        """Creating Jac CLI cmds."""

        @cmd_registry.register
        def hello():
            """Prints Hello, World!"""
            print("Hello, World!")
```

**Step 8: Install the plugin.**
```bash
poetry install
```

**Step 9: Run the plugin.**
```bash
jac hello
```

You should see `Hello, World!` printed to the console.

That's it! You have created your first JAC plugin. You can now extend JAC with your own custom commands.

### Next Steps
- Now you can publish your plugin to PyPI and share it with the world. Follow the [Publishing Python Packages](https://packaging.python.org/tutorials/packaging-projects/) guide to learn how to publish your plugin.
- Don't forget to create a nice README and add some examples to help users understand how to use your plugin.

> **Note:**
> For more examples, check out the [JAC Plugin Examples](https://github.com/Jaseci-Labs/jaclang/tree/main/examples/plugins)

>Check out the [byLLM Plugin](https://github.com/jaseci/jac-byllm) for a more complex example. Where we have created a plugin that adds LLM functionality to JAC.

If you have any questions, feel free to ask in the [Community Channel]().



================================================================================
FILE: docs/internals/planning_specs/error_system.md
================================================================================


# Jac Compiler Error Handling Subsystem

## 1. Introduction

This document outlines the design for a new error handling subsystem for the Jac compiler. The goal is to create a more robust, maintainable, and developer-friendly system for reporting, managing, and diagnosing errors and warnings encountered during the various compilation phases (parsing, semantic analysis, code generation, etc.).

The key objectives are:
-   **Centralization**: A single source of truth for all error and warning definitions (codes, message templates).
-   **Clarity**: Consistent and informative error messages for the user.
-   **Maintainability**: Easier to add, modify, and track error types.
-   **Extensibility**: Ability to add richer diagnostic information (e.g., fix-it hints) in the future.
-   **Tooling Support**: Facilitate better integration with IDEs and other development tools.

## 2. Current System Overview

The existing error handling mechanism relies on an `Alert` class (`jaclang.compiler.passes.transform.Alert`).

-   Each `Transform` (base class for compiler passes) maintains its own `errors_had` and `warnings_had` lists.
-   Passes report errors using `log_error(message_string, ...)` and `log_warning(message_string, ...)`.
-   These methods create `Alert` objects, storing the raw message string, code location (`CodeLocInfo`), and the originating pass type.
-   Alerts from individual passes are also aggregated into global `errors_had` and `warnings_had` lists in the `JacProgram` instance.

While functional, this system has limitations:
-   Error messages are decentralized (defined as raw strings within each pass).
-   No standardized error codes, making it harder to categorize or programmatically handle specific errors.
-   Less flexibility for internationalization or complex message formatting.

## 3. Proposed Design

The new design introduces a centralized error registry, standardized error codes, and an enhanced error reporting structure.

### 3.1. Error Code Enumeration and Registry

We will define a central enumeration for all possible compiler errors and warnings. Each member of this enumeration will represent a unique error type.

**Location:** `jaclang.compiler.errors.JacErrorCode.py` (New File)

```python
# jaclang.compiler.errors.JacErrorCode.py
from enum import Enum, auto

class JacErrorCode(Enum):
    # Lexer/Parser Errors (L000-L999)
    UNEXPECTED_TOKEN = auto()                       # msg: "Unexpected token '{token_value}' of type {token_type}, expected {expected_tokens}."
    UNTERMINATED_STRING_LITERAL = auto()            # msg: "Unterminated string literal."
    INVALID_ESCAPE_SEQUENCE = auto()                # msg: "Invalid escape sequence '\\{char}' in string literal."
    MALFORMED_NUMERIC_LITERAL = auto()              # msg: "Malformed numeric literal: {details}."
    SYNTAX_ERROR_NEAR_TOKEN = auto()                # msg: "Syntax error near '{token}'."
    MISSING_EXPECTED_TOKEN = auto()                 # msg: "Missing expected token: {expected_token}."
    # ... more parser errors

    # Semantic Errors (S000-S999)
    DUPLICATE_SYMBOL_DECL = auto()                  # msg: "Symbol '{name}' already declared in this scope at {original_loc}."
    SYMBOL_NOT_FOUND = auto()                       # msg: "Symbol '{name}' not found in the current scope or accessible scopes."
    TYPE_MISMATCH = auto()                          # msg: "Type mismatch: Expected type '{expected_type}', but got '{actual_type}' for '{construct_name}'."
    INCOMPATIBLE_OPERANDS = auto()                  # msg: "Incompatible operands for operator '{operator}': '{left_type}' and '{right_type}'."
    ASSIGN_TO_READ_ONLY = auto()                    # msg: "Cannot assign to read-only symbol '{name}'."
    ACCESS_TO_PRIVATE_MEMBER = auto()               # msg: "Cannot access private member '{member_name}' of '{owner_name}' from this context."
    ACCESS_TO_PROTECTED_MEMBER = auto()             # msg: "Cannot access protected member '{member_name}' of '{owner_name}' from this context."
    NO_SUCH_ABILITY = auto()                        # msg: "Object of type '{type_name}' does not have ability '{ability_name}'."
    INCORRECT_ARGUMENT_COUNT = auto()               # msg: "Function/Ability '{callable_name}' expects {expected_count} arguments, but got {actual_count}."
    ARGUMENT_TYPE_MISMATCH = auto()                 # msg: "Argument '{arg_name}' of '{callable_name}' expects type '{expected_type}', but got '{actual_type}'."
    IMPORT_ERROR = auto()                           # msg: "Could not import module '{module_name}': {reason}."
    CIRCULAR_IMPORT = auto()                        # msg: "Circular import detected involving module '{module_name}'."
    # ... more semantic errors

    # Code Generation Errors (C000-C999)
    CODEGEN_UNSUPPORTED_FEATURE = auto()            # msg: "Feature '{feature_name}' is not yet supported by the code generator."
    BYTECODE_GENERATION_FAILED = auto()             # msg: "Bytecode generation failed for '{construct_name}': {details}."
    # ... more codegen errors

    # Internal Compiler Errors (I000-I999)
    ICE_UNEXPECTED_NODE_TYPE = auto()               # msg: "Internal Compiler Error: Unexpected AST node type '{node_type}' in pass '{pass_name}'."
    ICE_MISSING_SYMBOL_INFO = auto()                # msg: "Internal Compiler Error: Missing symbol information for '{name}'."
    # ... more internal errors

    # Warnings (W000-W999)
    UNUSED_VARIABLE = auto()                        # msg: "Variable '{name}' is declared but never used."
    UNUSED_IMPORT = auto()                          # msg: "Import '{module_name}' is unused."
    POTENTIAL_NULL_DEREFERENCE = auto()             # msg: "Potential null dereference of '{variable_name}'."
    DEPRECATED_FEATURE_USED = auto()                # msg: "Feature '{feature_name}' is deprecated and will be removed in a future version. {suggestion}"
    # ... more warnings

    def __str__(self) -> str:
        return self.name
```

**Location:** `jaclang.compiler.errors.JacErrorStrings.py` (New File)

```python
# jaclang.compiler.errors.JacErrorStrings.py
from jaclang.compiler.errors.JacErrorCode import JacErrorCode

# Using a dictionary to map error codes to message templates
# This allows for easier updates and potential future localization
ERROR_MESSAGE_TEMPLATES: dict[JacErrorCode, str] = {
    # Lexer/Parser Errors
    JacErrorCode.UNEXPECTED_TOKEN: "Unexpected token '{token_value}' of type {token_type}, expected {expected_tokens}.",
    JacErrorCode.UNTERMINATED_STRING_LITERAL: "Unterminated string literal.",
    JacErrorCode.INVALID_ESCAPE_SEQUENCE: "Invalid escape sequence '\\\\{char}' in string literal.",
    JacErrorCode.MALFORMED_NUMERIC_LITERAL: "Malformed numeric literal: {details}.",
    JacErrorCode.SYNTAX_ERROR_NEAR_TOKEN: "Syntax error near '{token}'.",
    JacErrorCode.MISSING_EXPECTED_TOKEN: "Missing expected token: {expected_token}.",

    # Semantic Errors
    JacErrorCode.DUPLICATE_SYMBOL_DECL: "Symbol '{name}' already declared in this scope at {original_loc}.",
    JacErrorCode.SYMBOL_NOT_FOUND: "Symbol '{name}' not found in the current scope or accessible scopes.",
    JacErrorCode.TYPE_MISMATCH: "Type mismatch: Expected type '{expected_type}', but got '{actual_type}' for '{construct_name}'.",
    JacErrorCode.INCOMPATIBLE_OPERANDS: "Incompatible operands for operator '{operator}': '{left_type}' and '{right_type}'.",
    JacErrorCode.ASSIGN_TO_READ_ONLY: "Cannot assign to read-only symbol '{name}'.",
    JacErrorCode.ACCESS_TO_PRIVATE_MEMBER: "Cannot access private member '{member_name}' of '{owner_name}' from this context.",
    JacErrorCode.ACCESS_TO_PROTECTED_MEMBER: "Cannot access protected member '{member_name}' of '{owner_name}' from this context.",
    JacErrorCode.NO_SUCH_ABILITY: "Object of type '{type_name}' does not have ability '{ability_name}'.",
    JacErrorCode.INCORRECT_ARGUMENT_COUNT: "Function/Ability '{callable_name}' expects {expected_count} arguments, but got {actual_count}.",
    JacErrorCode.ARGUMENT_TYPE_MISMATCH: "Argument '{arg_name}' of '{callable_name}' expects type '{expected_type}', but got '{actual_type}'.",
    JacErrorCode.IMPORT_ERROR: "Could not import module '{module_name}': {reason}.",
    JacErrorCode.CIRCULAR_IMPORT: "Circular import detected involving module '{module_name}'.",

    # Code Generation Errors
    JacErrorCode.CODEGEN_UNSUPPORTED_FEATURE: "Feature '{feature_name}' is not yet supported by the code generator.",
    JacErrorCode.BYTECODE_GENERATION_FAILED: "Bytecode generation failed for '{construct_name}': {details}.",

    # Internal Compiler Errors
    JacErrorCode.ICE_UNEXPECTED_NODE_TYPE: "Internal Compiler Error: Unexpected AST node type '{node_type}' in pass '{pass_name}'.",
    JacErrorCode.ICE_MISSING_SYMBOL_INFO: "Internal Compiler Error: Missing symbol information for '{name}'.",

    # Warnings
    JacErrorCode.UNUSED_VARIABLE: "Variable '{name}' is declared but never used.",
    JacErrorCode.UNUSED_IMPORT: "Import '{module_name}' is unused.",
    JacErrorCode.POTENTIAL_NULL_DEREFERENCE: "Potential null dereference of '{variable_name}'.",
    JacErrorCode.DEPRECATED_FEATURE_USED: "Feature '{feature_name}' is deprecated and will be removed in a future version. {suggestion}",
}
```

### 3.2. Enhanced Alert Structure

The `Alert` class will be modified (or a new class, e.g., `JacAlert`, will be created) to include the error code and a dictionary of contextual arguments for message formatting.

**Location:** `jaclang.compiler.passes.transform.py` (Modify existing `Alert`)

```python
# jaclang.compiler.passes.transform.py (Modified Alert class)
# ... (other imports)
from jaclang.compiler.errors.JacErrorCode import JacErrorCode
from jaclang.compiler.errors.JacErrorStrings import ERROR_MESSAGE_TEMPLATES

# ...

class Alert:
    """Alert interface for compiler errors and warnings."""

    def __init__(
        self,
        code: JacErrorCode,
        loc: CodeLocInfo,
        from_pass: Type[Transform],
        args: Optional[dict[str, Any]] = None,
    ) -> None:
        """Initialize alert."""
        self.code: JacErrorCode = code
        self.loc: CodeLocInfo = loc
        self.from_pass: Type[Transform] = from_pass
        self.args: dict[str, Any] = args if args else {}
        self.msg: str = self._format_message()

    def _format_message(self) -> str:
        """Format the message using the template and arguments."""
        template = ERROR_MESSAGE_TEMPLATES.get(self.code)
        if not template:
            return f"Internal Compiler Error: No message template for error code {self.code.name}"
        try:
            return template.format(**self.args)
        except KeyError as e:
            return f"Internal Compiler Error: Missing argument {e} for error {self.code.name} in template: '{template}'"

    # __str__, __repr__, as_log, pretty_print methods remain largely the same,
    # but will use self.msg (the formatted message) instead of an initial raw message.
    # Example modification for __str__
    def __str__(self) -> str:
        """Return string representation of alert."""
        return (
            f"[{self.code.name}] {self.loc.mod_path}, line {self.loc.first_line},"
            f" col {self.loc.col_start}: {self.msg}"
        )

    def as_log(self) -> str:
        """Return the alert as a single line log."""
        file_path: str = self.loc.mod_path
        if file_path == "":
            # There are error messages without file references.
            return f"[{self.code.name}] {self.msg}"

        line: int = self.loc.first_line
        column: int = self.loc.col_start
        return f"{file_path}:{line}:{column}: [{self.code.name}] {self.msg}"

    def pretty_print(self) -> str:
        """Pretty prints the Alert to show the alert with source location."""
        pretty_dump = pretty_print_source_location(
            self.loc.mod_path,
            self.loc.orig_src.code, # Assumes orig_src is available on CodeLocInfo
            self.loc.first_line,
            self.loc.pos_start,
            self.loc.pos_end,
        )
        if pretty_dump != "":
            pretty_dump = "\\n" + pretty_dump
        return self.as_log() + pretty_dump

# ... (rest of Transform class)
```

### 3.3. Reporting Errors/Warnings in Passes

Compiler passes will use the new system to report errors:

```python
# Example usage within a Transform subclass
# from jaclang.compiler.errors.JacErrorCode import JacErrorCode

# ... inside a pass method ...
# self.log_error(
#     JacErrorCode.SYMBOL_NOT_FOUND,
#     args={"name": "my_var"},
#     node_override=current_ast_node  # Optional: if different from self.cur_node
# )
#
# self.log_warning(
#     JacErrorCode.UNUSED_VARIABLE,
#     args={"name": "temp_var"},
#     node_override=variable_declaration_node
# )
```

The `log_error` and `log_warning` methods in `Transform` will be updated:

```python
# jaclang.compiler.passes.transform.py (Modified Transform class methods)

# ...
    def log_error(
        self,
        code: JacErrorCode,
        args: Optional[dict[str, Any]] = None,
        node_override: Optional[UniNode] = None,
    ) -> None:
        """Pass Error."""
        alrt = Alert(
            code,
            self.cur_node.loc if not node_override else node_override.loc,
            self.__class__,
            args,
        )
        self.errors_had.append(alrt)
        self.prog.errors_had.append(alrt) # JacProgram accumulates these
        self.logger.error(alrt.as_log())

    def log_warning(
        self,
        code: JacErrorCode,
        args: Optional[dict[str, Any]] = None,
        node_override: Optional[UniNode] = None,
    ) -> None:
        """Pass Warning."""
        alrt = Alert(
            code,
            self.cur_node.loc if not node_override else node_override.loc,
            self.__class__,
            args,
        )
        self.warnings_had.append(alrt)
        self.prog.warnings_had.append(alrt) # JacProgram accumulates these
        self.logger.warning(alrt.as_log())
# ...
```

### 3.4. Mermaid Diagrams

#### 3.4.1. Error Information Structure (Class Diagram)

```mermaid
classDiagram
    class JacErrorCode {
        <<enumeration>>
        UNEXPECTED_TOKEN
        DUPLICATE_SYMBOL_DECL
        SYMBOL_NOT_FOUND
        TYPE_MISMATCH
        UNUSED_VARIABLE
        # ... other codes
    }

    class ERROR_MESSAGE_TEMPLATES {
        <<dictionary>>
        JacErrorCode: str_template
    }

    class Alert {
        +JacErrorCode code
        +CodeLocInfo loc
        +Type[Transform] from_pass
        +dict~str, Any~ args
        +str msg  // Formatted message
        +__init__(code, loc, from_pass, args)
        -_format_message() str
        +as_log() str
        +pretty_print() str
    }

    class CodeLocInfo {
        +str mod_path
        +int first_line
        +int col_start
        # ... other location details (pos_start, pos_end, orig_src)
    }

    JacErrorCode <--o Alert : has a
    ERROR_MESSAGE_TEMPLATES ..> Alert : used by
    CodeLocInfo <--o Alert : has a
```

#### 3.4.2. Error Reporting Workflow (Sequence Diagram)

```mermaid
sequenceDiagram
    participant Pass as CompilerPass
    participant TransformBase as Transform (Base Class)
    participant AlertClass as Alert
    participant ErrorRegistry as JacErrorCode / ErrorStrings
    participant JacProgramInstance as JacProgram

    Pass->>TransformBase: log_error(JacErrorCode.SYMBOL_NOT_FOUND, args={"name":"x"}, node)
    TransformBase->>AlertClass: create Alert(code, loc, self.__class__, args)
    AlertClass->>ErrorRegistry: get_template(JacErrorCode.SYMBOL_NOT_FOUND)
    ErrorRegistry-->>AlertClass: return "Symbol '{name}' not found..."
    AlertClass-->>TransformBase: return formatted_alert_obj
    TransformBase->>TransformBase: self.errors_had.append(formatted_alert_obj)
    TransformBase->>JacProgramInstance: self.prog.errors_had.append(formatted_alert_obj)
    TransformBase->>Logging: self.logger.error(formatted_alert_obj.as_log())
```

#### 3.4.3. Component Interaction (Component Diagram)

```mermaid
graph TD
    UserCode[Jac Source Code] --> CompilerNode[Jac Compiler]

    subgraph Compiler
        Input --> JacParser[Parser / Lexer]
        JacParser --> AST[Abstract Syntax Tree]
        AST --> SemanticPasses[Semantic Analysis Passes]
        SemanticPasses --> IR[Intermediate Representation]
        IR --> CodeGenPasses[Code Generation Passes]
        CodeGenPasses --> Output[Bytecode / Other Output]

        JacParser -- reports to --> ErrorSubsystem
        SemanticPasses -- reports to --> ErrorSubsystem
        CodeGenPasses -- reports to --> ErrorSubsystem

        subgraph ErrorSubsystem [Error Handling Subsystem]
            ES_Alert[Alert Class]
            ES_Codes[JacErrorCode Enum]
            ES_Strings[Error Message Templates]
            ES_Reporting[Reporting Logic in Transform]
        end

        ErrorSubsystem --> JacProgram["JacProgram (Error Aggregation)"]
        JacProgram --> UserOutput[User-facing Error/Warning Display]
    end

    ES_Codes -->|defines keys for| ES_Strings
    ES_Strings -->|provides templates to| ES_Alert
    ES_Codes -->|provides codes to| ES_Alert
    ES_Reporting -->|creates| ES_Alert
```

## 4. Integration with Compiler Passes

-   All existing compiler passes (subclasses of `Transform`) will need to be updated to use the new `log_error` and `log_warning` signatures (i.e., passing `JacErrorCode` and `args` dictionary instead of a raw string).
-   The `JacProgram` class will continue to aggregate `Alert` objects in its `errors_had` and `warnings_had` lists. No major changes are expected here, as it already stores `Alert` objects.
-   The `CodeLocInfo` object, which is part of `UniNode.loc`, must reliably provide `orig_src.code` for the `pretty_print` functionality to work correctly. This should be ensured during AST construction and transformation.

## 5. Benefits of the New System

-   **Standardization**: Error codes provide a clear, unambiguous way to identify specific issues.
-   **Maintainability**: Error messages are centrally managed, making them easier to update, correct, or translate. Adding new errors is a structured process.
-   **Improved Diagnostics**: Formatted messages with contextual arguments can provide more precise and helpful information to users. Error codes can be looked up in documentation.
-   **Reduced Redundancy**: Eliminates scattered string literals for error messages across the codebase.
-   **Testability**: Easier to write tests that check for specific error codes rather than matching fragile message strings.
-   **Foundation for Advanced Features**: Paves the way for features like:
    -   More detailed error reports (e.g., with "fix-it" suggestions).
    -   Selective error suppression or promotion (e.g., treating certain warnings as errors).
    -   Better IDE integration for displaying errors.

## 6. Future Enhancements (Optional)

-   **Error Recovery**: Implement mechanisms for certain passes (especially the parser) to attempt recovery after an error to report multiple issues in one compilation run.
-   **Structured Diagnostic Information**: Extend `Alert` or `args` to carry more structured diagnostic data beyond simple string placeholders.
-   **Localization**: The centralized string templates make it easier to add support for multiple languages for error messages.
-   **Documentation Links**: Error messages could include URLs pointing to detailed explanations or examples for specific error codes.
-   **Fix-it Hints**: Provide concrete suggestions or code snippets to help users fix errors.
-   **Severity Levels**: Introduce more granular severity levels beyond just error/warning if needed.

This design provides a solid foundation for a more professional and manageable error handling system within the Jac compiler.



================================================================================
FILE: docs/internals/planning_specs/formatter_system.md
================================================================================


# Refactoring Your Formatter to a Prettier-Style Architecture

This document outlines a comprehensive plan for incrementally refactoring your current AST-based code formatter to a more maintainable, Prettier-style architecture. This approach preserves what works in your current implementation while introducing key architectural improvements that will make the formatter more robust, extensible, and easier to maintain.

## Table of Contents

- [Overview of Prettier's Architecture](#overview-of-prettiers-architecture)
- [Incremental Refactoring Steps](#incremental-refactoring-steps)
  - [1. Create a Three-Phase Pipeline Architecture](#1-create-a-three-phase-pipeline-architecture)
  - [2. Implement a Doc Builder Abstraction](#2-implement-a-doc-builder-abstraction)
  - [3. Refactor AST Traversal to Build Doc IR](#3-refactor-ast-traversal-to-build-doc-ir)
  - [4. Implement a Separate Printer](#4-implement-a-separate-printer)
  - [5. Decouple Comment Handling](#5-decouple-comment-handling)
  - [6. Refactor Formatting Rules](#6-refactor-formatting-rules)
  - [7. Implement Configurable Options](#7-implement-configurable-options)
  - [8. Refactor Specific Node Types Incrementally](#8-refactor-specific-node-types-incrementally)
  - [9. Implement Line Break and Indentation Logic](#9-implement-line-break-and-indentation-logic)
  - [10. Add Tests for Each Phase](#10-add-tests-for-each-phase)
- [Challenges and Considerations](#challenges-and-considerations)
- [Conclusion](#conclusion)

## Overview of Prettier's Architecture

Prettier's architecture stands out for its clean separation of concerns and its approach to formatting:

```mermaid
flowchart LR
    A[Input Code] --> B[Parser]
    B --> C[AST]
    C --> D[Doc Builder]
    D --> E[Doc IR]
    E --> F[Printer]
    F --> G[Formatted Output]

    style D fill:#f9d,stroke:#333,stroke-width:2px
    style E fill:#f9d,stroke:#333,stroke-width:2px
    style F fill:#f9d,stroke:#333,stroke-width:2px
```

The key insight in Prettier's design is the **Doc IR (Intermediate Representation)** which sits between the AST and the final output. This IR abstracts formatting concerns from the AST structure, allowing for more flexible and powerful formatting strategies.

The Doc IR represents the _intent_ of formatting rather than the direct formatting itself. It contains elements like:

- Text segments
- Potential line breaks
- Indentation levels
- Groups that can be printed in one line or broken into multiple lines

The printer phase then uses an algorithm based on Philip Wadler's "A Prettier Printer" paper to render this IR into the final formatted code with optimal line breaks.

## Incremental Refactoring Steps

### 1. Create a Three-Phase Pipeline Architecture

**Current State:**
Your formatter currently combines AST traversal, formatting decisions, and output generation into a single pass, with methods like `exit_assignment` that both make formatting decisions and emit code.

```mermaid
flowchart LR
    A[AST] --> B[Visitor Methods]
    B --> C[Formatted Output]

    subgraph "Current Approach"
        B
    end
```

**Target State:**
We need to separate this into distinct phases:

```mermaid
flowchart LR
    A[AST] --> B[AST Visitor]
    B --> C[Doc IR]
    C --> D[Printer]
    D --> E[Formatted Output]

    subgraph "New Architecture"
        B --- C --- D
    end
```

**Implementation Plan:**

1. Create a new `JacDocBuilder` class that will transform the AST into a Doc IR.
2. Create a new `JacPrinter` class that will format the Doc IR into the final code.
3. Modify the existing `JacFormatPass` to orchestrate these components rather than doing everything itself.

```python
class JacFormatPass(UniPass):
    """JacFormat Pass format Jac code."""

    def before_pass(self) -> None:
        """Initialize pass."""
        self.options = FormatterOptions()
        self.doc_builder = JacDocBuilder(self.options)
        self.printer = JacPrinter(self.options)

    def run_pass(self) -> None:
        """Execute the formatting pass."""
        # Phase 1: Build Doc IR
        doc = self.doc_builder.build(self.ir_in)

        # Phase 2: Print the Doc IR to formatted code
        formatted_code = self.printer.print(doc)

        # Store the result in the output IR
        self.ir_out = self.ir_in.copy()
        self.ir_out.source.content = formatted_code
```

This separation allows each component to focus on its specific responsibility, making the code more maintainable and easier to test.

### 2. Implement a Doc Builder Abstraction

The Doc IR is the cornerstone of Prettier's architecture. It provides an abstract representation of the formatting that can be rendered optimally.

**Implementation Details:**

Create a hierarchy of Doc classes to represent different formatting constructs:

```python
class Doc:
    """Base class for document parts."""
    def __str__(self):
        return self.__class__.__name__

class Text(Doc):
    """Simple text content."""
    def __init__(self, text):
        self.text = text

    def __str__(self):
        return f'Text("{self.text}")'

class Line(Doc):
    """Represents a line break that can be preserved or flattened."""
    def __init__(self, hard=False, literal=False):
        self.hard = hard      # If True, always break
        self.literal = literal  # If True, includes the literal newline in flattened output

    def __str__(self):
        attrs = []
        if self.hard:
            attrs.append("hard")
        if self.literal:
            attrs.append("literal")
        return f"Line({', '.join(attrs)})"

class Group(Doc):
    """A group that can be printed flat or broken into multiple lines."""
    def __init__(self, contents, break_contiguous=False, id=None):
        self.contents = contents
        self.break_contiguous = break_contiguous
        self.id = id

    def __str__(self):
        return f"Group({self.contents})"

class Indent(Doc):
    """Indented content."""
    def __init__(self, contents):
        self.contents = contents

    def __str__(self):
        return f"Indent({self.contents})"

class Concat(Doc):
    """A sequence of doc parts."""
    def __init__(self, parts):
        self.parts = parts

    def __str__(self):
        return f"Concat({self.parts})"

class IfBreak(Doc):
    """Content that differs based on whether the parent group is broken."""
    def __init__(self, break_contents, flat_contents):
        self.break_contents = break_contents
        self.flat_contents = flat_contents

    def __str__(self):
        return f"IfBreak({self.break_contents}, {self.flat_contents})"

class Align(Doc):
    """Alignment relative to the current indentation level."""
    def __init__(self, contents, n=None):
        self.contents = contents
        self.n = n  # Number of spaces, or null to use current indentation level

    def __str__(self):
        return f"Align({self.n}, {self.contents})"
```

Example of how these might be used together to represent formatted code:

```python
# The code: if (condition) { statement; }
doc = Group(
    Concat([
        Text("if "),
        Text("("),
        Text("condition"),
        Text(")"),
        Text(" {"),
        IfBreak(
            # If the group breaks
            Concat([
                Line(),
                Indent(
                    Concat([
                        Text("statement;"),
                        Line()
                    ])
                ),
                Text("}")
            ]),
            # If the group stays flat
            Concat([
                Text(" statement; "),
                Text("}")
            ])
        )
    ])
)
```

This Doc IR can represent both the flat and broken forms of the code, and the printer will decide which to use based on line length constraints.

### 3. Refactor AST Traversal to Build Doc IR

Instead of emitting code directly, the AST traversal will now build a Doc IR.

**Current approach:**

```python
def exit_assignment(self, node: uni.Assignment) -> None:
    prev_token = None
    for kid in node.kid:
        if isinstance(kid, uni.CommentToken):
            if kid.is_inline:
                self.emit(node, kid.gen.jac)
            else:
                self.emit_ln(node, "")
                self.emit_ln(node, "")
                self.emit_ln(node, kid.gen.jac)
        elif isinstance(kid, uni.Token) and kid.name == Tok.KW_LET:
            self.emit(node, f"{kid.gen.jac} ")
        elif isinstance(kid, uni.Token) and "=" in kid.gen.jac:
            self.emit(node, f" {kid.gen.jac} ")
        # ... more formatting logic
```

**New approach:**

```python
def build_assignment(self, node: uni.Assignment) -> Doc:
    """Build Doc IR for an assignment node."""
    parts = []

    for kid in node.kid:
        if isinstance(kid, uni.CommentToken):
            if kid.is_inline:
                parts.append(Text(" "))
                parts.append(Text(kid.value))
            else:
                parts.append(Line(hard=True))
                parts.append(Line(hard=True))
                parts.append(Text(kid.value))
                parts.append(Line(hard=True))
        elif isinstance(kid, uni.Token) and kid.name == Tok.KW_LET:
            parts.append(Text(kid.value))
            parts.append(Text(" "))
        elif isinstance(kid, uni.Token) and "=" in kid.value:
            parts.append(Text(" "))
            parts.append(Text(kid.value))
            parts.append(Text(" "))
        elif "=" in kid.gen.doc and self.is_line_break_needed(kid.gen.doc):
            # Handle long assignments with a group that allows breaking
            parts.append(
                Group(
                    Concat([
                        self.split_assignment_into_doc(kid.gen.doc)
                    ])
                )
            )
        else:
            parts.append(kid.gen.doc)

    return Group(Concat(parts))

def split_assignment_into_doc(self, assignment_text):
    """Split a long assignment into a Doc structure with potential breaks."""
    parts = re.split(r"(=)", assignment_text)
    doc_parts = []

    # Handle first part
    first_part = parts.pop(0).strip()
    doc_parts.append(Text(first_part))

    # Handle equals sign
    if parts:
        doc_parts.append(Text(" "))
        doc_parts.append(Text(parts.pop(0).strip()))
        doc_parts.append(Text(" "))

    # Handle remaining parts with potential breaks
    if parts:
        value_part = parts.pop(0).strip()
        if self.is_complex_expression(value_part):
            doc_parts.append(self.build_complex_expression_doc(value_part))
        else:
            doc_parts.append(Text(value_part))

    return Concat(doc_parts)
```

This approach separates the construction of the formatting representation from the actual output generation, allowing for more sophisticated formatting decisions.

### 4. Implement a Separate Printer

The printer's job is to convert the Doc IR into formatted text, making optimal decisions about line breaks.

```python
class JacPrinter:
    """Printer for Doc IR structures into formatted code."""

    def __init__(self, options):
        self.options = options

    def print(self, doc):
        """Print the Doc IR to a formatted string."""
        return self._print_doc(doc, 0, self.options.max_line_length)

    def _print_doc(self, doc, indent_level, width_remaining, is_broken=False):
        """Recursively print a Doc node."""
        if isinstance(doc, Text):
            return doc.text

        elif isinstance(doc, Line):
            if is_broken or doc.hard:
                return "\n" + " " * (indent_level * self.options.indent_size)
            else:
                return " " if not doc.literal else "\n"

        elif isinstance(doc, Group):
            # Try to print flat first
            flat_contents = self._print_doc(doc.contents, indent_level, width_remaining)

            # If it fits, use flat version
            if len(flat_contents.splitlines()[-1]) <= width_remaining and "\n" not in flat_contents:
                return flat_contents

            # Otherwise, print broken
            return self._print_doc(doc.contents, indent_level, width_remaining, True)

        elif isinstance(doc, Indent):
            return self._print_doc(doc.contents, indent_level + 1,
                                 width_remaining - self.options.indent_size, is_broken)

        elif isinstance(doc, Concat):
            result = ""
            current_width = width_remaining

            for part in doc.parts:
                part_str = self._print_doc(part, indent_level, current_width, is_broken)
                result += part_str

                # Update remaining width
                if "\n" in part_str:
                    lines = part_str.splitlines()
                    current_width = width_remaining - len(lines[-1])
                else:
                    current_width -= len(part_str)

            return result

        elif isinstance(doc, IfBreak):
            if is_broken:
                return self._print_doc(doc.break_contents, indent_level, width_remaining, is_broken)
            else:
                return self._print_doc(doc.flat_contents, indent_level, width_remaining, is_broken)

        elif isinstance(doc, Align):
            align_size = self.options.indent_size if doc.n is None else doc.n
            return self._print_doc(doc.contents, indent_level + align_size//self.options.indent_size,
                                 width_remaining - align_size, is_broken)

        # Default case
        return str(doc)
```

This implementation is a simplified version of Wadler's algorithm. A full implementation would include more sophisticated fitting logic, caching, and optimization.

### 5. Decouple Comment Handling

Comments are a common source of complexity in formatters. Prettier handles them by attaching comments to AST nodes before formatting.

**Implementation Plan:**

1. Create a comment attachment phase that runs before Doc IR generation.
2. Modify the Doc IR to include attached comments.
3. Update the printer to handle comments appropriately.

```python
class CommentAttacher:
    """Attaches comments to the nearest relevant AST nodes."""

    def __init__(self, ast, comments):
        self.ast = ast
        self.comments = sorted(comments, key=lambda c: c.loc.first_line)

    def run(self):
        """Attach comments to nodes and return the modified AST."""
        self.unattached_comments = list(self.comments)
        self._visit_node(self.ast)
        return self.ast

    def _visit_node(self, node):
        """Visit a node and its children, attaching comments as appropriate."""
        # Attach leading comments (before the node)
        node.leading_comments = self._get_comments_before(node)

        # Recursively visit children
        for child in node.children():
            self._visit_node(child)

        # Attach trailing comments (after the node)
        node.trailing_comments = self._get_comments_after(node)

    def _get_comments_before(self, node):
        """Get comments that appear before the node."""
        result = []

        for comment in list(self.unattached_comments):
            if comment.loc.last_line < node.loc.first_line:
                result.append(comment)
                self.unattached_comments.remove(comment)

        return result

    def _get_comments_after(self, node):
        """Get comments that appear after the node but before the next node."""
        # Implementation would depend on how to determine the "next" node
        # This is a simplified version
        result = []

        for comment in list(self.unattached_comments):
            if (comment.loc.first_line > node.loc.last_line and
                (not node.next_sibling or comment.loc.last_line < node.next_sibling.loc.first_line)):
                result.append(comment)
                self.unattached_comments.remove(comment)

        return result
```

Then in the Doc builder:

```python
def build_node_doc(self, node):
    """Build a Doc for a node including its attached comments."""
    parts = []

    # Add leading comments
    if hasattr(node, 'leading_comments') and node.leading_comments:
        for comment in node.leading_comments:
            parts.append(Text(comment.value))
            parts.append(Line(hard=True))

    # Build the node's own Doc
    node_doc = self._build_specific_node_doc(node)
    parts.append(node_doc)

    # Add trailing comments
    if hasattr(node, 'trailing_comments') and node.trailing_comments:
        for comment in node.trailing_comments:
            parts.append(Text(comment.value))
            parts.append(Line(hard=True))

    return Concat(parts)
```

This approach makes comment handling more systematic and predictable.

### 6. Refactor Formatting Rules

Currently, your formatting rules are spread across many `exit_*` methods. A cleaner approach would be to centralize these rules.

```python
class FormattingRules:
    """Central repository for formatting rules."""

    def __init__(self, options):
        self.options = options

    def format_node(self, node):
        """Format any node by dispatching to the appropriate method."""
        method_name = f"format_{node.__class__.__name__.lower()}"
        if hasattr(self, method_name):
            return getattr(self, method_name)(node)
        else:
            return self.format_default(node)

    def format_default(self, node):
        """Default formatting for nodes without specific rules."""
        # Generic formatting logic

    def format_assignment(self, node):
        """Format an assignment node."""
        # Assignment-specific formatting

    def format_binaryexpr(self, node):
        """Format a binary expression."""
        # Binary expression formatting

    # Additional formatting methods for other node types
```

This approach makes it easier to see all formatting rules in one place and reuse common patterns.

### 7. Implement Configurable Options

A clean options system makes it easier to adjust formatting behavior:

```python
class FormatterOptions:
    """Configuration options for the formatter."""

    def __init__(self,
                 indent_size=4,
                 max_line_length=80,
                 tab_width=4,
                 use_tabs=False,
                 semicolons=True,
                 bracket_spacing=True,
                 jsx_bracket_same_line=False,
                 arrow_parens='always',
                 trailing_comma='all'):
        """Initialize formatter options with defaults."""
        self.indent_size = indent_size
        self.max_line_length = max_line_length
        self.tab_width = tab_width
        self.use_tabs = use_tabs
        self.semicolons = semicolons
        self.bracket_spacing = bracket_spacing
        self.jsx_bracket_same_line = jsx_bracket_same_line
        self.arrow_parens = arrow_parens
        self.trailing_comma = trailing_comma

    @classmethod
    def from_config_file(cls, file_path):
        """Load options from a configuration file."""
        # Implementation to load from a config file

    def merge(self, overrides):
        """Create a new options object with the given overrides."""
        new_options = self.__class__()
        for key, value in vars(self).items():
            setattr(new_options, key, getattr(overrides, key, value))
        return new_options
```

You can then reference these options throughout the formatter:

```python
def build_assignment(self, node):
    parts = []
    # ...
    if self.options.semicolons:
        parts.append(Text(";"))
    # ...
    return Group(Concat(parts))
```

This makes the formatter more configurable and adaptable to different coding styles.

### 8. Refactor Specific Node Types Incrementally

Start by refactoring the most complex node types to use the new architecture, then gradually convert the rest.

```mermaid
gantt
    title Incremental Node Type Refactoring
    dateFormat  YYYY-MM-DD
    section Phase 1
    Assignment            :p1, 2023-06-01, 5d
    BinaryExpr            :p2, 2023-06-06, 5d
    FuncCall              :p3, 2023-06-11, 5d
    section Phase 2
    IfStmt                :p4, 2023-06-16, 5d
    Archetype             :p5, 2023-06-21, 5d
    HasVar                :p6, 2023-06-26, 5d
    section Phase 3
    ImportStmt            :p7, 2023-07-01, 5d
    All remaining types   :p8, 2023-07-06, 15d
```

For each node type:

1. Create a Doc builder method
2. Test the formatting
3. Verify that it works with the printer
4. Move on to the next node type

This phased approach allows for incremental progress while keeping the formatter functional.

### 9. Implement Line Break and Indentation Logic

The key to good formatting is intelligent line breaking and indentation. With the Doc IR, you can implement sophisticated algorithms for this:

```python
def should_break_group(self, group, flat_content, width_remaining):
    """Determine if a group should be broken based on remaining width."""
    # Simple case: if flat content fits, don't break
    if len(flat_content) <= width_remaining:
        return False

    # More complex heuristics
    # 1. Does it contain deeply nested groups that would benefit from breaking?
    nested_depth = self._get_group_nesting_depth(group)
    if nested_depth > 2:
        return True

    # 2. Does it contain specific constructs that read better when broken?
    has_break_worthy_constructs = self._has_break_worthy_constructs(group)
    if has_break_worthy_constructs:
        return True

    # 3. Would breaking save a significant amount of horizontal space?
    flat_lines = flat_content.splitlines()
    if len(flat_lines) > 1 and max(len(l) for l in flat_lines) > width_remaining * 0.8:
        return True

    return False

def _get_group_nesting_depth(self, group):
    """Get the maximum nesting depth of groups within this group."""
    # Implementation depends on your Doc IR structure

def _has_break_worthy_constructs(self, group):
    """Check if the group contains constructs that read better when broken."""
    # Check for long parameter lists, complex expressions, etc.
```

This kind of logic can significantly improve the quality of the formatting.

### 10. Add Tests for Each Phase

Comprehensive tests ensure that the refactoring doesn't break existing functionality:

```python
def test_doc_builder():
    """Test that the Doc builder creates the expected Doc IR."""
    # Arrange
    ast = parse("x = 1 + 2")
    options = FormatterOptions()
    builder = JacDocBuilder(options)

    # Act
    doc = builder.build(ast)

    # Assert
    assert isinstance(doc, Group)
    assert len(doc.contents.parts) == 3  # x, =, 1 + 2

def test_printer():
    """Test that the printer produces the expected output."""
    # Arrange
    doc = Group(Concat([
        Text("x"),
        Text(" = "),
        Text("1 + 2")
    ]))
    options = FormatterOptions()
    printer = JacPrinter(options)

    # Act
    output = printer.print(doc)

    # Assert
    assert output == "x = 1 + 2"

def test_end_to_end():
    """Test the entire formatting pipeline."""
    # Arrange
    input_code = "x=1+2"
    options = FormatterOptions()
    formatter = JacFormatter(options)

    # Act
    output = formatter.format(input_code)

    # Assert
    assert output == "x = 1 + 2"
```

These tests should cover both simple and complex cases, as well as edge cases like comments, empty blocks, and very long lines.

## Challenges and Considerations

### Handling Comments

Comments are challenging because they need to be preserved but aren't part of the AST structure. The comment attacher phase addresses this, but may need refinement for complex cases.

### Preserving Semantic Structure

It's important that the formatter doesn't change the meaning of the code. Be careful with operators and expressions where whitespace matters.

```python
def validate_semantic_preservation(self, original_ast, formatted_code):
    """Verify that formatting preserves semantic structure."""
    formatted_ast = parse(formatted_code)
    return self._ast_semantically_equivalent(original_ast, formatted_ast)

def _ast_semantically_equivalent(self, ast1, ast2):
    """Check if two ASTs are semantically equivalent."""
    # Implementation would compare structure ignoring formatting details
```

### Performance

For large files, the formatting process can be time-consuming. Consider optimizations:

1. Caching Doc IRs for unchanged parts of code
2. Parallelizing formatting of independent sections
3. Implementing the printer efficiently to avoid recomputing layouts

```python
class DocCache:
    """Cache for Doc IRs to avoid redundant computation."""

    def __init__(self):
        self.cache = {}

    def get(self, node_hash):
        """Get a cached Doc IR for a node, if available."""
        return self.cache.get(node_hash)

    def put(self, node_hash, doc):
        """Cache a Doc IR for a node."""
        self.cache[node_hash] = doc

    def invalidate(self, node_hash=None):
        """Invalidate cache entries."""
        if node_hash is None:
            self.cache.clear()
        else:
            self.cache.pop(node_hash, None)
```

### Backward Compatibility

If users are already relying on your current formatter, consider a transitional period:

```python
def format(self, code, use_new_architecture=True):
    """Format code using either the new or old architecture."""
    if use_new_architecture:
        # Use the new pipeline
        ast = parse(code)
        doc = self.doc_builder.build(ast)
        return self.printer.print(doc)
    else:
        # Use the existing formatter
        # Implementation using current approach
```

## Conclusion

Refactoring your formatter to a Prettier-style architecture provides significant benefits:

- **Cleaner separation of concerns** between parsing, formatting decisions, and output generation
- **More maintainable codebase** with centralized formatting rules
- **Better handling of line breaks** through the Doc IR abstraction
- **More predictable formatting** due to systematic algorithms

The incremental approach outlined here allows you to make progress while keeping the formatter functional. Start with the core architectural changes, then refactor node types one by one, and finally implement the more sophisticated formatting logic.

Remember that the goal is not just to mimic Prettier, but to adopt the architectural principles that make it successful, while preserving the domain-specific knowledge and formatting rules that are tailored to your language.



================================================================================
FILE: docs/internals/planning_specs/native_type_system/architecture.md
================================================================================


# Type System Architecture

This document outlines the high-level architecture of Jac's native type system, detailing its core components and how they interact with each other.

## Core Components

The native type system consists of several key components that work together throughout the compilation process:

```mermaid
graph TD
    A[Type Representations] --> B[Type Environment]
    A --> C[Type Resolver]
    B <--> C
    C --> D[Type Checker]
    B --> D
    E[Symbol Tables] <--> B
    F[AST Nodes] --> C
    F <--> D
    D --> G[Type Inferencer]
    B <--> G
```

### Type Representations

At the core of the system is a hierarchy of classes representing Jac types. Instead of simple strings, these classes provide rich type information that facilitates operations like:

- Type equivalence checking
- Subtyping relationships
- Type operations (like unions, intersections)
- Parameter validation for generics

```mermaid
classDiagram
    JacType <|-- PrimitiveType
    JacType <|-- ArchetypeType
    JacType <|-- CallableType
    JacType <|-- ContainerType
    JacType <|-- UnionType
    JacType <|-- OptionalType
    JacType <|-- TypeVariable
    ContainerType <|-- ListType
    ContainerType <|-- DictType
    ContainerType <|-- TupleType

    class JacType {
        <<abstract>>
        +is_equivalent(other: JacType) bool
        +is_subtype_of(super_type: JacType, env: TypeEnvironment) bool
        +__str__() str
    }

    class PrimitiveType {
        +name str
    }

    class ArchetypeType {
        +name str
        +sym_tab UniScopeNode
        +arch_node Archetype
    }
```

### Type Environment

The Type Environment manages the typing context as the compiler processes the code. It:

- Tracks variable types within lexical scopes
- Maintains the hierarchy of scopes
- Holds contextual information (current archetype, return type expectations)
- Caches type resolutions for performance

```mermaid
classDiagram
    TypeEnvironment --> "1..*" Scope
    Scope --> "0..1" Scope : parent_scope

    class TypeEnvironment {
        +scope_stack List~Scope~
        +current_archetype ArchetypeType
        +current_callable_ret_type JacType
        +inheritance_cache Dict
        +node_to_type_map Dict
        +enter_scope()
        +exit_scope()
        +add_variable(name, type)
        +get_variable_type(name)
    }

    class Scope {
        +variables Dict~str, JacType~
        +type_vars Dict~str, TypeVariable~
        +sym_tab_scope UniScopeNode
        +parent_scope Scope
        +lookup_var(name, deep)
        +define_var(name, type)
    }
```

### Type Resolver

The Type Resolver translates syntactic type representations in the AST into the structured JacType objects. It handles:

- Simple type name resolution
- Generic parameter resolution
- Union and intersection types
- Qualified name resolution (for imported types)

### Type Checker

The Type Checker applies type checking rules to validate operations, assignments, and expressions. It:

- Traverses the AST
- Validates operations against operand types
- Checks assignments for type compatibility
- Verifies function calls against signatures
- Reports type errors with meaningful messages

### Type Inferencer

The Type Inferencer determines types when they aren't explicitly annotated:

- Infers types from initializers
- Propagates type information through operations
- Uses constraint solving for complex cases
- Applies contextual typing based on expected types

## Compiler Integration

```mermaid
flowchart TD
    A[Parser] --> B[AST Generation]
    B --> C[Symbol Table Construction]
    C --> D[Type Annotation Resolution]
    D --> E[Type Inference]
    E --> F[Type Constraint Generation]
    F --> G[Constraint Solving]
    G --> H[Type Checking]
    H --> I[Code Generation]

    subgraph "Native Type System"
    D
    E
    F
    G
    H
    end
```

The type system is tightly integrated with the compiler:

1. After parsing and building initial symbol tables, the **Type Annotation Resolution** phase resolves explicit type annotations into JacType objects
2. Next, the **Type Inference** phase infers types for expressions and variables without explicit annotations
3. The **Type Constraint Generation** phase generates constraints from operations and control flow
4. The **Constraint Solving** phase resolves these constraints to determine concrete types
5. Finally, the **Type Checking** phase validates all expressions and statements against the resolved types

## Error Handling

Type errors are reported through the compiler's error system with:

- Precise source location information
- Clear error messages explaining the issue
- Suggestions for fixes when possible
- Categorization of errors (e.g., assignment incompatibility, invalid operation)

## Design Principles

The architecture follows these key principles:

1. **Progressive Resolution**: Types are refined in multiple passes rather than requiring everything to be determinable in a single pass
2. **Clear Separation of Concerns**: Each component has well-defined responsibilities
3. **AST Integration**: Type information is attached directly to AST nodes for easy access
4. **Performance Consideration**: Caching mechanisms minimize redundant work
5. **Extensibility**: The system can be extended with new type constructs and rules



================================================================================
FILE: docs/internals/planning_specs/native_type_system/compiler_integration.md
================================================================================


# Compiler Integration

This document explains how the native type system integrates with the Jac compiler infrastructure.

## Overview

The type system is tightly integrated with the Jac compiler through multiple passes that work together to analyze, infer, and check types throughout the compilation process.

```mermaid
graph TD
    subgraph Parsing
        A[Parser] --> B[AST Generation]
    end

    subgraph "Symbol Resolution"
        B --> C[Symbol Table Construction]
        C --> D[DefUsePass]
        D --> E[InheritancePass]
    end

    subgraph "Type System"
        E --> F[TypeAnnotationResolvePass]
        F --> G[TypeInferencePass]
        G --> H[TypeConstraintPass]
        H --> I[TypeCheckPass]
    end

    subgraph "Code Generation"
        I --> J[PyastGenPass]
        J --> K[PyBytecodeGenPass]
    end

    L[Error Reporting System] --- F
    L --- G
    L --- H
    L --- I
```

## Compiler Passes for Type System

The type system is implemented as a series of compiler passes that execute in a specific order:

### 1. TypeAnnotationResolvePass

This pass resolves explicit type annotations in the AST:

```python
class TypeAnnotationResolvePass(Transform[Module, Module]):
    """Resolves explicit type annotations in the AST."""

    def __init__(self, ir_in: Module, prog: JacProgram) -> None:
        super().__init__(ir_in, prog)
        self.resolver = TypeResolver(self.report_error)
        self.env = TypeEnvironment(ir_in, self.resolver)

    def visit_HasVar(self, node: uni.HasVar) -> None:
        """Process a variable declaration with type annotation."""
        if node.type_tag:
            type_annotation = self.resolver.resolve_type_from_ast(node.type_tag, self.env)
            node.jac_type = type_annotation

            # Also store in symbol table if possible
            if node.name.sym_link and node.name.sym_link.decl:
                node.name.sym_link.decl.resolved_jac_type = type_annotation

        super().visit_HasVar(node)
```

The TypeAnnotationResolvePass:
- Creates a TypeResolver and TypeEnvironment
- Traverses the AST to find explicit type annotations
- Resolves annotations to JacType instances
- Attaches types to AST nodes and symbol table entries

### 2. TypeInferencePass

This pass infers types for expressions and variables without explicit annotations:

```python
class TypeInferencePass(Transform[Module, Module]):
    """Infers types for expressions and variables without explicit annotations."""

    def __init__(self, ir_in: Module, prog: JacProgram) -> None:
        super().__init__(ir_in, prog)
        self.resolver = TypeResolver(self.report_error)
        self.env = TypeEnvironment(ir_in, self.resolver)
        self.constraint_collector = TypeConstraintCollector()

    def visit_Assignment(self, node: uni.Assignment) -> None:
        """Process an assignment expression."""
        # Visit children first to collect their types
        super().visit_Assignment(node)

        # Generate a type constraint: rhs_type <: lhs_type
        if node.left.jac_type is None:
            # Infer from right side if left has no type yet
            if node.right.jac_type:
                node.left.jac_type = node.right.jac_type
        else:
            # Otherwise add a constraint
            self.constraint_collector.add_subtype_constraint(
                node.right, node.left,
                f"Assignment at {node.loc.line_no}:{node.loc.col_no}"
            )
```

The TypeInferencePass:
- Collects types already determined from annotations
- Infers types for expressions from their subexpressions
- Infers types for variables from initializers
- Generates type constraints for further solving

### 3. TypeConstraintPass

This pass collects and solves constraints to determine consistent types:

```python
class TypeConstraintPass(Transform[Module, Module]):
    """Collects and solves type constraints."""

    def __init__(self, ir_in: Module, prog: JacProgram) -> None:
        super().__init__(ir_in, prog)
        self.constraint_solver = TypeConstraintSolver(self.report_error)

    def apply(self) -> None:
        # Collect all constraints from previous passes
        constraints = self.prog.type_constraints

        # Solve the constraint system
        resolved_types = self.constraint_solver.solve(constraints)

        # Apply the resolved types to AST nodes
        for node_id, resolved_type in resolved_types.items():
            node = self.prog.ast_node_map.get(node_id)
            if node:
                node.jac_type = resolved_type
```

The TypeConstraintPass:
- Takes constraints from the TypeInferencePass
- Builds a constraint graph
- Applies constraint propagation algorithms
- Resolves type variables to concrete types
- Updates AST nodes with the resolved types

### 4. TypeCheckPass

This pass validates that operations are type-safe:

```python
class TypeCheckPass(Transform[Module, Module]):
    """Validates that operations are type-safe."""

    def __init__(self, ir_in: Module, prog: JacProgram) -> None:
        super().__init__(ir_in, prog)
        self.resolver = TypeResolver(self.report_error)
        self.env = TypeEnvironment(ir_in, self.resolver)

    def visit_BinaryExpr(self, node: uni.BinaryExpr) -> None:
        """Check a binary expression."""
        super().visit_BinaryExpr(node)

        left_type = node.left.jac_type
        right_type = node.right.jac_type

        if not left_type or not right_type:
            return  # Skip if types are missing (error reported elsewhere)

        if node.op.name == uni.Tok.PLUS:
            # Check if + operation is valid for these types
            if not self.is_valid_addition(left_type, right_type):
                self.report_error(
                    JacErrorCode.TYPE_ERROR_INVALID_OPERATION,
                    args={
                        "op": "+",
                        "left_type": str(left_type),
                        "right_type": str(right_type)
                    },
                    node_override=node
                )
            else:
                # Set the result type
                node.jac_type = self.determine_addition_result_type(left_type, right_type)
```

The TypeCheckPass:
- Validates that operations are performed on compatible types
- Checks that assignments respect the type system
- Verifies function arguments match parameter types
- Reports detailed type errors when violations occur
- Sets result types for expressions

## Integration with Symbol Tables

The type system heavily integrates with Jac's symbol table system:

```mermaid
graph TD
    A[AST Node] --> B[Symbol Table Entry]
    A --> C[JacType]
    B --> D[resolved_jac_type]

    E[TypeEnvironment] --> F[Current Scope]
    F --> G[Symbol Table Scope]
    F --> H[Variable Type Map]

    I[ArchetypeType] --> J[Symbol Table of Archetype]
```

Key integration points:
1. **Symbol Table Linking**: The Symbol Table helps the type system locate definitions for type names
2. **Type Storage**: Types are stored both on AST nodes and in Symbol Table entries
3. **Scope Navigation**: The TypeEnvironment uses Symbol Table scopes to resolve names
4. **Member Lookup**: ArchetypeType instances maintain links to their Symbol Tables for member lookup

## Replacing MyPy Integration

The native type system completely replaces the previous MyPy-based approach:

| Old MyPy Approach | New Native Approach |
|-------------------|---------------------|
| Convert Jac AST to Python AST | Work directly on Jac AST |
| Run MyPy on Python AST | Run native type checking passes |
| Extract type strings from MyPy | Use rich JacType instances |
| Map types back to Jac AST | Types directly attached to AST nodes |
| Limited understanding of Jac constructs | Full understanding of Jac-specific features |

```mermaid
graph TD
    subgraph "Old Approach"
        A1[Jac AST] --> B1[Python AST]
        B1 --> C1[MyPy Analysis]
        C1 --> D1[String Type Info]
        D1 --> E1[FuseTypeInfoPass]
        E1 --> F1[Type String on AST]
    end

    subgraph "New Approach"
        A2[Jac AST] --> B2[Symbol Tables]
        B2 --> C2[TypeAnnotationResolvePass]
        C2 --> D2[TypeInferencePass]
        D2 --> E2[TypeCheckPass]
        E2 --> F2[JacType Objects on AST]
    end
```

## Integration with Error Reporting

Type errors are reported through the compiler's existing error reporting system:

```python
def report_error(self, error_code: JacErrorCode, args: dict, node_override: Optional[uni.UniNode] = None) -> None:
    """Report a type error through the compiler's error system."""
    loc = node_override.loc if node_override else self.curr_node.loc if self.curr_node else None

    self.errors_had.append(
        Alert(
            error_code=error_code,
            msg_args=args,
            severity=Severity.ERROR,
            loc_override=loc
        )
    )
```

Error messages provide:
- Clear description of the type error
- Exact source location
- Expected vs. actual types
- Suggestions for fixing the error when possible

## Integration with Runtime Type Information

The native type system can also generate runtime type information when needed:

```python
class PyastGenPass(Transform[Module, Module]):
    """Generates Python AST for code generation."""

    def generate_type_annotation(self, jac_type: JacType) -> Optional[py_ast.expr]:
        """Convert a JacType to a Python type annotation."""
        if isinstance(jac_type, PrimitiveType):
            return py_ast.Name(id=jac_type.name, ctx=py_ast.Load())
        elif isinstance(jac_type, ListType):
            return py_ast.Subscript(
                value=py_ast.Name(id='list', ctx=py_ast.Load()),
                slice=py_ast.Index(value=self.generate_type_annotation(jac_type.element_type)),
                ctx=py_ast.Load()
            )
        # ... other type conversions
```

This enables:
- Generation of Python type annotations for Jac code
- Runtime type checks if desired
- IDE integration and tooling support

## Extension Points

The design allows for easy extension with new types and features:

1. **Adding New Types**: Extend the JacType hierarchy with new type classes
2. **Custom Type Rules**: Modify TypeCheckPass to handle special typing rules
3. **Language Feature Support**: Add specific handling for Jac features like walkers
4. **Optimization Hints**: Use type information for optimization
5. **IDE Integration**: Export type information for IDE tooling

## Performance Considerations

The system includes several optimizations to ensure good performance:

1. **Type Caching**: Resolved types are cached to avoid redundant computation
2. **Incremental Analysis**: Only re-analyze parts of the code that have changed
3. **Early Error Detection**: Fail fast when errors are detected
4. **Parallel Processing**: Some passes can be parallelized for large projects



================================================================================
FILE: docs/internals/planning_specs/native_type_system/index.md
================================================================================


 # Native Type System

This section covers the design and implementation of Jac's native type system. Instead of relying on external type checkers like mypy, Jac now implements its own fully integrated type checking system that's designed to work seamlessly with the language's unique features.

## Overview

The Jac native type system provides comprehensive static type checking throughout the compilation process. It's designed to catch type errors early while supporting Jac's specific constructs like walkers, nodes, edges, and abilities.

```mermaid
graph TD
    A[Source Code] --> B[Parser]
    B --> C[AST Generation]
    C --> D[Symbol Table Construction]
    D --> E[Type Resolution]
    E --> F[Type Checking]
    F --> G[Type Inference]
    G --> H[Code Generation]

    style E fill:#f96,stroke:#333,stroke-width:2px
    style F fill:#f96,stroke:#333,stroke-width:2px
    style G fill:#f96,stroke:#333,stroke-width:2px
```

## Key Features

- **Progressive Type Resolution**: Types are resolved during multiple compiler passes, enabling complex type relationships to be properly validated
- **Full Type Inference**: Variables can be implicitly typed based on their usage and initialization
- **Gradual Typing**: Optional type annotations allow for flexibility while still providing type safety where specified
- **Object-Oriented Type Checking**: Robust support for inheritance, interfaces, and polymorphism
- **Object-Spatial Type Extensions**: Special handling for Jac-specific constructs like walkers, nodes, and edges

## Documentation Structure

- [**Type System Architecture**](architecture.md): Core design of the type system
- [**Type Representation**](type_representation.md): How types are represented internally
- [**Type Resolution**](type_resolution.md): The process of determining and validating types
- [**Type Rules**](type_rules.md): Formal rules for type checking in Jac
- [**Type Inference**](type_inference.md): How types are inferred when not explicitly specified
- [**Integration with Compiler**](compiler_integration.md): How the type system integrates with the compiler passes



================================================================================
FILE: docs/internals/planning_specs/native_type_system/lets_build.md
================================================================================


# Jac Type Checker Architecture: A Pyright-Inspired Approach

## Table of Contents

- [Introduction](#introduction)
- [System Overview](#system-overview)
- [Project Structure](#project-structure)
- [Core Components](#core-components)
  - [Type Model](#type-model)
  - [Type Factory](#type-factory)
  - [Type Relationships](#type-relationships)
  - [Type Narrowing](#type-narrowing)
- [Flow and Integration](#flow-and-integration)
  - [Type Checking Process for Jac](#type-checking-process-for-jac)
  - [Parser Integration for Jac](#parser-integration-for-jac)
  - [Type Evaluator Implementation for Jac](#type-evaluator-implementation-for-jac)
- [Advanced Features](#advanced-features)
  - [Protocol Support](#protocol-support)
  - [Type Guards](#type-guards)
  - [Structural Types](#structural-types)
- [Implementation Guide](#implementation-guide)
  - [Getting Started](#getting-started)
  - [Key Algorithms](#key-algorithms)
  - [Testing Strategy](#testing-strategy)
- [Comparison with Other Type Checkers](#comparison-with-other-type-checkers)
- [Conclusion](#conclusion)

## Introduction

This document outlines the architecture and implementation details for a Jac type checker that adopts Pyright's efficient approach to type checking, while being implemented in Python (as the Jac compiler itself is). Pyright, originally written in TypeScript, is known for its performance and scalability with large codebases. This architecture aims to bring those benefits to a Jac implementation.

The key innovations of this approach include:

1. An efficient type representation system with aggressive caching
2. Sophisticated type narrowing based on control flow analysis (adapted for Jac's control flow constructs)
3. High-performance algorithms for type compatibility checking
4. Memory-efficient data structures for representing the type system for Jac

## System Overview

```mermaid
graph TD
    A[Source Code] --> B[Parser]
    B --> C[AST Builder]
    C --> D[Binder]
    D --> E[Type Evaluator]
    E --> F[Type Checker]
    F --> G[Diagnostics]

    H[Type Model] --> E
    H --> F
    I[Type Cache] --> H
    J[Type Factory] --> H
    K[Type Narrower] --> E
    L[Config Options] --> F
```

The system follows a pipeline architecture where Jac source code flows through various stages of analysis, with the type model serving as the foundation for all type-related operations.

## Project Structure

The type checker components will be integrated into the existing Jac compiler structure, primarily within the `jaclang/compiler/` directory. New modules will be added, and existing ones might be augmented. Here's a proposed structure for the type checking additions:

```
jaclang/
â”œâ”€â”€ compiler/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ jac.lark                 # Jac grammar
â”‚   â”œâ”€â”€ parser.py                # Existing parser
â”‚   â”œâ”€â”€ ...                      # Other existing compiler files
â”‚   â”œâ”€â”€ typemodel/               # NEW: Type system model (inspired by Pyright)
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ types.py             # Core type classes for Jac (ArchetypeType, InstanceType, CallableType, etc.)
â”‚   â”‚   â”œâ”€â”€ type_factory.py      # Type creation factory
â”‚   â”‚   â”œâ”€â”€ type_cache.py        # Type caching
â”‚   â”‚   â”œâ”€â”€ type_relations.py    # Subtyping, assignability, etc.
â”‚   â”‚   â””â”€â”€ builtin_types.py     # Definitions for Jac's built-in types
â”‚   â”œâ”€â”€ passes/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ ...                  # Existing passes
â”‚   â”‚   â”œâ”€â”€ type_check_pass.py   # NEW: Main pass for type checking
â”‚   â”‚   â”œâ”€â”€ sym_tab_pass.py      # Possible existing or new pass for symbol table construction
â”‚   â”‚   â””â”€â”€ ...
â”‚   â”œâ”€â”€ analysis/                # NEW or Augmented: For deeper semantic analysis
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ symbol_table.py      # Symbol table (might exist or be enhanced)
â”‚   â”‚   â”œâ”€â”€ type_evaluator.py    # Type evaluation for Jac expressions
â”‚   â”‚   â”œâ”€â”€ type_narrower.py     # Type narrowing logic for Jac
â”‚   â”‚   â””â”€â”€ ...
â”‚   â””â”€â”€ utils/                   # Utility functions
â”‚       â”œâ”€â”€ __init__.py
â”‚       â”œâ”€â”€ diagnostics.py       # Error and warning reporting (might exist or be enhanced)
â”‚       â””â”€â”€ ...
â””â”€â”€ ...
tests/
â”œâ”€â”€ compiler/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ test_type_checker.py   # NEW: Tests for the type checker
â”‚   â”œâ”€â”€ test_type_narrowing.py # NEW: Tests for type narrowing
â”‚   â””â”€â”€ samples/               # Jac code samples for testing
    â””â”€â”€ ...
```

This structure aims to integrate the type checker smoothly into the Jac compiler's pass-based architecture.

## Core Components

### Type Model

The type model is the foundation of the entire type checker. It defines how Jac types are represented, compared, and manipulated.

```mermaid
classDiagram
    class Type {
        +TypeCategory category
        +TypeFlags flags
        +__eq__(other) bool
        +__hash__() int
    }

    class UnknownType {
        +__str__() str
    }

    class AnyType {
        +__str__() str
    }

    class NoneType {
        %% Represents Jac's null
        +__str__() str
    }

    class NeverType {
        +__str__() str
    }

    class ArchetypeType {
        %% Represents Jac archetypes: object, node, edge, walker, class
        +str name
        +str module
        +ArchetypeKind kind
        %% object, node, edge, walker, class
        +Dict members
        %% For 'has' variables
        +Dict abilities
        %% For 'can' abilities/methods
        +List bases
        %% Inherited archetypes
        +List typeParameters
        %% For potential future generic support
        +__eq__(other) bool
        +__hash__() int
        +__str__() str
    }

    class ArchetypeInstanceType {
        +ArchetypeType archetypeType
        +Dict typeArguments
        %% For potential future generic support
        +__eq__(other) bool
        +__hash__() int
        +__str__() str
    }

    class CallableType {
        %% Represents Jac abilities and functions
        +List parameters
        +Type returnType
        +bool is_ability
        %% Differentiates from plain functions if needed
        +__eq__(other) bool
        +__hash__() int
        +__str__() str
    }

    class EnumType {
        %% Represents Jac enums
        +str name
        +str module
        +Dict members
        +__eq__(other) bool
        +__hash__() int
        +__str__() str
    }

    class UnionType {
        +List types
        +__eq__(other) bool
        +__hash__() int
        +__str__() str
    }

    Type <|-- UnknownType
    Type <|-- AnyType
    Type <|-- NoneType
    Type <|-- NeverType
    Type <|-- ArchetypeType
    Type <|-- ArchetypeInstanceType
    Type <|-- CallableType
    Type <|-- EnumType
    Type <|-- UnionType
```

#### Implementation of the Base Type Class

```python
from enum import Enum, auto
from typing import Dict, List, Optional, Set, Tuple # Assuming these are needed

class TypeCategory(Enum):
    UNKNOWN = auto()
    ANY = auto()
    NONE = auto() # For Jac's null
    NEVER = auto()
    Archetype = auto() # For Jac archetypes
    Archetype_INSTANCE = auto()
    CALLABLE = auto() # For Jac abilities/functions
    ENUM = auto()
    UNION = auto()
    # ... other categories as needed

class TypeFlags(Enum): # Using Enum for flags for clarity, can be bitflags too
    NONE = 0
    # Example flags, to be defined based on Jac's needs
    IS_ABSTRACT = auto()
    IS_STATIC = auto()
    IS_READONLY = auto()
    # ... other flags

class Type:
    """Base class for all Jac type objects."""

    def __init__(self, category: TypeCategory):
        self.category = category
        self.flags: Set[TypeFlags] = {TypeFlags.NONE} # Using a set for flags

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, Type):
            return False
        return self.category == other.category

    def __hash__(self) -> int:
        return hash(self.category)
```

The `Type` class serves as the base for all type representations. It includes:

- A `category` field that identifies the kind of type (archetype, instance, union, enum, etc.)
- A `flags` field for additional type properties (e.g., static, abstract - needs Jac-specific definition)
- Equality and hash methods for efficient comparisons and storage in collections

#### Implementation of Archetype and Instance Types

Archetype and instance types are fundamental to Jac's object-oriented and agent-based features:

```python
class ArchetypeKind(Enum):
    OBJECT = auto()
    NODE = auto()
    EDGE = auto()
    WALKER = auto()
    CLASS = auto() # Generic class-like archetype
    ENUM_CLASS = auto() # The class for an Enum

class ArchetypeType(Type):
    """Represents a Jac archetype (object, node, edge, walker, class)."""

    def __init__(self, name: str, kind: ArchetypeKind, module: Optional[str] = None):
        super().__init__(TypeCategory.Archetype)
        self.name = name
        self.kind = kind
        self.module = module
        self.members: Dict[str, Type] = {} # For 'has' variables
        self.abilities: Dict[str, CallableType] = {} # For 'can' abilities/methods
        self.bases: List[ArchetypeType] = []
        self.type_parameters: List[Type] = [] # Placeholder for future generics

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, ArchetypeType):
            return False
        return (
            super().__eq__(other) and # Check base category
            self.name == other.name and
            self.kind == other.kind and
            self.module == other.module
        )

    def __hash__(self) -> int:
        return hash((self.category, self.name, self.kind, self.module))

    def __str__(self) -> str:
        prefix = self.kind.name.lower()
        if self.module:
            return f"{self.module}.{prefix}::{self.name}"
        return f"{prefix}::{self.name}"


class ArchetypeInstanceType(Type):
    """Represents an instance of a Jac archetype."""

    def __init__(self, archetype_type: ArchetypeType):
        super().__init__(TypeCategory.Archetype_INSTANCE)
        self.archetype_type = archetype_type
        self.type_arguments: Dict[str, Type] = {} # Placeholder for future generics

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, ArchetypeInstanceType):
            return False
        return super().__eq__(other) and self.archetype_type == other.archetype_type # Compare archetype_type for equality

    def __hash__(self) -> int:
        return hash((self.category, self.archetype_type))

    def __str__(self) -> str:
        if not self.type_arguments:
            return str(self.archetype_type)

        args = ", ".join(str(arg) for arg in self.type_arguments.values())
        # Jac might not have generic syntax yet, this is forward-looking
        return f"{self.archetype_type}[{args}]"

# Placeholder for EnumType, which could inherit from `ArchetypeType` or be distinct
class EnumType(ArchetypeType): # Enums can be thought of as a special kind of archetype
    """Represents a Jac enumeration type."""
    def __init__(self, name: str, module: Optional[str] = None):
        super().__init__(name, ArchetypeKind.ENUM_CLASS, module)
        self.category = TypeCategory.ENUM # Override category
        self.enum_members: Dict[str, Type] = {} # Enum members often have an implicit or explicit value type

    # __eq__, __hash__, __str__ would be inherited or specialized if needed
```

Key points:
- `ArchetypeType` represents the type of an archetype itself (object, node, etc.)
- `ArchetypeInstanceType` represents an instance of an archetype.
- Both implement proper equality and hash methods for efficient comparison.
- `ArchetypeKind` distinguishes between different kinds of archetypes.
- Placeholder for `EnumType`, which could inherit from `ArchetypeType` or be distinct.
- Type arguments for generic types are included as a placeholder for future Jac features.

### Type Factory

The TypeFactory implements the Factory pattern for creating Jac type objects, ensuring consistent creation and caching:

```mermaid
graph TD
    A[TypeFactory] --> B[create unknown]
    A --> C[create any]
    A --> D[create none]
    %% For Jac's null
    A --> E[create never]
    A --> F[create archetype]
    A --> G[create archetype_instance]
    A --> H[create callable]
    %% For Jac abilities/functions
    A --> I[create union]
    A --> L[create enum]

    B --> J[TypeCache]
    C --> J
    D --> J
    E --> J
    F --> J
    G --> J
    H --> J
    I --> J
    L --> J

    J --> K[returns cached or new type]
```

#### Implementation of Type Factory

```python
class TypeFactory:
    """
    Factory class for creating Jac type objects. Ensures all types are created
    through the cache for memory efficiency.
    """

    @staticmethod
    def unknown() -> UnknownType:
        return TypeCache.get_instance().unknown_type

    @staticmethod
    def any() -> AnyType:
        return TypeCache.get_instance().any_type

    @staticmethod
    def none() -> NoneType: # Corresponds to Jac's 'null'
        return TypeCache.get_instance().none_type

    @staticmethod
    def never() -> NeverType:
        return TypeCache.get_instance().never_type

    @staticmethod
    def archetype_type(name: str, kind: ArchetypeKind, module: Optional[str] = None) -> ArchetypeType:
        # Jac's core built-in types (int, float, str, bool, bytes) might be handled here
        # or treated as special archetypes if they have methods/abilities.
        # For example, if "str" is a built-in archetype:
        if module is None and name in ["int", "float", "str", "bool", "bytes", "object"]: # TODO: Define Jac built-ins
            # This assumes built-ins are cached as ArchetypeTypes
            cached_builtin = TypeCache.get_instance().get_builtin_archetype(name)
            if cached_builtin: # Ensure it has the correct kind, or handle appropriately
                return cached_builtin

        return ArchetypeType(name, kind, module)

    @staticmethod
    def archetype_instance_type(archetype_type: ArchetypeType) -> ArchetypeInstanceType:
        return ArchetypeInstanceType(archetype_type)

    @staticmethod
    def enum_type(name: str, module: Optional[str] = None) -> EnumType:
        # Enums might also be cached if they are frequently reused or have a predefined structure
        return EnumType(name, module)

    @staticmethod
    def callable_type(parameters: List[Tuple[str, Type]], return_type: Type, is_ability: bool = False) -> CallableType:
        # Parameters could be a list of (name, type) tuples or more complex Parameter objects
        # The TypeCache would handle caching of callable types based on signature
        return TypeCache.get_instance().get_callable_type(parameters, return_type, is_ability)

    @staticmethod
    def union(types: List[Type]) -> Type:
        # Filter out duplicates
        unique_types = []
        seen_types: Set[int] = set() # Use set of ids for seen types

        for t in types:
            # Handle nested unions - flatten them
            if isinstance(t, UnionType):
                for nested_type in t.types:
                    # Using id() for seen_types check to handle object identity directly
                    if id(nested_type) not in seen_types:
                        unique_types.append(nested_type)
                        seen_types.add(id(nested_type))
            else:
                if id(t) not in seen_types:
                    unique_types.append(t)
                    seen_types.add(id(t))

        # Special cases for union simplification
        if len(unique_types) == 0:
            return TypeFactory.never()

        if len(unique_types) == 1:
            return unique_types[0]

        # If Any is in the union, the result is Any
        if any(isinstance(t, AnyType) for t in unique_types):
            return TypeFactory.any()

        # If NoneType (Jac null) is present, and other non-None types, it forms an Optional-like union.
        # Further simplification rules can be added (e.g., int | int = int)

        # Create the union through the cache
        return TypeCache.get_instance().get_union_type(unique_types)
```

Key features:
- Provides static methods for creating all fundamental Jac types.
- Delegates to `TypeCache` for efficient storage and reuse of type objects.
- Implements special case handling for types like unions (e.g., flattening, Any propagation).
- Performs normalization (e.g., flattening nested unions).
- `archetype_type` can handle creation of both user-defined and potentially built-in archetypes.
- `callable_type` adapted for Jac's abilities/functions.

### Type Cache

The TypeCache is crucial for memory efficiency, ensuring that identical Jac types share the same object instance:

```python
class TypeCache:
    """
    Centralized cache for Jac type objects to avoid creating duplicate
    instances of the same type. This is key to memory efficiency.
    """

    _instance = None

    @classmethod
    def get_instance(cls) -> 'TypeCache': # Forward reference for TypeCache
        if cls._instance is None:
            cls._instance = TypeCache()
        return cls._instance

    def __init__(self):
        if TypeCache._instance is not None:
            raise RuntimeError("TypeCache is a singleton, use get_instance()")
        # Cache for built-in archetype-like types (int, str, etc.)
        self._builtin_archetypes: Dict[str, ArchetypeType] = {}

        # Cache for user-defined ArchetypeTypes (keyed by module and name)
        self._archetype_types: Dict[Tuple[Optional[str], str], ArchetypeType] = {}

        # Cache for EnumTypes (keyed by module and name)
        self._enum_types: Dict[Tuple[Optional[str], str], EnumType] = {}

        # Cache for union types (using frozensets of type IDs as keys)
        self._union_types: Dict[frozenset[int], UnionType] = {}

        # Cache for callable types (keyed by a tuple representing their signature)
        # Signature: (param_types_tuple, return_type_id, is_ability_bool)
        self._callable_types: Dict[Tuple[Tuple[int, ...], int, bool], CallableType] = {}

        # Singleton types
        self.unknown_type = UnknownType()
        self.any_type = AnyType()
        self.none_type = NoneType() # Jac's null
        self.never_type = NeverType()

        # Initialize common built-in types for Jac
        self._initialize_builtin_jac_types()

    def _initialize_builtin_jac_types(self) -> None:
        """Initialize cache with common Jac built-in types."""
        # Jac's primitive types. These are often represented as archetypes.
        # The ArchetypeKind for these would be specific, e.g., ArchetypeKind.BUILTIN_PRIMITIVE
        # or they can use existing kinds if they behave like them (e.g. ArchetypeKind.CLASS for string methods)
        builtin_names_kinds = {
            "int": ArchetypeKind.CLASS, # Assuming int has some 'class-like' properties or for consistency
            "float": ArchetypeKind.CLASS,
            "str": ArchetypeKind.CLASS,
            "bool": ArchetypeKind.CLASS,
            "bytes": ArchetypeKind.CLASS,
            "list": ArchetypeKind.CLASS, # If list is a built-in generic type
            "dict": ArchetypeKind.CLASS, # If dict is a built-in generic type
            "type": ArchetypeKind.CLASS, # The type of types themselves
            "object": ArchetypeKind.CLASS # A potential base object type for Jac archetypes
        }
        for name, kind in builtin_names_kinds.items():
            # Create as ArchetypeType for now. Details of their members/abilities would be defined elsewhere.
            self._builtin_archetypes[name] = ArchetypeType(name, kind, module="builtin")

        # `null` is represented by NoneType, `any` by AnyType, etc.

    def get_builtin_archetype(self, name: str) -> Optional[ArchetypeType]:
        """Get a cached built-in Jac archetype-like type."""
        return self._builtin_archetypes.get(name)

    def get_archetype_type(self, name: str, kind: ArchetypeKind, module: Optional[str] = None) -> ArchetypeType:
        key = (module, name)
        if key in self._archetype_types:
            # TODO: Add consistency check for 'kind' if an archetype is re-requested with a different kind
            return self._archetype_types[key]

        new_arch_type = ArchetypeType(name, kind, module)
        self._archetype_types[key] = new_arch_type
        return new_arch_type

    def get_enum_type(self, name: str, module: Optional[str] = None) -> EnumType:
        key = (module, name)
        if key in self._enum_types:
            return self._enum_types[key]

        new_enum_type = EnumType(name, module)
        self._enum_types[key] = new_enum_type
        return new_enum_type

    def get_union_type(self, types: List[Type]) -> UnionType:
        """Get a cached union type or create a new one."""
        # Remove duplicates and normalize (e.g. Any | T = Any, T | Never = T)
        # Simplified: Actual implementation would handle more cases
        unique_types_list = list(dict.fromkeys(types)) # Preserves order, removes duplicates

        if not unique_types_list:
            return self.never_type # Or handle as error
        if len(unique_types_list) == 1:
            # This step was in TypeFactory.union, ensure it's consistent or primarily here.
            # return unique_types_list[0] # This line might be problematic if factory handles it.
            pass # Let the factory decide if it returns the single type or a UnionType of one

        # Sort by category and then by a stable attribute (e.g., hash or string form) to ensure consistent key ordering
        # This is crucial for cache key stability.
        unique_types_list.sort(key=lambda t: (t.category.value, str(t))) # Example sorting

        # Create a frozenset of type IDs as the cache key
        # Using id() assumes type objects are immutable once created and cached for this to be safe
        key = frozenset(id(t) for t in unique_types_list)

        if key in self._union_types:
            return self._union_types[key]

        new_union = UnionType(unique_types_list)
        self._union_types[key] = new_union
        return new_union

    def get_callable_type(self, parameters: List[Tuple[str, Type]], return_type: Type, is_ability: bool) -> CallableType:
        """Get a cached callable type or create a new one."""
        # Create a stable cache key. Parameter names usually don't affect signature for caching.
        # Param types are important, their order, and the return type.
        param_type_ids = tuple(id(ptype) for _, ptype in parameters)
        key = (param_type_ids, id(return_type), is_ability)

        if key in self._callable_types:
            return self._callable_types[key]

        # Create ParameterType objects if your CallableType expects them
        # For now, assuming CallableType constructor can handle List[Tuple[str, Type]] or similar
        new_callable = CallableType(parameters, return_type, is_ability=is_ability)
        self._callable_types[key] = new_callable
        return new_callable
```

Key points:
- Implements the Singleton pattern to ensure a single cache instance for all Jac types.
- Maintains separate caches for different Jac type categories (built-ins, archetypes, enums, unions, callables).
- Uses ID-based caching for complex types like unions and callables to ensure canonical representation.
- Pre-initializes common built-in Jac types (like `int`, `str`, `bool`, `null` via `NoneType`) for efficiency.
- Provides getter methods that first check the cache before creating a new type instance.

### Type Relationships

Type relationships determine compatibility between Jac types. Key operations include checking for subtyping (`is_subtype`) and assignability (`is_assignable_to`).

```mermaid
graph TD
    A[TypeRelationship] --> B[is_subtype]
    A --> C[is_assignable_to]
    %% Often similar to is_subtype but can have nuances

    B --> D{source == AnyType?}
    D -->|Yes| E[return True]
    D -->|No| F{target == AnyType?}
    F -->|Yes| E
    F -->|No| G{source == NeverType?}
    G -->|Yes| E
    G -->|No| H{source and target same category?}
    H -->|Yes| I[handle specific Jac category (Archetype, Enum, Callable)]
    H -->|No| J{source == UnionType?}
    J -->|Yes| K[check all source types against target]
    J -->|No| L{target == UnionType?}
    L -->|Yes| M[check source against any target type]
    L -->|No| N[Handle NoneType (Jac null) assignability, e.g., to Optional-like unions]
    N --> O[return False]
    %% Default
```

#### Implementation of Type Relationships for Jac

```python
class TypeRelationship:
    """
    Class that handles Jac type relationships like subtyping, assignability, etc.
    This is a key part of an efficient type checking system.
    """

    @staticmethod
    def is_subtype(source: Type, target: Type) -> bool:
        """
        Determines if source is a subtype of target in Jac.
        This is a foundational version; a full implementation would be more complex,
        especially with generics, protocols, etc.
        """
        # Any type is compatible with any other type (both ways)
        if isinstance(source, AnyType) or isinstance(target, AnyType):
            return True

        # Never type is a subtype of any type
        if isinstance(source, NeverType):
            return True

        # Nothing is a subtype of Never (except Never itself, handled above)
        if isinstance(target, NeverType):
            return False

        # Jac's null (NoneType) handling
        if isinstance(source, NoneType):
            if isinstance(target, NoneType): # null is a subtype of null
                return True
            if isinstance(target, UnionType): # null is a subtype of Union{T, null}
                return any(isinstance(t, NoneType) for t in target.types)
            # Add rules if specific archetypes are inherently nullable in Jac
            # Otherwise, null is not a subtype of a non-union, non-NoneType type.
            return False

        # Same type categories - delegate to specific Jac type checks
        if source.category == target.category:
            if isinstance(source, UnionType) and isinstance(target, UnionType): # Should be handled by Union specific rules or below
                # Every type in source union must be a subtype of at least one type in target union (more complex check needed)
                # Simplified: For S = U(s1,s2), T = U(t1,t2), is_subtype(S,T) if for all si, exists tj such that is_subtype(si, tj)
                # This is not quite right. is_subtype(A|B, C|D) iff is_subtype(A,C|D) and is_subtype(B,C|D)
                # For now, defer to general union rules below.
                pass # Fall through to general union handling

            if isinstance(source, ArchetypeType) and isinstance(target, ArchetypeType):
                # Check archetype hierarchy (including kind compatibility if relevant in Jac)
                if source == target: # Same archetype definition
                    return True

                # Check base archetypes recursively
                # This needs a cycle detection mechanism for robust implementation
                # For now, simple recursive check:
                for base in source.bases:
                    if TypeRelationship.is_subtype(base, target):
                        return True
                # TODO: Consider Jac-specific rules for ArchetypeKind compatibility (e.g. node vs object)
                return False

            if isinstance(source, ArchetypeInstanceType) and isinstance(target, ArchetypeInstanceType):
                # Delegate to ArchetypeType check, ignoring generics for now
                # With generics, type arguments would need to be checked based on variance
                return TypeRelationship.is_subtype(source.archetype_type, target.archetype_type)

            if isinstance(source, EnumType) and isinstance(target, EnumType):
                return source == target # Enums are typically subtypes of themselves only

            if isinstance(source, CallableType) and isinstance(target, CallableType):
                # Check Jac callable compatibility (contravariant in args, covariant in return)
                # Differentiate between abilities and functions if their subtyping rules differ
                if source.is_ability != target.is_ability: # Assuming abilities and functions are not directly interchangeable unless specified
                    # This rule might be too strict; depends on Jac semantics
                    pass # For now, allow if signatures match, further Jac rules might apply

                # Return type must be a subtype (covariant)
                if not TypeRelationship.is_subtype(source.return_type, target.return_type):
                    return False

                # Parameters must be compatible (contravariant)
                if len(source.parameters) != len(target.parameters):
                    return False # Arity mismatch

                for s_param, t_param in zip(source.parameters, target.parameters):
                    # Jac param representation: (_, s_param_type) = s_param ; (_, t_param_type) = t_param
                    s_param_type = s_param[1] # Assuming (name, type) tuple
                    t_param_type = t_param[1] # Assuming (name, type) tuple
                    if not TypeRelationship.is_subtype(t_param_type, s_param_type): # Contravariance
                        return False
                return True

        # Union type as source - each component of source must be a subtype of target
        if isinstance(source, UnionType):
            return all(TypeRelationship.is_subtype(t, target) for t in source.types)

        # Union type as target - source must be a subtype of at least one component of target
        if isinstance(target, UnionType):
            return any(TypeRelationship.is_subtype(source, t) for t in target.types)

        # Different type categories that aren't explicitly handled are not compatible
        # e.g. ArchetypeInstanceType is not a subtype of CallableType unless special rules apply
        return False

    @staticmethod
    def is_assignable_to(source: Type, target: Type) -> bool:
        """
        Determines if a value of 'source' type can be assigned to a variable of 'target' type in Jac.
        Often, this is the same as is_subtype, but can differ (e.g. with variance, or specific language rules).
        For now, let's assume it's largely similar to is_subtype for Jac.
        """
        # Basic assignability is often subtyping
        if TypeRelationship.is_subtype(source, target):
            return True

        # Special assignability rules for Jac could be added here
        # e.g. assigning an int literal to a float variable might be allowed even if int is not strictly a subtype of float
        # For now, no additional rules beyond subtyping.

        return False
```

Key principles for Jac type relationships:
- `Any` type is compatible with everything.
- `Never` type is a subtype of everything.
- `NoneType` (Jac `null`) handling for unions (representing optional types) and direct nullability.
- Union types follow logical set operations for subtyping.
- `ArchetypeType`s follow inheritance hierarchies defined by `bases`. Compatibility between different `ArchetypeKind`s needs definition based on Jac semantics.
- `CallableType`s (Jac abilities/functions) follow standard variance rules: contravariant in parameters, covariant in return types.
- `EnumType`s are generally only compatible with themselves.
- `is_assignable_to` can extend `is_subtype` with Jac-specific assignment rules if needed.

### Type Narrowing

Type narrowing is a powerful feature, allowing the Jac type checker to refine types based on control flow analysis. This is particularly important for Jac's `match` statements and conditional logic.

```mermaid
sequenceDiagram
    participant JacCode as Jac Code
    participant CFG as Control Flow Graph
    participant Analyzer as Type Analyzer
    participant Narrower as Type Narrower

    JacCode->>CFG: Parse into branches (e.g., if/else, match cases)
    CFG->>Analyzer: Analyze each branch
    Analyzer->>Narrower: Request type narrowing for variables
    Note over Narrower: Analyze conditions (e.g., `check x is type`, `match x with pattern`, `if x != null`)
    Note over Narrower: Apply Jac-specific narrowing rules
    Narrower-->>Analyzer: Return narrowed type(s) for variables in the current scope
    Analyzer->>CFG: Update type information within the specific branch/scope
```

#### Implementation of Type Narrowing for Jac

```python
class TypeNarrower:
    """
    Class that handles type narrowing for Jac based on control flow analysis.
    This will be crucial for Jac features like `match` statements and `check` expressions.
    """

    @staticmethod
    def narrow_type_from_check(original_type: Type, asserted_type: Type, is_positive_check: bool = True) -> Type:
        """Narrows a type based on a Jac `check expr is type_expr` or similar assertion.
        `is_positive_check` is True if the assertion is `expr is type`, False if `expr is not type` (or equivalent).
        """
        # If the original type is Any, narrow to the asserted type if positive check
        if isinstance(original_type, AnyType):
            return asserted_type if is_positive_check else TypeFactory.any() # Or a more refined 'not asserted_type' if possible

        if is_positive_check:
            # If original_type is already a subtype of asserted_type, no change (or return original_type)
            if TypeRelationship.is_subtype(original_type, asserted_type):
                return original_type # Or potentially asserted_type if it's more specific and a subtype

            # If asserted_type is a subtype of original_type, then the new type is asserted_type
            if TypeRelationship.is_subtype(asserted_type, original_type):
                return asserted_type

            # If original_type is a union, filter the union
            if isinstance(original_type, UnionType):
                narrowed_types = [t for t in original_type.types if TypeRelationship.is_subtype(t, asserted_type)]
                if not narrowed_types:
                    return TypeFactory.never() # This branch is unreachable if assertion holds
                return TypeFactory.union(narrowed_types)

            # If no direct subtype relation but they could overlap (e.g. protocol check)
            # This needs more sophisticated logic, potentially an intersection type or just asserted_type if valid
            # For now, if they are not related by subtyping, a positive check might mean this path is dead (Never) or it's the asserted_type.
            # This depends on Jac's exact semantics for `check`.
            # A safe bet if original and asserted are compatible might be asserted_type.
            if TypeRelationship.is_subtype(original_type, asserted_type) or TypeRelationship.is_subtype(asserted_type, original_type): # Simplified check for some relation
                return asserted_type
            return TypeFactory.never() # If no clear path to reconcile, assume check makes path unreachable or type is asserted_type

        else: # Negative check (e.g., expr is not TypeX)
            if isinstance(original_type, UnionType):
                # Remove types that are subtypes of asserted_type from the union
                narrowed_types = [t for t in original_type.types if not TypeRelationship.is_subtype(t, asserted_type)]
                if not narrowed_types:
                    return TypeFactory.never()
                return TypeFactory.union(narrowed_types)

            # If original_type is a subtype of asserted_type, then this path means it's Never
            if TypeRelationship.is_subtype(original_type, asserted_type):
                return TypeFactory.never()

            return original_type # Cannot narrow further with this negative check

    @staticmethod
    def narrow_type_from_truthiness(original_type: Type, is_truthy_branch: bool) -> Type:
        """Narrows a type based on a truthiness check in Jac (e.g., in an `if some_var:` context)."""
        if isinstance(original_type, AnyType):
            return original_type # Cannot narrow Any based on truthiness alone

        if isinstance(original_type, UnionType):
            if is_truthy_branch:
                # Remove NoneType (Jac null) and other falsy types if defined for Jac (e.g. empty string, 0 for numbers)
                # For simplicity, just removing NoneType here.
                narrowed_types = [t for t in original_type.types if not isinstance(t, NoneType)]
                # TODO: Add rules for other Jac-specific falsy types (e.g. empty collections if they are falsy)
                if not narrowed_types:
                    return TypeFactory.never() # e.g. if original_type was just NoneType
                return TypeFactory.union(narrowed_types)
            else: # is_falsy_branch
                # If original type could be NoneType, and we are in falsy branch, it *could* be NoneType
                # Or it could be another falsy value (empty string, 0, etc.)
                # A full implementation would identify all types in the union that *can* be falsy.
                # If NoneType is the only falsy type in the union, narrow to NoneType.
                has_none = any(isinstance(t, NoneType) for t in original_type.types)
                # This is a simplification: if null is possible, and it's a falsy branch, what remains?
                # It could be *only* null, or other falsy values. If only null, narrow to null.
                # If other types in union could also be falsy (e.g. int 0, empty str), it's more complex.
                # For now, if None is present, and it's a falsy branch, we can't definitively say it *is* None unless other types are guaranteed truthy.
                # A safe bet is to return the original type unless more specific rules can apply.
                if has_none and all(not isinstance(t, NoneType) or True for t in original_type.types): # Simplified: if None is one of options.
                    # If we want to narrow to NoneType, we need to ensure other parts of union are not falsy.
                    # Example: Union[int, NoneType]. If false, could be 0 or None. Not just None.
                    # If only NoneType makes it falsy, then it is NoneType.
                    potential_falsy = [t for t in original_type.types if isinstance(t, NoneType) or TypeRelationship.is_subtype(t,TypeFactory.archetype_instance_type(TypeFactory.archetype_type("int",ArchetypeKind.CLASS))) ] # placeholder for actual falsy check
                    if len(potential_falsy) == 1 and isinstance(potential_falsy[0], NoneType): # if None is the only way it can be false from the union members
                        return TypeFactory.none()
                return original_type # Return original, too complex to simplify generally here

        # Single type (not union)
        if not is_truthy_branch: # Falsy branch
            # If original_type itself can be falsy (e.g. int, str, bool which can be 0, "", False)
            # or if it's NoneType
            if isinstance(original_type, NoneType): # if it is None, and branch is falsy, it remains None.
                return original_type
            # If it is bool and it's False. This is tricky without knowing if it *is* bool.
            # Jac needs defined truthy/falsy rules for its types.
            # For now, if it is not a union and in a falsy branch, we cannot easily narrow it further to Never unless the type is always truthy.
            # Example: if `obj: MyObject` and `if not obj:`, if MyObject instances are always truthy, then this is Never.
            pass # Needs more rules

        return original_type

    @staticmethod
    def narrow_type_from_null_check(original_type: Type, is_null: bool) -> Type:
        """Narrows a type based on a null check (e.g., `if var is null` or `if var is not null`)."""
        if isinstance(original_type, AnyType):
            return TypeFactory.none() if is_null else TypeFactory.any() # If any is null, it becomes null. If not null, remains any.

        if isinstance(original_type, UnionType):
            if is_null: # Variable is null
                if any(isinstance(t, NoneType) for t in original_type.types):
                    return TypeFactory.none() # If null is a possibility, it must be null
                else:
                    return TypeFactory.never() # Original type couldn't be null, so this path is dead
            else: # Variable is not null
                narrowed_types = [t for t in original_type.types if not isinstance(t, NoneType)]
                if not narrowed_types:
                    return TypeFactory.never() # Should not happen if original union was valid (e.g. not just NoneType)
                return TypeFactory.union(narrowed_types)
        else: # Not a UnionType
            if is_null: # Variable is null
                return TypeFactory.none() if isinstance(original_type, NoneType) or TypeRelationship.is_subtype(TypeFactory.none(), original_type) else TypeFactory.never()
            else: # Variable is not null
                return TypeFactory.never() if isinstance(original_type, NoneType) else original_type
```

Key Jac narrowing strategies:
- Type narrowing based on Jac's `check expression is type_expression` (or equivalent assertion/matching mechanism).
- Type narrowing based on truthiness checks in conditional statements (`if`, `while`, etc.), considering Jac's definition of truthy/falsy values.
- Type narrowing based on `null` checks (e.g., `if var is null` or `if var is not null`).
- Narrowing union types by filtering components based on the condition.
- Identifying unreachable code branches by narrowing a type to `Never`.
- **Match statement narrowing**: Jac's `match` statement will be a primary driver for type narrowing. Each `case` pattern will provide strong type information for the matched variable within that case's scope.

## Flow and Integration

### Type Checking Process for Jac

The overall type checking process for Jac will integrate into its existing compiler passes. It involves several stages:

```mermaid
graph TB
    A[Parse Jac Source Code] --> B[Build Jac AST]
    B --> C[Symbol Table Construction (Sema Pass)]
    C --> D[Evaluate Types (within TypeCheckPass or separate pass)]
    D --> E[Check Type Compatibility & Rules (TypeCheckPass)]
    E --> F[Generate Diagnostics]

    G[Jac Type Model] --> D
    G --> E
    H[Symbol Table] --> C
    H --> D
    H --> E
```

#### Implementation of the Main Type Checking Pass for Jac

In Jac, the main analyzer will likely be implemented as a compiler pass (e.g., `TypeCheckPass`) that runs after parsing and symbol table construction.

```python
# Example structure for a Jac TypeCheckPass
# This would reside in jaclang/compiler/passes/type_check_pass.py

from jaclang.compiler.passes.uni_pass import UniPass
# Assume other necessary imports for Jac AST nodes, SymbolTable, Type Model, Diagnostics, etc.
# from jaclang.compiler.absyntree import AstNode (or specific node types)
# from ..analysis.symbol_table import SymbolTable
# from ..typemodel.types import Type, ArchetypeType, CallableType # etc.
# from ..typemodel.type_factory import TypeFactory
# from ..analysis.type_evaluator import TypeEvaluator
# from ..analysis.type_narrower import TypeNarrower
# from ..utils.diagnostics import Diagnostic, DiagnosticSeverity, DiagnosticCollection

class TypeCheckPass(UniPass):
    """
    Jac Type Checker Pass. Relies on a symbol table already being populated
    (e.g., by a preceding SymTabPass or during the same pass if integrated).
    """

    def __init__(self, ir: AstNode, sym_tab: SymbolTable, diag: DiagnosticCollection, config_options=None):
        super().__init__(ir=ir) # Initialize UniPass, ir is the AST root
        self.sym_tab = sym_tab
        self.diag = diag
        self.type_cache = TypeCache.get_instance()
        self.type_factory = TypeFactory # Static methods, no instance needed typically
        # config_options could hold type system strictness flags, etc.
        self.config_options = config_options or {}
        self.type_evaluator = TypeEvaluator(self.sym_tab, self.type_cache, self.diag, self.type_factory)
        self.type_checker_core = TypeCheckerCore(self.sym_tab, self.diag, self.type_cache, self.type_factory, self.config_options)

    def enter_node(self, node: AstNode):
        # Entry point for visiting each node if using a visitor pattern inherited from UniPass
        # Type evaluation and checking can happen on specific nodes or primarily on exit
        pass

    def exit_node(self, node: AstNode):
        # Main logic for type checking often happens on node exit, after children are processed.
        # This depends on the specific AST node type.

        # Example: Check assignment statements
        if isinstance(node, AssignmentStmt): # Replace with actual Jac AST node for assignment
            target_type = self.type_evaluator.get_type(node.target) # Get type of assignment target
            value_type = self.type_evaluator.get_type(node.value)   # Get type of assigned value
            self.type_checker_core.check_assignment(value_type, target_type, node) # Pass node for error reporting location

        # Example: Check function/ability calls
        elif isinstance(node, CallExpr): # Replace with actual Jac AST node for calls
            # ... logic to get callable type and argument types ...
            # self.type_checker_core.check_call(callable_type, arg_types, node)
            pass

        # Example: Check function/ability definitions for return type consistency
        elif isinstance(node, FunctionDef): # Replace with actual Jac AST node for function/ability def
            # declared_return_type = self.type_evaluator.get_type_from_annotation(node.return_annotation)
            # inferred_return_type = self.type_evaluator.infer_return_type_from_body(node.body)
            # self.type_checker_core.check_return_types(inferred_return_type, declared_return_type, node)
            pass

        # ... other checks for various Jac AST nodes ...

    # The `run` method might be inherited from UniPass or overridden.
    # def run(self) -> AstNode:
    #     self.traverse(self.ir) # UniPass might provide traverse
    #     return self.ir

# Placeholder for TypeCheckerCore which would contain the actual checking logic (e.g. check_assignment)
class TypeCheckerCore:
    def __init__(self, sym_tab, diag, type_cache, type_factory, config_options):
        self.sym_tab = sym_tab
        self.diag = diag
        self.type_cache = type_cache
        self.type_factory = type_factory
        self.config_options = config_options

    def check_assignment(self, value_type: Type, target_type: Type, error_node: AstNode) -> None:
        if not TypeRelationship.is_assignable_to(value_type, target_type):
            self.diag.add(
                Diagnostic(f"Cannot assign type '{value_type}' to '{target_type}'.",
                           DiagnosticSeverity.ERROR, error_node.loc)
            )
    # ... other checking methods: check_call, check_binary_op, etc.


# The Analyzer class from the original doc is effectively distributed into:
# 1. The Jac Parser (already exists)
# 2. SymbolTable pass/logic (may exist or need enhancement)
# 3. TypeCheckPass (this class)
# 4. TypeEvaluator (called by TypeCheckPass)
```

The `TypeCheckPass` would:
- Traverse the Jac AST.
- Use the `SymbolTable` to resolve names to their declarations and types.
- Use the `TypeEvaluator` to determine the types of expressions.
- Use the `TypeCheckerCore` (or similar helper) with `TypeRelationship` to validate type compatibility for assignments, operations, calls, etc.
- Generate `Diagnostics` (errors/warnings) for type mismatches.

### Parser Integration for Jac

Jac already has its own parser (defined by `jac.lark` and implemented in `jaclang.compiler.parser`). The type checker will consume the AST generated by this existing parser. No new parser needs to be built for type checking itself, but the AST structure must be understood by the type checking passes.

```python
# This section is informational, as Jac's parser is pre-existing.
# Example of how Jac parsing might be invoked (conceptual):
# from jaclang.compiler.parser import JacParser
# from jaclang.compiler.absyntree import AstNode

# source_code = \"\"
# walker my_walker {
#     has name: str = \"Jacy\";
#     can greet with entry {
#         std.out(f\"Hello, {self.name}\");
#     }
# }
# \"\"\"
#
# def parse_jac_code(source_code: str, file_path: Optional[str] = None) -> Optional[AstNode]:
#     parser_instance = JacParser(mod_path="", input_file="", source_string=source_code)
#     ast_root = parser_instance.ir # Access the intermediate representation (AST)
#     if parser_instance.errors:
#         for error in parser_instance.errors:
#             print(f"Parse Error: {error}") # Handle errors appropriately
#         return None
#     return ast_root

# The type checker would receive `ast_root` after this stage.
```

### Jac Type Evaluator Implementation

The type evaluator is responsible for determining the types of expressions and other AST nodes within the Jac code. It will heavily rely on the `SymbolTable`.

```python
# Resides in jaclang/compiler/analysis/type_evaluator.py

# from jaclang.compiler.absyntree import AstNode # Base AST node
# from .symbol_table import SymbolTable, Symbol
# from ..typemodel.types import Type, CallableType, ArchetypeType, ArchetypeInstanceType, AnyType, UnknownType, NoneType
# from ..typemodel.type_factory import TypeFactory
# from ..typemodel.type_cache import TypeCache
# from ..utils.diagnostics import DiagnosticCollection
# from .type_narrower import TypeNarrower

class TypeEvaluator:
    """
    Evaluates the types of expressions and other relevant nodes in Jac code.
    Operates in conjunction with a SymbolTable and TypeNarrower.
    """

    def __init__(self, sym_tab: SymbolTable, type_cache: TypeCache, diag: DiagnosticCollection, type_factory: TypeFactory):
        self.sym_tab = sym_tab
        self.type_cache = type_cache
        self.diag = diag # For reporting errors during type evaluation if necessary
        self.type_factory = type_factory
        self.type_narrower = TypeNarrower() # Can be used for context-sensitive type evaluation
        self.current_scope_uid: Optional[str] = None # UID of the current symbol table scope

    def get_type(self, node: AstNode) -> Type:
        """Main method to get the type of an AST node."""
        # Dispatch to specific visitor methods based on Jac AST node type
        # This would use a visitor pattern, e.g., self.visit(node)
        # For simplicity, a direct mapping or if/isinstance chain:

        if isinstance(node, NameAtom): # Example: Jac variable name or archetype name
            return self._visit_name(node)
        elif isinstance(node, LiteralAtom): # Example: Jac int, float, str, bool, null literals
            return self._visit_literal(node)
        elif isinstance(node, BinaryExpr): # Example: +, -, *, /, and, or, etc.
            return self._visit_binary_expr(node)
        elif isinstance(node, CallExpr): # Example: func_call(), ability_call()
            return self._visit_call_expr(node)
        elif isinstance(node, AtomTrailer): # Example: x.y, x[y]
             return self._visit_atom_trailer(node)
        # ... many other Jac expression types ...

        # For nodes whose type isn't directly evaluated or is complex (e.g., statements)
        # this method might return a placeholder or raise an error.
        # It might be better to have evaluate_expression_type(node) instead of a generic get_type.
        self.diag.add_warning(f"Type evaluation not implemented for Jac AST node: {type(node).__name__}", node.loc)
        return self.type_factory.unknown() # Default to Unknown or Any for unhandled nodes

    def _visit_name(self, node: NameAtom) -> Type: # Replace NameAtom with Jac's AST name node
        """Determine the type of a name (variable, archetype, etc.)."""
        name_str = node.value # Assuming node has a .value or .name attribute
        symbol = self.sym_tab.lookup(name_str, scope_uid=self.current_scope_uid)
        if not symbol:
            self.diag.add_error(f"Name '{name_str}' not found.", node.loc)
            return self.type_factory.unknown()

        # TODO: Type narrowing might influence the symbol's perceived type here
        # narrowed_type = self.type_narrower.get_narrowed_type(symbol, self.current_control_flow_context)
        # if narrowed_type: return narrowed_type

        return symbol.type if symbol.type else self.type_factory.unknown() # Symbol should have a type

    def _visit_literal(self, node: LiteralAtom) -> Type: # Replace LiteralAtom with Jac's literal node
        # Based on Jac token types (INT, FLOAT, STRING, BOOL_TRUE/FALSE, NULL)
        if node.is_int: return self.type_factory.archetype_instance_type(self.type_cache.get_builtin_archetype("int"))
        if node.is_float: return self.type_factory.archetype_instance_type(self.type_cache.get_builtin_archetype("float"))
        if node.is_string: return self.type_factory.archetype_instance_type(self.type_cache.get_builtin_archetype("str"))
        if node.is_bool: return self.type_factory.archetype_instance_type(self.type_cache.get_builtin_archetype("bool"))
        if node.is_null: return self.type_factory.none()
        # if node.is_bytes: return self.type_factory.archetype_instance_type(self.type_cache.get_builtin_archetype("bytes"))
        return self.type_factory.unknown()

    def _visit_binary_expr(self, node: BinaryExpr) -> Type:
        left_type = self.get_type(node.left)
        right_type = self.get_type(node.right)
        op = node.op.value # Assuming op has a value like '+', '-', 'and'

        # TODO: Implement operator type resolution based on Jac's rules
        # This would involve checking for overloaded operators (dunder methods if Jac has them) or predefined operator rules.
        # e.g., int + int -> int; str + str -> str; int + float -> float
        # For now, a placeholder:
        if isinstance(left_type, AnyType) or isinstance(right_type, AnyType):
            return self.type_factory.any()
        if op == '+':
            if TypeRelationship.is_subtype(left_type, self.type_cache.get_builtin_archetype("int")) and \
               TypeRelationship.is_subtype(right_type, self.type_cache.get_builtin_archetype("int")):\n                return self.type_cache.get_builtin_archetype("int")
            # ... other + rules
        # ... other operators ...
        self.diag.add_error(f"Operator '{op}' not supported for types '{left_type}' and '{right_type}'.", node.loc)
        return self.type_factory.unknown()

    def _visit_call_expr(self, node: CallExpr) -> Type:
        # Callee could be a name, or something more complex like obj.method
        callee_type = self.get_type(node.callee)

        if not isinstance(callee_type, CallableType):
            # Could be an archetype instantiation (constructor call)
            if isinstance(callee_type, ArchetypeType):
                # This is an archetype constructor call, e.g. Node(), MyObject()
                # Type check constructor arguments against __init__ if defined, or member initializers
                # For now, return an instance of the archetype
                return self.type_factory.archetype_instance_type(callee_type)

```

## Implementation Guide

### Getting Started

To begin implementing this type checker:

1. **Set up the project structure** as outlined above
2. **Implement the core type model** first
3. **Add the parser integration** using Python's built-in `ast` module
4. **Implement the binder and symbol table**
5. **Build the type evaluator**
6. **Add the type checker**
7. **Implement diagnostics reporting**

### Key Algorithms

Some of the most important algorithms in the type checker:

#### Subtyping Algorithm

```python
def is_subtype(source: Type, target: Type, visited: Set[Tuple[Type, Type]] = None) -> bool:
    """
    Determine if source is a subtype of target.
    The visited set prevents infinite recursion with recursive types.
    """
    if visited is None:
        visited = set()

    # Check for cycles in recursive types
    pair = (id(source), id(target))
    if pair in visited:
        return True  # Assume true for recursive types

    visited.add(pair)

    try:
        # Any type is compatible with any other type
        if isinstance(source, AnyType) or isinstance(target, AnyType):
            return True

        # Never type is a subtype of any type
        if isinstance(source, NeverType):
            return True

        # Any type is a supertype of Never
        if isinstance(target, NeverType):
            return False

        # Same type categories
        if source.category == target.category:
            # Handle specific type category checks
            # ...

        # Type categories don't match, but special cases might apply
        # ...

        # Default to false for incompatible types
        return False

    finally:
        # Clean up the visited set
        visited.remove(pair)
```

#### Type Narrowing with Flow Sensitivity

```python
def narrow_types_in_condition(
    condition: ast.expr,
    original_types: Dict[str, Type],
    true_branch: bool
) -> Dict[str, Type]:
    """Narrow types based on a condition expression."""
    narrowed_types = original_types.copy()

    # Check for isinstance() calls
    if (isinstance(condition, ast.Call) and
        isinstance(condition.func, ast.Name) and
        condition.func.id == "isinstance" and
        len(condition.args) == 2):

        # Get the variable name
        if isinstance(condition.args[0], ast.Name):
            var_name = condition.args[0].id

            # Only narrow if we know the variable's type
            if var_name in narrowed_types:
                original_type = narrowed_types[var_name]

                # Get the class being checked against
                # (This would be more complex in reality)
                class_type = None  # Determine from condition.args[1]

                if class_type:
                    # Apply narrowing
                    if true_branch:
                        narrowed_types[var_name] = TypeNarrower.narrow_type_from_isinstance(
                            original_type, class_type
                        )
                    else:
                        # Negative narrowing is more complex
                        pass

    # Check for truthiness checks
    if isinstance(condition, ast.Name):
        var_name = condition.id

        # Only narrow if we know the variable's type
        if var_name in narrowed_types:
            original_type = narrowed_types[var_name]

            # Apply truthiness narrowing
            narrowed_types[var_name] = TypeNarrower.narrow_type_from_truth(
                original_type, is_truthy=true_branch
            )

    return narrowed_types
```

### Testing Strategy

Implement testing at multiple levels:

1. **Unit tests** for individual components
2. **Integration tests** for the type checking pipeline
3. **Sample code tests** with known type errors and correct behavior

```python
def test_type_narrowing():
    """Test the type narrowing functionality."""
    # Create a factory and narrower
    factory = TypeFactory
    narrower = TypeNarrower()

    # Create test types
    int_class = factory.class_type("int")
    str_class = factory.class_type("str")
    int_instance = factory.instance_type(int_class)
    str_instance = factory.instance_type(str_class)

    # Create a union type
    union_type = factory.union([int_instance, str_instance])

    # Test narrowing with isinstance
    narrowed_type = narrower.narrow_type_from_isinstance(union_type, int_class)

    # Check that the type was narrowed correctly
    assert isinstance(narrowed_type, InstanceType)
    assert narrowed_type.class_type == int_class
```

## Comparison with Other Type Checkers

This table compares our type checker with existing Python type checkers:

| Feature | Our Type Checker | mypy | pyright |
|---------|-----------------|------|---------|
| Implementation Language | Python | Python | TypeScript |
| Type Representation | Object-based with caching | Structural | Object-based with caching |
| Type Narrowing | Sophisticated flow-sensitive | Basic | Sophisticated flow-sensitive |
| Performance | Optimized for large codebases | Good for small-medium | Excellent for large codebases |
| Protocol Support | Full structural typing | Nominal with limited structural | Full structural typing |
| Type Inference | Context-aware | Limited | Context-aware |
| Memory Efficiency | High (uses caching) | Medium | High (uses caching) |
| Incremental Checking | Yes | Yes | Yes |

## Conclusion

This document outlines the architecture and implementation details for a Jac type checker inspired by Pyright's efficient approach. By adopting Pyright's type representation system, aggressive caching, and sophisticated type narrowing, but implementing it in Python, we can create a type checker that combines the performance advantages of Pyright with the ease of development and integration that comes from using Python.

The key innovations in this approach include:

1. An efficient object-based type representation system
2. Aggressive type caching to minimize memory usage
3. Sophisticated flow-sensitive type narrowing
4. Full support for structural typing through protocols
5. Context-aware type inference

Next steps for implementation would involve developing the core type model, followed by the parser integration, symbol table, type evaluator, and checker components. With proper attention to performance optimization techniques in Python, this architecture can provide an excellent foundation for a high-performance Python type checker.

## Advanced Features

### Protocol Support (Structural Typing) for Jac

While Jac may not have an explicit `protocol` keyword like Python, its type system can still support structural typing. This means an archetype could be considered compatible with an expected structure if it possesses the necessary members (`has` variables) and abilities (`can` declarations) with compatible signatures, regardless of nominal inheritance.

```python
# This is a conceptual adaptation. Jac might not have a separate ProtocolType.
# Instead, structural compatibility can be checked directly against ArchetypeType or an ad-hoc structure.

class HypotheticalJacProtocol:
    """Represents a structural interface for Jac type checking."""
    def __init__(self, name: str, required_members: Dict[str, Type], required_abilities: Dict[str, CallableType]):
        self.name = name
        self.required_members = required_members
        self.required_abilities = required_abilities

    def is_structurally_compatible(self, arch_instance_type: ArchetypeInstanceType) -> bool:
        """Check if an archetype instance structurally conforms to this protocol."""
        arch_type = arch_instance_type.archetype_type

        # Check required members (variables from 'has' statements)
        for member_name, expected_member_type in self.required_members.items():
            if member_name not in arch_type.members:
                return False # Missing required member
            actual_member_type = arch_type.members[member_name]
            if not TypeRelationship.is_subtype(actual_member_type, expected_member_type):
                return False # Member type mismatch

        # Check required abilities (from 'can' statements)
        for ability_name, expected_ability_type in self.required_abilities.items():
            if ability_name not in arch_type.abilities:
                return False # Missing required ability
            actual_ability_type = arch_type.abilities[ability_name]
            # Callable subtyping checks if signatures are compatible
            if not TypeRelationship.is_subtype(actual_ability_type, expected_ability_type):
                return False # Ability signature mismatch

        return True

# In practice, instead of a HypotheticalJacProtocol class, the TypeRelationship.is_subtype
# or is_assignable_to could be augmented to perform these structural checks when a
# target type is, for example, an abstract archetype with only ability signatures.
```

Jac's `KW_ABSTRACT` modifier for abilities/archetypes could define implicit protocols. An archetype with abstract abilities would require implementers to provide concrete versions, forming a structural contract.

### Type Guards in Jac

Jac can leverage several mechanisms for type guards, which inform the type checker about type refinements within specific code blocks:

1.  **`check <expression> is <type_expression>`:** (Assuming `check` serves this role or a similar construct exists) This directly asserts the type of an expression, allowing the `TypeNarrower` to refine the type in the subsequent scope if the check passes.

    ```jac
    obj: SomeArchetype | OtherArchetype | null;

    check obj is SomeArchetype; // Type of obj is narrowed to SomeArchetype here
    // obj.some_arch_method(); // Safe to call

    if check obj is not null {
        // obj is narrowed to SomeArchetype | OtherArchetype here
    }
    ```

2.  **`match` statements:** Jac's `match` statement with patterns is a powerful form of type guard. Each `case` branch that successfully matches a pattern will narrow the type of the matched variable(s) according to the pattern.

    ```jac
    message: Any;
    match message {
        case str_val: str => {
            // Here, str_val is known to be of type 'str'
            std.out(str_val.to_upper());
        }
        case int_val: int => {
            // Here, int_val is known to be of type 'int'
            std.out(int_val + 5);
        }
        case my_node: MyNodeArchetype => {
            // Here, my_node is known to be of type MyNodeArchetype
            my_node.node_specific_ability();
        }
    }
    ```

3.  **Null checks:** Explicit checks for `null` (e.g., `if item is null` or `if item is not null`) will narrow types by removing or confirming `NoneType` from unions.

```python
# Adapting the TypeGuard class concept for Jac
# Much of this logic would be integrated into TypeNarrower and TypeEvaluator when processing
# Jac's `check` statements, `match` patterns, or conditional expressions.

class JacTypeGuardAnalyzer:
    """Analyzes Jac constructs that act as type guards."""

    @staticmethod
    def analyze_check_statement(
        check_node: CheckStmt, # Hypothetical Jac AST node for 'check ... is ...'
        type_evaluator: TypeEvaluator,
        current_scope_uid: str # For symbol lookup
    ) -> Optional[Tuple[Symbol, Type]]: # (Symbol being narrowed, narrowed_type)
        """
        Analyzes a Jac 'check target_expr is type_expr' statement.
        Returns the symbol for target_expr and its narrowed type if successful.
        """
        # 1. Get the symbol for target_expr (e.g., if it's a simple Name)
        target_expr_node = check_node.target_expr
        target_symbol = None
        original_type = None

        if isinstance(target_expr_node, NameAtom): # Jac's name node
            target_symbol = type_evaluator.sym_tab.lookup(target_expr_node.value, scope_uid=current_scope_uid)
            if not target_symbol or not target_symbol.type:
                return None # Cannot analyze if symbol or its type is unknown
            original_type = target_symbol.type
        else:
            # If target_expr is more complex, its type needs to be evaluated first.
            # Narrowing might only apply if target_expr is a simple variable name.
            original_type = type_evaluator.get_type(target_expr_node)
            # For complex expressions, narrowing might not directly update a symbol but affect temporary type info.
            # This example focuses on simple variable narrowing.
            return None # Simplification: only narrowing simple names for now

        # 2. Evaluate the type_expr to a Type object
        asserted_type_node = check_node.type_expr
        asserted_type = type_evaluator.get_type_from_annotation(asserted_type_node) # Assumes a method to resolve type expr to Type

        if isinstance(asserted_type, UnknownType) or isinstance(asserted_type, AnyType):
            return None # Cannot meaningfully narrow with Any/Unknown

        # 3. Use TypeNarrower to get the refined type
        # Assume check_node has a flag like `is_positive_check` (for `is` vs `is not`)
        is_positive = not check_node.is_negated # Hypothetical attribute
        narrowed_type = TypeNarrower.narrow_type_from_check(original_type, asserted_type, is_positive_check=is_positive)

        if narrowed_type and not isinstance(narrowed_type, NeverType):
            # The symbol's type can be considered `narrowed_type` in the subsequent scope.
            # The actual update of the symbol's type for scope management is handled by the calling pass.
            return (target_symbol, narrowed_type)

        return None

    # Similar analysis methods could be designed for `match` statement patterns.
```

### Jac Ability/Function Type Inference

Inferring types for Jac abilities and functions without complete type annotations is a valuable feature for developer convenience. The inferrer would analyze the body of the callable to deduce parameter and return types.

```python
# Resides in jaclang/compiler/analysis/type_inferrer.py (or similar)

class JacCallableInferrer:
    """Infers types for Jac abilities and functions if annotations are missing or partial."""

    def __init__(self, type_evaluator: TypeEvaluator, type_factory: TypeFactory, sym_tab: SymbolTable):
        self.type_evaluator = type_evaluator
        self.type_factory = type_factory
        self.sym_tab = sym_tab # Needed for context

    def infer_callable_type(self, callable_node: AbilityOrFunctionDefNode, current_scope_uid: str) -> CallableType:
        """Infers the type of a Jac ability or function based on its signature annotations and body."""
        # callable_node would be Jac's AST node for `can ...` or `def ...`

        # 1. Start with types from annotations (if any)
        parameters = []
        for param_node in callable_node.signature.params: # Hypothetical AST structure
            param_name = param_node.name.value
            param_type = self.type_factory.any() # Default if no annotation
            if param_node.type_tag:
                # Evaluate the type from the Jac type annotation
                param_type = self.type_evaluator.get_type_from_annotation(param_node.type_tag.tag, current_scope_uid)
            parameters.append((param_name, param_type))

        declared_return_type = self.type_factory.any()
        if callable_node.signature.return_type_tag:
            declared_return_type = self.type_evaluator.get_type_from_annotation(callable_node.signature.return_type_tag.tag, current_scope_uid)

        # 2. Infer return type from body if no return annotation (or to verify annotation)
        # This requires evaluating all return statements within the callable's body.
        # Create a new scope for the callable's body for inference.
        # callable_scope_uid = self.sym_tab.get_scope_for_node(callable_node).uid

        # For simplicity, assume type_evaluator has a method for this.
        # This is a complex process involving control flow analysis.
        # inferred_return_type = self.type_evaluator.infer_return_type_from_body(callable_node.body, callable_scope_uid)

        # For now, we prioritize the declared return type if present.
        # A full implementation might create a union of all returned types if no annotation.
        final_return_type = declared_return_type # Simplification
        # if isinstance(declared_return_type, AnyType) and not isinstance(inferred_return_type, AnyType):
        #    final_return_type = inferred_return_type

        # 3. Infer parameter types based on usage within the body (very advanced)
        # E.g., if `param + 1` is seen, `param` might be inferred as `int` or `float`.
        # This is often iterative and complex. For now, we rely on annotations or default to Any.

        is_ability = callable_node.is_ability_decl # Hypothetical flag on AST node
        return self.type_factory.callable_type(parameters, final_return_type, is_ability=is_ability)

    # `get_type_from_annotation` would be part of TypeEvaluator or a shared utility
    # def evaluate_jac_annotation(self, annotation_node: AstNode, current_scope_uid: str) -> Type:
    #     # ... logic to convert Jac AST type expression (e.g., NameAtom like 'str',
    #     # ArchetypeTypeNode, or future ListType[ElementType]) into a Type object ...
    #     # This would use sym_tab.lookup for names, and type_factory.
    #     if isinstance(annotation_node, NameAtom):
    #         type_name = annotation_node.value
    #         # Check built-ins first
    #         builtin_arch = self.type_evaluator.type_cache.get_builtin_archetype(type_name)
    #         if builtin_arch:
    #             return self.type_factory.archetype_instance_type(builtin_arch) # e.g., str -> instance of str archetype
    #
    #         # Look up in symbol table (for user-defined archetypes, enums)
    #         symbol = self.sym_tab.lookup(type_name, scope_uid=current_scope_uid)
    #         if symbol and isinstance(symbol.type, (ArchetypeType, EnumType)):
    #             if isinstance(symbol.type, ArchetypeType):
    #                 return self.type_factory.archetype_instance_type(symbol.type) # User-defined archetype
    #             return symbol.type # EnumType
    #         return self.type_factory.unknown() # Or Any, or error
    #     # TODO: Handle more complex annotations if Jac supports them (e.g. generics, unions in syntax)
    #     return self.type_factory.unknown()

```



================================================================================
FILE: docs/internals/planning_specs/native_type_system/type_inference.md
================================================================================


# Type Inference

This document describes the type inference system in Jac, which allows the compiler to automatically determine the types of expressions and variables without explicit annotations.

## Motivation

Type inference provides the best of both worlds: the safety of a statically typed language with the concise syntax of a dynamically typed language. In Jac, type inference helps:

- Reduce verbosity and boilerplate code
- Make code more readable while maintaining type safety
- Avoid redundant type annotations when types are obvious

## Basic Principles

Type inference in Jac follows these core principles:

1. **Local Inference**: Types are inferred from local context, like initialization expressions
2. **Bidirectional Propagation**: Types can flow both from expressions to variables and from expected contexts to expressions
3. **Progressive Refinement**: Types are refined as more information becomes available during compilation
4. **Defaulting Rules**: When inference is ambiguous, sensible defaults are chosen

## Inference Mechanisms

```mermaid
graph TD
    A[Type Inference Sources] --> B[Initialization Inference]
    A --> C[Contextual Inference]
    A --> D[Flow-sensitive Inference]
    A --> E[Return Type Inference]

    B --> B1["x = 42 âž x inferred as int"]
    C --> C1["func(x) where func expects int âž constrains x to int"]
    D --> D1["if x: ... âž constrains x to be bool-convertible"]
    E --> E1["return x âž constraints x to match function return type"]
```

### Initialization Inference

The simplest form of inference occurs for local variables with initializers:

```jac
x = 42;         // x is inferred as int
y = 3.14;       // y is inferred as float
z = "hello";    // z is inferred as str
items = [];     // items is inferred as list[any]
```

For collections, the element type is inferred from the elements:

```jac
nums = [1, 2, 3];           // nums is inferred as list[int]
mixed = [1, "two", 3.0];    // mixed is inferred as list[int|str|float]
pairs = {"a": 1, "b": 2};   // pairs is inferred as dict[str, int]
```

### Contextual Inference

Types can be inferred from how variables are used:

```jac
def process(items: list[int]) -> int:
    return sum(items);

// x is inferred to be list[int] from the context of the function call
x = [];
process(x);  // Constrains x to list[int]
```

### Flow-sensitive Inference

Types can be refined based on control flow:

```jac
x = get_value();  // Initial type might be Any or a union type

if isinstance(x, str):
    // Within this block, x is known to be a str
    print(x.upper());
else:
    // Here, x's type excludes str
    // ...
```

### Return Type Inference

For functions without explicit return types, the return type is inferred:

```jac
can multiply(a: int, b: int) {
    return a * b;  // Return type inferred as int
}
```

## The Inference Algorithm

Type inference works in several phases:

### 1. Collection Phase

In this phase, the compiler:
- Identifies all variables and expressions
- Records explicit type annotations
- Creates placeholder types for variables without annotations
- Generates type variables for generic type parameters

### 2. Constraint Generation Phase

The compiler analyzes expressions and statements to generate constraints:

```mermaid
flowchart TD
    A[AST Walk] --> B[Generate Type Variables]
    B --> C[Generate Constraints]
    C --> D[Constraint Solving]

    C --> C1["Assignment: lhs = rhs âž rhs <: lhs"]
    C --> C2["BinaryOp: a + b âž Constraints on a, b, result"]
    C --> C3["FunctionCall: f(a, b) âž a <: param1, b <: param2"]
    C --> C4["Return: return e âž e <: func_return_type"]
```

Example constraints:
- Assignment: `x = e` generates `typeof(e) <: typeof(x)`
- Binary operation: `a + b` generates type constraints based on operation rules
- Function call: `f(a, b)` generates `typeof(a) <: typeof(param1)`, `typeof(b) <: typeof(param2)`

### 3. Constraint Solving Phase

The constraint solver attempts to find the most specific types that satisfy all constraints. This typically involves:

1. Constructing a constraint graph
2. Applying constraint propagation
3. Resolving type variables to concrete types
4. Defaulting remaining ambiguous types

```python
# Simplified constraint solving algorithm
def solve_constraints(constraints, type_vars):
    changed = True
    while changed:
        changed = False
        for constraint in constraints:
            # Apply constraint propagation rules
            result = apply_constraint(constraint, type_vars)
            if result:
                changed = True

    # Apply defaulting rules for any remaining ambiguous types
    for var in type_vars:
        if is_ambiguous(var):
            type_vars[var] = default_type_for(var)
```

### 4. Type Application Phase

Finally, the inferred types are attached to AST nodes and made available to the type checker and code generator.

## Handling Special Cases

### Type Inference for Containers

For containers, inference considers both the variable declaration and element types:

```jac
// Inferred as list[int]
x = [1, 2, 3];

// Inferred as list[int|str]
y = [1, "two", 3];

// If z is annotated, this constrains the elements:
z: list[float] = [];  // z must contain floats
```

### Generic Function Type Inference

For generic functions, type parameters are inferred from arguments:

```jac
can first_item<T>(items: list[T]) -> T {
    return items[0];
}

// T inferred as int
x = first_item([1, 2, 3]);

// T inferred as str
y = first_item(["a", "b", "c"]);
```

### Inference with Union Types

Union types are inferred when needed:

```jac
if condition:
    x = 42;
else:
    x = "hello";

// x is inferred as int|str
```

## Bidirectional Type Checking

Jac uses bidirectional type checking, which combines:

- **Type inference**: Determining the type of an expression bottom-up
- **Type checking**: Verifying an expression against an expected type top-down

```mermaid
graph TD
    A[Bidirectional Type Checking] --> B[Inference Mode]
    A --> C[Checking Mode]

    B --> B1["Infer expression type from its parts"]
    B --> B2["Bottom-up: e â‡’ T"]

    C --> C1["Check if expression matches expected type"]
    C --> C2["Top-down: Î“ âŠ¢ e : T"]

    D[Expression] --> B
    C --> D
```

Example:

```jac
// In checking mode: x's type known to be int
x: int = ...;

// In inference mode: expression's type calculated
calc_result = complex_expression();

// Bidirectional: x's type constrains the expression
x = some_expression();
```

## Handling Ambiguity

When type inference is ambiguous, Jac applies defaulting rules:

- Empty collections default to element type `any`
- Numeric literals without context default to `int`
- When multiple valid types exist, the most specific common supertype is chosen

## Interaction with Gradual Typing

Jac supports gradual typing, where some parts of the program have explicit types while others rely on inference:

```jac
// Explicitly typed
x: int = 42;

// Inferred
y = x + 10;

// Partially explicit (list of ints)
z: list[int] = [];
```

## Error Handling in Type Inference

When inference encounters conflicting constraints, it produces clear error messages:

```
test.jac:10:12 - Type Error
Cannot infer consistent type for variable 'x'
Conflicting constraints:
  - x must be int (from assignment at line 5)
  - x must be str (from function call at line 10)
```

## Performance Considerations

Type inference can be computationally expensive. To maintain good compiler performance:

1. **Incremental Inference**: Only re-infer types for code that has changed
2. **Caching**: Cache inference results for common expressions
3. **Early Stopping**: Stop inference when sufficient information is available
4. **Constraint Simplification**: Simplify constraint sets before solving



================================================================================
FILE: docs/internals/planning_specs/native_type_system/type_representation.md
================================================================================


# Type Representation

This document details how types are represented internally in Jac's native type system.

## From Strings to Objects

In the previous implementation, types were primarily represented as strings (e.g., `"int"`, `"list[str]"`, `"MyCustomType"`). The new system replaces these with a rich hierarchy of type objects.

```mermaid
graph LR
    A["String: 'list[int]'"] -->|Old System| B["expr_type = 'list[int]'"]
    C["AST for list[int]"] -->|New System| D["ListType(element_type=JAC_INT)"]
```

## The Type Hierarchy

The foundation of the type system is the abstract `JacType` class, which defines the interface for all type objects.

```mermaid
classDiagram
    direction LR
    class JacType {
        <<abstract>>
        +is_equivalent(other: JacType) bool
        +is_subtype_of(super_type: JacType, env: TypeEnvironment) bool
        +__str__() str
    }

    JacType <|-- PrimitiveType
    JacType <|-- AnyType
    JacType <|-- NothingType
    JacType <|-- ArchetypeType
    JacType <|-- CallableType
    JacType <|-- ContainerType
    JacType <|-- OptionalType
    JacType <|-- UnionType
    JacType <|-- TypeVariable

    ContainerType <|-- ListType
    ContainerType <|-- DictType
    ContainerType <|-- TupleType
    ContainerType <|-- SetType
```

## Core Type Classes

### PrimitiveType

Represents Jac's primitive types like `int`, `float`, `str`, `bool`, and `bytes`.

```python
class PrimitiveType(JacType):
    def __init__(self, name: str):
        self.name = name  # e.g., "int", "float", "str"
```

### ArchetypeType

Represents Jac archetypes (objects, nodes, edges, walkers) and enums.

```python
class ArchetypeType(JacType):
    def __init__(self, name: str, sym_tab: UniScopeNode, arch_node: Archetype):
        self.name = name  # Fully qualified name
        self.sym_tab = sym_tab  # Symbol table of the archetype
        self.arch_node = arch_node  # AST node for the archetype definition
```

This type maintains connections to both the symbol table and AST node of the archetype, enabling member lookups and inheritance resolution.

### CallableType

Represents abilities, functions, and lambdas.

```python
class CallableType(JacType):
    def __init__(self, param_types: list[JacType], return_type: JacType, name: Optional[str] = None):
        self.param_types = param_types
        self.return_type = return_type
        self.name = name  # Optional name of the callable
```

### Container Types

A family of types for collections:

```python
class ListType(ContainerType):
    def __init__(self, element_type: JacType):
        self.element_type = element_type

class DictType(ContainerType):
    def __init__(self, key_type: JacType, value_type: JacType):
        self.key_type = key_type
        self.value_type = value_type

class TupleType(ContainerType):
    def __init__(self, item_types: Sequence[JacType], homogeneous_type: Optional[JacType] = None):
        self.item_types = tuple(item_types)  # For heterogeneous tuples
        self.homogeneous_type = homogeneous_type  # For tuple[T, ...]
```

### Type Operators

Types that combine or modify other types:

```python
class OptionalType(JacType):
    def __init__(self, wrapped_type: JacType):
        self.wrapped_type = wrapped_type

class UnionType(JacType):
    def __init__(self, types: Sequence[JacType]):
        self.member_types = frozenset(self._normalize_union(types))
```

### Special Types

```python
class AnyType(JacType):
    """Represents the 'any' type."""
    pass

class NothingType(JacType):
    """Represents the type for functions not returning a value."""
    pass

class TypeVariable(JacType):
    """Represents a type variable for generics."""
    def __init__(self, name: str, scope_id: int):
        self.name = name
        self.scope_id = scope_id  # Disambiguates type vars with same name
```

## Type Operations

### Type Equivalence

The `is_equivalent` method determines if two types are equivalent:

```python
# In ListType
def is_equivalent(self, other: JacType) -> bool:
    return (isinstance(other, ListType) and
            self.element_type.is_equivalent(other.element_type))

# In ArchetypeType (nominal typing)
def is_equivalent(self, other: JacType) -> bool:
    return isinstance(other, ArchetypeType) and self.name == other.name
```

Different types have different equivalence rules:
- **Nominal equivalence** for archetypes (based on name)
- **Structural equivalence** for containers and callables (based on structure)

### Subtyping Relationships

The `is_subtype_of` method determines if one type can be used where another is expected:

```python
# In ArchetypeType
def is_subtype_of(self, super_type: JacType, env: TypeEnvironment) -> bool:
    if self.is_equivalent(super_type):
        return True
    if isinstance(super_type, AnyType):
        return True
    if isinstance(super_type, ArchetypeType):
        # Check inheritance chain
        for base in env.get_base_types(self):
            if base.is_equivalent(super_type) or base.is_subtype_of(super_type, env):
                return True
    return False
```

Subtyping relationships follow these principles:
- A type is always a subtype of itself
- A type is always a subtype of `any`
- For archetypes, subtyping follows the inheritance hierarchy
- For containers, variance rules apply (e.g., covariance for lists)
- For callables, parameter types are contravariant and return types are covariant

## Singletons for Common Types

For efficiency, common types are pre-instantiated:

```python
JAC_INT = PrimitiveType("int")
JAC_FLOAT = PrimitiveType("float")
JAC_STRING = PrimitiveType("str")
JAC_BOOL = PrimitiveType("bool")
JAC_BYTES = PrimitiveType("bytes")
JAC_NULL = NothingType()
JAC_ANY = AnyType()
JAC_NOTHING = NothingType()
```

## Integration with AST

Type information is stored directly on AST nodes:

```python
class Expr(UniNode):
    # ...
    def __init__(self):
        # ...
        self.jac_type: Optional[JacType] = None
```

This allows type information to be easily accessed during code generation and other compiler passes.

## String Representation

For error messages and debugging, types provide string representations:

```python
# In ListType
def __str__(self) -> str:
    return f"list[{str(self.element_type)}]"

# In CallableType
def __str__(self) -> str:
    params_str = ", ".join(str(p) for p in self.param_types)
    return f"({params_str}) -> {str(self.return_type)}"
```

## Example: Complex Type Representation

Let's look at how a complex type is represented:

```mermaid
graph TD
    A["dict[str, list[Optional[MyClass]]]"] --> B["DictType"]
    B --> C["key_type: StringType"]
    B --> D["value_type: ListType"]
    D --> E["element_type: OptionalType"]
    E --> F["wrapped_type: ArchetypeType"]
    F --> G["name: 'MyClass'"]
    F --> H["sym_tab: MyClass's symbol table"]
    F --> I["arch_node: MyClass's AST node"]
```



================================================================================
FILE: docs/internals/planning_specs/native_type_system/type_resolution.md
================================================================================


# Type Resolution

This document explains how the Jac compiler resolves types from source code, transforming type annotations and expressions into concrete type representations.

## The Resolution Process

Type resolution is the process of converting syntactic representations of types (such as annotations in source code) into the JacType objects used by the compiler.

```mermaid
graph TD
    A[Source Code with Type Annotations] --> B[AST with Type References]
    B --> C[Type Resolver]
    C --> D[Concrete JacType Objects]

    E[Symbol Tables] --> C
    F[Type Environment] --> C
    G[Type Registry] --> C
```

## The Type Resolver

The Type Resolver is a central component that handles type resolution:

```python
class TypeResolver:
    def __init__(self, error_reporter: callable):
        self.error_reporter = error_reporter

    def resolve_type_from_ast(self, ast_node: uni.Expr, env: TypeEnvironment) -> JacType:
        """Main entry point to resolve a JacType from an AST expression."""
        # Logic to handle different AST node types
```

## Sources of Type Information

The Type Resolver works with several different sources of type information:

1. **Explicit Type Annotations**:
   - Variable declarations: `x: int = 5`
   - Parameter types: `can do_something(name: str, count: int)`
   - Return types: `can calculate() -> float`

2. **Type Hints in Doc Strings**:
   - Documentation comments can specify types: `@param name: The user's name`

3. **Imported Types**:
   - Types defined in other modules: `from geometry import Point`

4. **Built-in Types**:
   - Primitive types (`int`, `str`, etc.)
   - Container types (`list`, `dict`, etc.)

## Resolution Logic

### Simple Name Resolution

For simple type names like `int` or `MyClass`:

```mermaid
flowchart TD
    A[Name Type Reference] --> B{Is it a built-in type?}
    B -- Yes --> C[Return built-in JacType]
    B -- No --> D{Is it a type variable?}
    D -- Yes --> E[Return TypeVariable]
    D -- No --> F{Is it in symbol table?}
    F -- Yes --> G[Return ArchetypeType]
    F -- No --> H[Report error, return Any]
```

```python
def _resolve_name_type(self, name_node: uni.Name, env: TypeEnvironment) -> JacType:
    name_str = name_node.value

    # Check built-in primitives
    if name_str in TYPE_NAME_TO_JAC_TYPE_MAP:
        return TYPE_NAME_TO_JAC_TYPE_MAP[name_str]

    # Check for type variables in scope
    type_var = env.get_type_variable(name_str)
    if type_var:
        return type_var

    # Look up in symbol table
    sym_tab_entry = env.current_scope.sym_tab_scope.lookup(name_str)
    if sym_tab_entry and sym_tab_entry.decl.name_of and isinstance(sym_tab_entry.decl.name_of, uni.Archetype):
        arch_node = sym_tab_entry.decl.name_of
        return ArchetypeType(name_str, arch_node.sym_tab, arch_node)

    # Not found, report error
    self.error_reporter(JacErrorCode.TYPE_ERROR_NAME_NOT_FOUND,
                        args={"name": name_str},
                        node_override=name_node)
    return JAC_ANY
```

### Generic Type Resolution

For types with parameters like `list[int]` or `dict[str, float]`:

```mermaid
flowchart TD
    A[Generic Type Reference] --> B[Extract base type name]
    B --> C[Resolve base type]
    A --> D[Extract type parameters]
    D --> E[Resolve each parameter recursively]
    C --> F[Construct appropriate container type]
    E --> F
    F --> G[Return container JacType]
```

```python
# For a case like list[int]
if base_name == "list" and isinstance(ast_node.right, uni.IndexSlice):
    type_args_ast = ast_node.right.idx_value.items
    if len(type_args_ast) == 1:
        element_type = self.resolve_type_from_ast(type_args_ast[0], env)
        return ListType(element_type)
    else:
        self.error_reporter(JacErrorCode.TYPE_ERROR_WRONG_GENERIC_ARGS,
                           args={"type_name": "list", "expected": 1, "actual": len(type_args_ast)},
                           node_override=ast_node)
        return ListType(JAC_ANY)  # Fallback
```

### Union Type Resolution

For union types like `int | str`:

```python
if isinstance(ast_node, uni.BinaryExpr) and ast_node.op.name == uni.Tok.PIPE:
    left_type = self.resolve_type_from_ast(ast_node.left, env)
    right_type = self.resolve_type_from_ast(ast_node.right, env)
    return UnionType([left_type, right_type])
```

### Callable Type Resolution

For callable types (ability signatures):

```python
if isinstance(ast_node, uni.AbilityTypeHint):
    param_types = [self.resolve_type_from_ast(param, env)
                   for param in ast_node.param_types.items]
    return_type = (self.resolve_type_from_ast(ast_node.return_type, env)
                   if ast_node.return_type else JAC_NOTHING)
    return CallableType(param_types, return_type)
```

## Handling Archetypes

Jac's archetypes (node, edge, object, walker) require special handling:

1. **Resolving the Archetype Definition**:
   - Locate the archetype's definition in the symbol table
   - Create an ArchetypeType with references to the symbol table and AST node

2. **Member Access Type Resolution**:
   - When resolving expressions like `obj.field`, use the archetype's symbol table

3. **Method Resolution**:
   - When resolving method calls, find abilities in the archetype's symbol table

## Qualified Name Resolution

For types referenced through modules or nested namespaces:

```mermaid
flowchart TD
    A[Qualified Name: mod.Type] --> B[Resolve module 'mod']
    B --> C{Found module?}
    C -- Yes --> D[Look up 'Type' in module's symbol table]
    C -- No --> E[Report error]
    D --> F{Found type?}
    F -- Yes --> G[Return ArchetypeType]
    F -- No --> H[Report error]
```

## Type Resolution Caching

For performance, resolved types are cached:

```python
# Inside TypeEnvironment
def get_node_type(self, ast_node_id: int) -> Optional[JacType]:
    return self.node_to_type_map.get(ast_node_id)

def set_node_type(self, ast_node_id: int, jac_type: JacType) -> None:
    self.node_to_type_map[ast_node_id] = jac_type
```

## Error Handling

The resolver reports errors through the error reporting system:

```python
self.error_reporter(JacErrorCode.TYPE_ERROR_NAME_NOT_FOUND,
                   args={"name": name_str},
                   node_override=name_node)
```

Common error scenarios:
- Type name not found
- Wrong number of type parameters
- Invalid use of type (e.g., trying to use a non-generic type as generic)
- Circular type references

## Integration with Compiler Passes

The Type Resolver is used in several compiler passes:

1. **Type Annotation Resolution Pass**:
   - After symbol table construction
   - Resolves explicit type annotations

2. **Type Inference Pass**:
   - Infers types from initializers and usage
   - May call the resolver to resolve known types

3. **Type Checking Pass**:
   - Uses resolved types to validate operations
   - May call the resolver for complex expressions

## Example Resolution Flow

```mermaid
sequenceDiagram
    participant Compiler as Compiler Pass
    participant Resolver as TypeResolver
    participant Env as TypeEnvironment
    participant SymTab as Symbol Table

    Note over Compiler: Encounters "x: list[MyClass]"
    Compiler->>Resolver: resolve_type_from_ast(ast_for_list[MyClass], env)
    Resolver->>Resolver: Extract "list" and "MyClass"
    Resolver->>Resolver: Recognize "list" as container type
    Resolver->>Resolver: Need to resolve "MyClass"
    Resolver->>Env: get_type_variable("MyClass")
    Env-->>Resolver: Not a type variable
    Resolver->>SymTab: lookup("MyClass")
    SymTab-->>Resolver: Symbol for MyClass (Archetype)
    Resolver->>Resolver: Create ArchetypeType for MyClass
    Resolver->>Resolver: Create ListType with MyClass element type
    Resolver-->>Compiler: ListType(element_type=ArchetypeType("MyClass"))
```



================================================================================
FILE: docs/internals/planning_specs/native_type_system/type_rules.md
================================================================================


# Type Rules

This document defines the formal type checking rules for the Jac language.

## Introduction to Type Rules

Type rules specify how to determine the types of expressions and how to validate operations. They form the foundation of the type checker's decision-making process.

Each rule specifies:
1. The language construct being checked
2. The conditions that must be met for the construct to be well-typed
3. The resulting type of the expression (if applicable)

## Notation

We'll use a formal notation similar to type inference rules in programming language theory:

```
Premises
--------------
Conclusion
```

Where:
- **Premises** are the conditions that must be true for the rule to apply
- **Conclusion** is what we can conclude when the premises are satisfied

We'll also use the following notation:
- Î“ (Gamma): The typing environment/context
- e : T: Expression e has type T
- S <: T: Type S is a subtype of T

## Core Rules

### Literals

```
--------------
Î“ âŠ¢ IntLiteral : int

--------------
Î“ âŠ¢ FloatLiteral : float

--------------
Î“ âŠ¢ StringLiteral : str

--------------
Î“ âŠ¢ BoolLiteral : bool

--------------
Î“ âŠ¢ null : Any
```

### Variables

```
x: T âˆˆ Î“
--------------
Î“ âŠ¢ x : T
```

A variable x has type T if the environment Î“ contains the binding x: T.

### Assignment

```
Î“ âŠ¢ e : S    Î“ âŠ¢ x : T    S <: T
---------------------------------
Î“ âŠ¢ x = e : T
```

An assignment is valid if the type of the expression is a subtype of the variable's type.

### Binary Operations

#### Arithmetic Operations

```
Î“ âŠ¢ e1 : T1    Î“ âŠ¢ e2 : T2    T1, T2 âˆˆ {int, float}
---------------------------------------------------------
Î“ âŠ¢ e1 + e2 : lub(T1, T2)    // Similarly for -, *, /
```

Where `lub` is the least upper bound (e.g., `lub(int, float) = float`).

```mermaid
graph LR
    int --> float
    subgraph "Numeric Type Hierarchy"
    int
    float
    end
```

#### String Concatenation

```
Î“ âŠ¢ e1 : str    Î“ âŠ¢ e2 : T    T has __str__
----------------------------------------
Î“ âŠ¢ e1 + e2 : str
```

#### Comparison Operations

```
Î“ âŠ¢ e1 : T1    Î“ âŠ¢ e2 : T2    T1 and T2 are comparable
------------------------------------------------------
Î“ âŠ¢ e1 < e2 : bool    // Similarly for >, <=, >=
```

```
Î“ âŠ¢ e1 : T1    Î“ âŠ¢ e2 : T2
--------------------------
Î“ âŠ¢ e1 == e2 : bool    // Similarly for !=
```

#### Logical Operations

```
Î“ âŠ¢ e1 : bool    Î“ âŠ¢ e2 : bool
----------------------------
Î“ âŠ¢ e1 and e2 : bool    // Similarly for or
```

```
Î“ âŠ¢ e : bool
-----------
Î“ âŠ¢ not e : bool
```

### Function/Ability Calls

```
Î“ âŠ¢ f : (P1, P2, ..., Pn) -> R
Î“ âŠ¢ e1 : T1    Î“ âŠ¢ e2 : T2    ...    Î“ âŠ¢ en : Tn
T1 <: P1    T2 <: P2    ...    Tn <: Pn
------------------------------------------
Î“ âŠ¢ f(e1, e2, ..., en) : R
```

A function call is valid if each argument's type is a subtype of the corresponding parameter type.

### Member Access

```
Î“ âŠ¢ e : T    member m with type M exists in T
-------------------------------------------
Î“ âŠ¢ e.m : M
```

### Control Flow

#### If Statement/Expression

```
Î“ âŠ¢ cond : bool    Î“ âŠ¢ then_expr : T1    Î“ âŠ¢ else_expr : T2
----------------------------------------------------------
Î“ âŠ¢ if cond then then_expr else else_expr : lub(T1, T2)
```

#### For Loop

```
Î“ âŠ¢ iterable : Iterable[T]    Î“, item: T âŠ¢ body
------------------------------------------
Î“ âŠ¢ for item in iterable: body
```

## Jac-Specific Rules

### Archetypes and Inheritance

```
A inherits from B    B inherits from C
------------------------------------
A <: B    B <: C    A <: C
```

### Walker Rules

```
W is a walker    N is a node
--------------------------
Î“ âŠ¢ W.takeâ†’N : N
```

```
Î“ âŠ¢ w : Walker    Î“ âŠ¢ n : Node    w.can_visit(n)
----------------------------------------------
Î“ âŠ¢ w.visit(n)
```

### Node/Edge Creation

```
N is a node archetype    Î“ âŠ¢ args match N.init parameters
------------------------------------------------------
Î“ âŠ¢ spawn N(args) : N
```

### Graph Operations

```
Î“ âŠ¢ n1 : N1    Î“ âŠ¢ n2 : N2    Î“ âŠ¢ e : E
N1, N2 are node types    E is edge type
-------------------------------------
Î“ âŠ¢ n1 -[e]-> n2
```

## Container Types

### List Operations

```
Î“ âŠ¢ list : list[T]    Î“ âŠ¢ index : int
------------------------------------
Î“ âŠ¢ list[index] : T
```

```
Î“ âŠ¢ list1 : list[T1]    Î“ âŠ¢ list2 : list[T2]
-------------------------------------------
Î“ âŠ¢ list1 + list2 : list[lub(T1, T2)]
```

### Dictionary Operations

```
Î“ âŠ¢ dict : dict[K, V]    Î“ âŠ¢ key : K'    K' <: K
---------------------------------------------
Î“ âŠ¢ dict[key] : V
```

## Variance Rules

### For Container Types

```mermaid
graph TD
    A[Type Variance] --> B[Covariance]
    A --> C[Contravariance]
    A --> D[Invariance]

    B --> B1["If S <: T, then C[S] <: C[T]"]
    C --> C1["If S <: T, then C[T] <: C[S]"]
    D --> D1["C[S] and C[T] are unrelated"]

    E[List in Jac] --> B
    F[Dictionary Keys] --> D
    G[Dictionary Values] --> B
    H[Function Parameters] --> C
    I[Function Return Types] --> B
```

- **List**: Covariant in element type
  ```
  S <: T
  --------
  list[S] <: list[T]
  ```

- **Dictionary**: Invariant in keys, covariant in values
  ```
  K1 == K2    V1 <: V2
  ------------------
  dict[K1, V1] <: dict[K2, V2]
  ```

- **Tuple**: Covariant in element types
  ```
  S1 <: T1    S2 <: T2    ...    Sn <: Tn
  ---------------------------------------
  tuple[S1, S2, ..., Sn] <: tuple[T1, T2, ..., Tn]
  ```

### For Function Types

- **Function/Ability**: Contravariant in parameters, covariant in return type
  ```
  T1 <: S1    T2 <: S2    ...    Tn <: Sn    R1 <: R2
  ---------------------------------------------------
  (S1, S2, ..., Sn) -> R1 <: (T1, T2, ..., Tn) -> R2
  ```

## Error Reporting

When a type rule is violated, the type checker reports an error with:

1. **Location**: The source code location where the error occurred
2. **Rule Violated**: Which type rule was broken
3. **Expected vs. Actual**: The expected type and the actual type found
4. **Suggestion**: If possible, a suggestion for how to fix the error

Example error:
```
test.jac:42:15 - Type Error
Cannot assign value of type 'str' to variable of type 'int'
  x: int = "hello";  // Type mismatch
            ^~~~~~
Consider using int("hello") to convert the string to an integer
```

## Type Compatibility Matrix

The following table summarizes which operations are allowed between different types:

```mermaid
graph TD
    A[Type Compatibility Matrix] --> B[Arithmetic Operations]
    A --> C[Comparison Operations]
    A --> D[Logical Operations]
    A --> E[String Operations]

    B --> B1["+ : Allowed for: int+int, float+float, int+float"]
    B --> B2["- : Allowed for: int-int, float-float, int-float"]
    B --> B3["* : Allowed for: int*int, float*float, int*float"]
    B --> B4["/ : Allowed for: int/int, float/float, int/float"]

    C --> C1["< > <= >= : Allowed for comparable types"]
    C --> C2["== != : Allowed for all types"]

    D --> D1["and, or : Allowed for bool operands"]
    D --> D2["not : Allowed for bool operand"]

    E --> E1["+ : Allowed for: str+Any (calls __str__)"]
```



================================================================================
FILE: docs/internals/planning_specs/ref_roadmap.md
================================================================================


# Jac Grammar Documentation Analysis

## Section 1: Base Module structure

*   **Grammar Rules from `jac.lark`:**
    ```lark
    start: module
    module: (toplevel_stmt (tl_stmt_with_doc | toplevel_stmt)*)?
           | STRING        (tl_stmt_with_doc | toplevel_stmt)*
    tl_stmt_with_doc: STRING toplevel_stmt
    toplevel_stmt: import_stmt
           | archetype
           | impl_def
           | ability
           | global_var
           | free_code
           | py_code_block
           | test
    ```
*   **Corresponding Markdown File:** `jac/examples/reference/base_module_structure.md`
*   **Findings:**
    1.  **Inconsistency in `with entry` requirement:**
        *   **Documentation states:** "Moreover, Jac requires that any standalone, module-level code be encapsulated within a `with entry {}` block."
        *   **Grammar allows:** `toplevel_stmt` (which includes `global_var`, `archetype`, `ability`, `test`, `impl_def`, `import_stmt`, `py_code_block`) to appear directly within a `module` without being wrapped in `free_code` (which is the `with entry {}` construct). The `free_code` rule is just one of the options for a `toplevel_stmt`.
        *   **Issue:** The documentation's statement about `with entry {}` being required for *any* standalone module-level code is an oversimplification and conflicts with the broader capabilities defined in the grammar for `module` and `toplevel_stmt`.

---

## Section 2: Import/Include Statements

*   **Grammar Rules from `jac.lark`:**
    ```lark
    import_stmt: KW_IMPORT KW_FROM from_path LBRACE import_items RBRACE
               | KW_IMPORT import_path (COMMA import_path)* SEMI
               | KW_INCLUDE import_path SEMI

    from_path: (DOT | ELLIPSIS)* import_path
             | (DOT | ELLIPSIS)+

    import_path: dotted_name (KW_AS NAME)?
    import_items: (import_item COMMA)* import_item COMMA?
    import_item: named_ref (KW_AS NAME)?
    dotted_name: named_ref (DOT named_ref)*
    ```
*   **Corresponding Markdown File:** `jac/examples/reference/import_include_statements.md`
*   **Findings:**
    1.  **`from_path` details not fully covered:**
        *   **Grammar allows:** `from_path` to be `(DOT | ELLIPSIS)* import_path` or `(DOT | ELLIPSIS)+`.
        *   **Documentation mentions:** Relative paths but doesn't explicitly detail the syntax using `.` or `ELLIPSIS` (`...`) in the `from_path` for selective imports.
        *   **Issue:** The documentation could be more explicit about using `.` and `...` in `from_path`.
    2.  **`import_items` trailing comma:**
        *   **Grammar allows:** A trailing comma in `import_items`.
        *   **Documentation example:** Does not show an example with a trailing comma.
        *   **Issue:** Minor omission; an example or note about the optional trailing comma would be beneficial.
    3.  **Multiple `import_path` in standard import:**
        *   **Grammar allows:** Importing multiple modules in a single standard `import` statement (e.g., `import mod1, mod2;`).
        *   **Documentation examples:** Show single module imports per statement.
        *   **Issue:** Documentation does not cover importing multiple modules in one standard `import` statement.

---

## Section 3: Archetypes

*   **Grammar Rules from `jac.lark`:**
    ```lark
    archetype: decorators? KW_ASYNC? archetype_decl
             | enum

    archetype_decl: arch_type access_tag? NAME inherited_archs? (member_block | SEMI)
    decorators: (DECOR_OP atomic_chain)+
    access_tag: COLON ( KW_PROT | KW_PUB | KW_PRIV )
    inherited_archs: LPAREN (atomic_chain COMMA)* atomic_chain RPAREN

    arch_type: KW_WALKER
              | KW_OBJECT
              | KW_EDGE
              | KW_NODE
              | KW_CLASS
    ```
*   **Corresponding Markdown File:** `jac/examples/reference/archetypes.md`
*   **Findings:**
    1.  **Omission of Empty/Forward Declaration:**
        *   **Grammar allows:** `archetype_decl` to end with `SEMI` (e.g., `node MyNode;`).
        *   **Documentation:** Does not mention or provide examples for this.
        *   **Issue:** Capability to define archetypes with empty bodies using a semicolon is not documented.
    2.  **Omission of `KW_ASYNC` for Archetypes:**
        *   **Grammar allows:** `archetype` to be `async` (e.g., `async walker MyAsyncWalker {...}`).
        *   **Documentation:** Does not mention `async` archetypes.
        *   **Issue:** The `async` keyword applicability to the archetype declaration itself is not documented.
    3.  **`enum` as an `archetype` form:**
        *   **Grammar states:** `archetype: ... | enum`.
        *   **Documentation:** `archetypes.md` does not mention that `enum` is a type of `archetype`.
        *   **Issue:** Lack of mention or cross-reference to `enum` as a form of `archetype`.

---

## Section 4: Archetype bodies

*   **Grammar Rules from `jac.lark`:**
    ```lark
    member_block: LBRACE member_stmt* RBRACE
    member_stmt: STRING? (py_code_block | ability | archetype | impl_def | has_stmt | free_code)
    has_stmt: KW_STATIC? (KW_LET | KW_HAS) access_tag? has_assign_list SEMI
    has_assign_list: (has_assign_list COMMA)? typed_has_clause
    typed_has_clause: named_ref type_tag (EQ expression | KW_BY KW_POST_INIT)?
    type_tag: COLON expression
    ```
*   **Corresponding Markdown File:** `jac/examples/reference/archetype_bodies.md`
*   **Findings:**
    1.  **`member_stmt` options not fully detailed/exemplified:**
        *   **Grammar for `member_stmt`:** `STRING? (py_code_block | ability | archetype | impl_def | has_stmt | free_code)`
        *   **Documentation (`archetype_bodies.md`):**
            *   Covers `has_stmt` and `ability` well.
            *   Shows docstrings (`STRING?`).
            *   Mentions `impl` blocks but not explicitly that `impl_def` can be nested inside an archetype.
            *   Does not explicitly cover nesting `archetype`, `py_code_block`, or `free_code` within an archetype.
        *   **Issue:** Documentation should list all `member_stmt` types and provide examples/references for nesting `archetype`, `py_code_block`, `impl_def`, and `free_code`.
    2.  **`has_stmt` using `KW_LET`:**
        *   **Grammar for `has_stmt`:** `KW_STATIC? (KW_LET | KW_HAS) ...`.
        *   **Documentation:** Consistently uses `has`. `KW_LET` alternative is not mentioned.
        *   **Issue:** Use of `let` for member declarations is not documented in this file.
    3.  **`typed_has_clause` with `KW_BY KW_POST_INIT`:**
        *   **Grammar:** `... (EQ expression | KW_BY KW_POST_INIT)?`
        *   **Documentation:** Covered in `archetypes.md` (`has id: str by postinit;`).
        *   **Status:** Covered in a related file.
    4.  **`has_assign_list` with multiple assignments:**
        *   **Grammar for `has_assign_list`:** `(has_assign_list COMMA)? typed_has_clause`, implying multiple comma-separated declarations.
        *   **Documentation:** Examples show one variable per `has` statement.
        *   **Issue:** Declaring multiple variables in a single `has` statement (e.g., `has name: str, age: int;`) is not documented.

---

## Section 5: Enumerations

*   **Grammar Rules from `jac.lark`:**
    ```lark
    enum: decorators? enum_decl
    enum_decl: KW_ENUM access_tag? NAME inherited_archs? (enum_block | SEMI)
    enum_block: LBRACE assignment_list COMMA? (py_code_block | free_code)* RBRACE
    // assignment_list: (assignment_list COMMA)? (assignment | named_ref)
    ```
*   **Corresponding Markdown File:** `jac/examples/reference/enumerations.md`
*   **Findings:**
    1.  **`inherited_archs` in `enum_decl`:**
        *   **Grammar allows:** Enums to use `inherited_archs` (e.g., `enum MyEnum(Parent) {...}`).
        *   **Documentation:** Does not mention or exemplify enum inheritance.
        *   **Issue:** Enum inheritance is not documented.
    2.  **Empty Enum Declaration with `SEMI`:**
        *   **Grammar allows:** `enum MyEnum;`.
        *   **Documentation:** Shows `enum Day;` with an `impl Day {}` block.
        *   **Status:** Covered in the context of `impl` blocks.
    3.  **`py_code_block` and `free_code` in `enum_block`:**
        *   **Grammar allows:** `py_code_block` (`::py::...::py::`) or `free_code` (`with entry {}`) within an `enum {}` body.
        *   **Documentation:** Examples focus on assignments in `enum {}` and methods in `impl {}`.
        *   **Issue:** Direct inclusion of `py_code_block` or `free_code` in `enum {}` is not documented.
    4.  **Nature of `assignment_list` in Enums:**
        *   **Grammar uses a general `assignment_list` rule.**
        *   **Documentation shows:** Typical enum assignments (`NAME = value` or `NAME`).
        *   **Question/Potential Minor Issue:** The documentation doesn't clarify if the full range of complex `assignment` syntax is applicable or idiomatic within enums, or if it's restricted to simpler forms.
        *   **Status:** Core enum assignment is covered; scope of complex assignments within enums is not detailed.

---

## Section 6: Functions and Abilities

*   **Grammar Rules from `jac.lark`:**
    ```lark
    ability: decorators? KW_ASYNC? (ability_decl | function_decl)

    function_decl: KW_OVERRIDE? KW_STATIC? KW_DEF access_tag? named_ref func_decl? (block_tail | KW_ABSTRACT? SEMI)
    ability_decl: KW_OVERRIDE? KW_STATIC? KW_CAN access_tag? named_ref event_clause (block_tail | KW_ABSTRACT? SEMI)

    block_tail: code_block | KW_BY atomic_call SEMI

    event_clause: KW_WITH expression? (KW_EXIT | KW_ENTRY) (RETURN_HINT expression)?

    func_decl: (LPAREN func_decl_params? RPAREN) (RETURN_HINT expression)?
             | (RETURN_HINT expression)

    func_decl_params: (param_var COMMA)* param_var COMMA?
    param_var: (STAR_POW | STAR_MUL)? named_ref type_tag (EQ expression)?
    ```
*   **Corresponding Markdown File:** `jac/examples/reference/functions_and_abilities.md`
*   **Findings:**
    1.  **`function_decl` without parentheses:**
        *   **Grammar for `func_decl` allows:** `(RETURN_HINT expression)` directly (e.g., `def my_func -> int { ... }`).
        *   **Documentation:** Examples use parentheses. The variant without `()` for no-parameter functions is not shown.
        *   **Issue:** Undocumented shorthand for no-parameter functions.
    2.  **`block_tail` with `KW_BY atomic_call SEMI` (Delegation):**
        *   **Grammar allows:** Implementation delegation (e.g., `def my_func by other_func;`).
        *   **Documentation:** Does not cover the `by` delegation syntax.
        *   **Issue:** Delegation of implementation is not documented.
    3.  **`event_clause` with return type:**
        *   **Grammar for `event_clause` allows:** `(RETURN_HINT expression)?` (e.g., `can my_ability with node entry -> bool { ... }`).
        *   **Documentation:** Does not show abilities with event clauses having explicit return types.
        *   **Issue:** Return types on event-claused abilities are not documented.
    4.  **`KW_OVERRIDE` for functions/abilities:**
        *   **Grammar allows:** `KW_OVERRIDE?`.
        *   **Documentation:** `override` keyword is not mentioned or exemplified.
        *   **Issue:** `override` keyword is not documented.
    5.  **`KW_ABSTRACT` with `SEMI`:**
        *   **Grammar allows:** `KW_ABSTRACT? SEMI`.
        *   **Documentation:** Shows `def area() -> float abs;`.
        *   **Status:** Covered.
    6.  **`param_var` (parameter definitions):**
        *   **Grammar covers:** `*args`, `**kwargs`, typed params, default values.
        *   **Documentation:** Shows these patterns.
        *   **Status:** Covered.
    7.  **`decorators` on `ability` / `function_decl`:**
        *   **Grammar allows:** Decorators on abilities and functions.
        *   **Documentation:** No specific example in `functions_and_abilities.md`, though decorators are a general feature.
        *   **Issue:** Minor; a direct example would be beneficial for completeness.
    8.  **`KW_STATIC` for abilities:**
        *   **Grammar allows:** `KW_STATIC? KW_CAN ...` (static abilities).
        *   **Documentation:** Examples show `static def`, but not `static can`.
        *   **Issue:** Static abilities are not explicitly documented.

---

## Section 7: Implementations

*   **Grammar Rules from `jac.lark`:**
    ```lark
    impl_def: decorators? KW_IMPL dotted_name impl_spec? impl_tail
    impl_spec: inherited_archs | func_decl | event_clause
    impl_tail: enum_block | block_tail
    // block_tail: code_block | KW_BY atomic_call SEMI
    ```
*   **Corresponding Markdown File:** `jac/examples/reference/implementations.md`
*   **Findings:**
    1.  **Modern `impl` Syntax vs. Grammar `impl_def`:**
        *   **Documentation shows:** `impl foo() -> str { ... }`, `impl vehicle { ... }`, `impl Size { ... }`.
        *   **Grammar:** `KW_IMPL dotted_name impl_spec? impl_tail`.
        *   **Status:** Documented "Modern `impl` Syntax" aligns well with the grammar.

    2.  **Legacy Colon Syntax:**
        *   **Documentation covers:** `:can:foo()`, `:obj:vehicle`, `:enum:Size`, `:test:check_vehicle`.
        *   **Grammar `jac.lark`:** Does not define this colon-prefixed syntax for implementations directly in `impl_def`.
        *   **Issue:** Significant inconsistency. The legacy colon syntax is not in the provided `impl_def` grammar.

    3.  **`impl_spec` with `inherited_archs` or `event_clause`:**
        *   **Grammar for `impl_spec`:** `inherited_archs | func_decl | event_clause`.
        *   **Documentation covers:** `impl_spec` as `func_decl` (e.g., `impl foo() -> str { ... }`).
        *   **Documentation does not cover:** `impl_spec` as `inherited_archs` (e.g., `impl MyType(Parent) { ... }`) or `event_clause` (e.g., `impl MyAbility with node entry { ... }`).
        *   **Issue:** Using `inherited_archs` or `event_clause` in `impl_spec` is not documented.

    4.  **`decorators` on `impl_def`:**
        *   **Grammar allows:** `decorators? KW_IMPL ...`.
        *   **Documentation:** No examples show decorators on `impl` blocks.
        *   **Issue:** Decorating `impl` blocks is not documented.

    5.  **`impl_tail` with `KW_BY atomic_call SEMI` (Delegation):**
        *   **Grammar allows:** `impl_tail` to be `block_tail`, which can delegate (e.g., `impl foo() -> str by other_call;`).
        *   **Documentation:** Does not cover `by` delegation for implementations.
        *   **Issue:** Delegating an entire `impl` block is not documented.

    6.  **Implementing `test`:**
        *   **Documentation shows:** `test check_vehicle;` and `:test:check_vehicle { ... }` (legacy).
        *   **Grammar `test` rule:** `KW_TEST NAME? code_block` (defines test with body).
        *   **Grammar `impl_def` suggests modern form:** `impl check_vehicle { ... }`.
        *   **Issue:** The "Modern `impl` Syntax" for tests (`KW_IMPL test_name`) is not explicitly shown. Clarity is needed on how `test Name;` declaration and `impl Name { ... }` interact versus the direct `test Name { ... }` grammar.

---

## Section 8: Global variables

*   **Grammar Rules from `jac.lark`:**
    ```lark
    global_var: (KW_LET | KW_GLOBAL) access_tag? assignment_list SEMI
    assignment_list: (assignment_list COMMA)? (assignment | named_ref)
    // access_tag: COLON ( KW_PROT | KW_PUB | KW_PRIV )
    // assignment: ... (complex rule)
    ```
*   **Corresponding Markdown File:** `jac/examples/reference/global_variables.md`
*   **Findings:**
    1.  **Keywords `let` and `glob`:**
        *   **Grammar:** `KW_LET`, `KW_GLOBAL`.
        *   **Documentation:** Explains `let` and `glob` with examples.
        *   **Status:** Covered.

    2.  **`access_tag`:**
        *   **Grammar:** `access_tag?` (optional).
        *   **Documentation:** Explains `:priv`, `:pub`, `:protect` and default visibility. Examples provided.
        *   **Status:** Covered.

    3.  **`assignment_list` for multiple declarations:**
        *   **Grammar allows:** Multiple comma-separated assignments (e.g., `glob a = 1, b = 2;`).
        *   **Documentation:** Examples show single declarations per statement.
        *   **Issue:** Declaring multiple global variables in a single statement is not documented.

    4.  **`assignment_list` with `named_ref` only (declaration without assignment):**
        *   **Grammar allows:** Declaration without explicit assignment (e.g., `glob my_var;`).
        *   **Documentation:** Examples show variables with initial assignments.
        *   **Issue:** Declaration of global variables without an initial assignment is not documented.

    5.  **Full complexity of `assignment` rule in `global_var`:**
        *   **Grammar uses a general `assignment` rule.**
        *   **Documentation shows:** Simple `name = expression` form.
        *   **Question/Potential Minor Issue:** Applicability of more complex assignment forms (e.g., with explicit type tags, augmented assignments) within `global_var` is not explored.
        *   **Status:** Basic global variable assignment covered; complex forms not detailed.

---

## Section 9: Free code

*   **Grammar Rules from `jac.lark`:**
    ```lark
    free_code: KW_WITH KW_ENTRY (COLON NAME)? code_block
    // code_block: LBRACE statement* RBRACE
    // statement: ... (very broad rule)
    ```
*   **Corresponding Markdown File:** `jac/examples/reference/free_code.md`
*   **Findings:**
    1.  **Basic Syntax `with entry { ... }`:**
        *   **Grammar:** `KW_WITH KW_ENTRY code_block`.
        *   **Documentation:** Shows `with entry { ... }`.
        *   **Status:** Covered.

    2.  **Named Entry Points `with entry:name { ... }`:**
        *   **Grammar:** `KW_WITH KW_ENTRY COLON NAME code_block`.
        *   **Documentation:** Shows `with entry:name { ... }`.
        *   **Status:** Covered.

    3.  **Content of `code_block` (Statements within `free_code`):**
        *   **Grammar:** `code_block` can contain any `statement*`.
        *   **Documentation:** Focuses on executable statements (assignments, function calls). It does not explicitly discuss or exemplify the use of declarative statements (like defining archetypes, abilities, or imports) *inside* a `with entry` block.
        *   **Issue/Clarification Needed:** The documentation should clarify the intended scope and limitations of statements within `free_code`. While grammatically flexible, practical or idiomatic usage might be more restricted than the grammar implies. For example, is defining an archetype inside `with entry` allowed and meaningful?

---

## Section 10: Inline python

*   **Grammar Rules from `jac.lark`:**
    ```lark
    py_code_block: PYNLINE
    PYNLINE: /::py::(.|\n|\r)*?::py::/ // Terminal
    // py_code_block is a toplevel_stmt, member_stmt, and statement
    ```
*   **Corresponding Markdown File:** `jac/examples/reference/inline_python.md`
*   **Findings:**
    1.  **Syntax `::py:: ... ::py::`:**
        *   **Grammar:** Defines the `PYNLINE` terminal.
        *   **Documentation:** Correctly shows `::py:: ... ::py::`.
        *   **Status:** Covered.

    2.  **Placement of `py_code_block`:**
        *   **Grammar:** Allows `py_code_block` at module level, within archetypes, and within general code blocks (e.g., function bodies).
        *   **Documentation:** Primarily shows module-level `py_code_block`. It does not explicitly exemplify or discuss its use *inside* archetypes or other Jac statement blocks (like function bodies).
        *   **Issue:** The documentation could be more comprehensive by illustrating the use of `py_code_block` in different scopes permitted by the grammar (e.g., inside a `can` block or an `obj` block).

---

## Section 11: Tests

*   **Grammar Rules from `jac.lark`:**
    ```lark
    test: KW_TEST NAME? code_block
    // NAME is an identifier: /[a-zA-Z_][a-zA-Z0-9_]*/
    // code_block: LBRACE statement* RBRACE
    ```
*   **Corresponding Markdown File:** `jac/examples/reference/tests.md`
*   **Findings:**
    1.  **Anonymous Test `test { ... }`:**
        *   **Grammar:** `KW_TEST code_block` (NAME is absent).
        *   **Documentation:** Shows `test { ... }`.
        *   **Status:** Covered.

    2.  **Named Test Syntax (Identifier vs. String Literal):**
        *   **Grammar:** `KW_TEST NAME code_block` (where `NAME` is an identifier).
        *   **Documentation:** Primarily shows test names as string literals (e.g., `test "descriptive test name" { ... }`).
        *   **Inconsistency/Clarification Needed:** The grammar specifies `NAME` (identifier) for test names, but documentation uses string literals. This needs clarification. If string literals are just descriptions and the actual name is different or optional, this should be explained. The `implementations.md` implies modern form:** `impl check_vehicle { ... }`.
        *   **Issue:** The "Modern `impl` Syntax" for tests (`KW_IMPL test_name`) is not explicitly shown. Clarity is needed on how `test Name;` declaration and `impl Name { ... }` interact versus the direct `test Name { ... }` grammar.

    3.  **Content of `code_block` within `test`:**
        *   **Grammar:** Allows any valid `statement*`.
        *   **Documentation:** Examples show a wide variety of Jac statements, including assignments, calls, assertions, loops, try/except, etc.
        *   **Status:** Well covered through examples.

    4.  **Separation of Test Declaration and Implementation:**
        *   **Grammar `test` rule:** Defines a test with its body directly.
        *   **Documentation (`tests.md`):** Shows tests defined with their bodies.
        *   **Documentation (`implementations.md`):** Discusses declaring tests (e.g., `test my_test_name;`) and implementing them separately.
        *   **Issue (Cross-file Context):** `tests.md` itself does not mention or cross-reference the declaration/implementation separation for tests. A brief note could improve clarity on how the `test Name;` (declaration) relates to `test Name {body}` (direct definition) or `impl Name {body}` (implementation).

---

## Section 12: Codeblocks and Statements

*   **Grammar Rules from `jac.lark`:**
    ```lark
    code_block: LBRACE statement* RBRACE

    statement: import_stmt
           | ability
           | has_stmt
           | archetype
           | impl_def
           | if_stmt
           | while_stmt
           | for_stmt
           | try_stmt
           | match_stmt
           | with_stmt
           | global_ref SEMI
           | nonlocal_ref SEMI
           | typed_ctx_block
           | return_stmt SEMI
           | (yield_expr | KW_YIELD) SEMI
           | raise_stmt SEMI
           | assert_stmt SEMI
           | check_stmt SEMI
           | assignment SEMI
           | delete_stmt SEMI
           | report_stmt SEMI
           | expression SEMI
           | ctrl_stmt SEMI
           | py_code_block
           | spatial_stmt
           | SEMI
    ```
*   **Corresponding Markdown File:** `jac/examples/reference/codeblocks_and_statements.md`
*   **Findings:**
    1.  **`code_block` Structure:**
        *   **Grammar:** `LBRACE statement* RBRACE`.
        *   **Documentation:** Shows `{ ... }` structure.
        *   **Status:** Covered.

    2.  **List of `statement` types (Overview):**
        *   **Grammar:** Provides an exhaustive list of specific statement productions.
        *   **Documentation:** Categorizes statements broadly (Declaration, Expression, Control Flow, Object-Spatial) but does not enumerate all specific types from the grammar in this overview file.
        *   **Issue/Nature of Document:** This overview could be more comprehensive by listing more specific statement types (e.g., `import_stmt`, `archetype` (as a statement), `global_ref`, `nonlocal_ref`, `typed_ctx_block`, `delete_stmt`, `report_stmt`, `ctrl_stmt` variants, `SEMI` (empty statement), `py_code_block` as a statement) or clearly stating that full details are in respective dedicated files. Many specific statement types have their own documentation pages.

    3.  **Statement Termination:**
        *   **Documentation:** States most statements need semicolons, control/block statements usually don't.
        *   **Grammar:** Shows specific `SEMI` usage.
        *   **Status:** Generally covered.

    4.  **Empty Statement `SEMI`:**
        *   **Grammar:** `statement: ... | SEMI` allows empty statements.
        *   **Documentation:** Does not explicitly mention the empty statement.
        *   **Issue:** The empty statement is not documented in this overview.

---

## Section 13: If statements

*   **Grammar Rules from `jac.lark`:**
    ```lark
    if_stmt: KW_IF expression code_block (elif_stmt | else_stmt)?
    elif_stmt: KW_ELIF expression code_block (elif_stmt | else_stmt)?
    else_stmt: KW_ELSE code_block
    ```
*   **Corresponding Markdown File:** `jac/examples/reference/if_statements.md`
*   **Findings:**
    1.  **Basic `if`:** Covered.
    2.  **`if-else`:** Covered.
    3.  **`if-elif`:** Covered.
    4.  **`if-elif-else`:** Covered.
    5.  **Multiple `elif` statements:** Covered.
    6.  **`expression` as condition:** Well covered with diverse examples.
    7.  **Mandatory `code_block`:** Covered and emphasized.

*   **Overall:** The documentation for `if_stmt` appears to be thorough and consistent with the grammar rules.

---

## Section 14: While statements

*   **Grammar Rules from `jac.lark`:**
    ```lark
    while_stmt: KW_WHILE expression code_block
    ```
*   **Corresponding Markdown File:** `jac/examples/reference/while_statements.md`
*   **Findings:**
    1.  **Basic Syntax `while condition { ... }`:** Covered.
    2.  **`expression` as Condition:** Well covered with diverse examples.
    3.  **Mandatory `code_block`:** Covered.
    4.  **Absence of `else` clause:** Consistent with grammar (correctly omitted).

*   **Overall:** The documentation for `while_stmt` is comprehensive and aligns well with the grammar rule.

---

## Section 15: For statements

*   **Grammar Rules from `jac.lark`:**
    ```lark
    for_stmt: KW_ASYNC? KW_FOR assignment KW_TO expression KW_BY assignment code_block else_stmt?
           | KW_ASYNC? KW_FOR atomic_chain KW_IN expression code_block else_stmt?
    // assignment: KW_LET? (atomic_chain EQ)+ (yield_expr | expression) | atomic_chain type_tag (EQ (yield_expr | expression))? | atomic_chain aug_op (yield_expr | expression)
    // atomic_chain: can be a simple name or a de-structuring pattern (e.g., x, y)
    // else_stmt: KW_ELSE code_block
    ```
*   **Corresponding Markdown File:** `jac/examples/reference/for_statements.md`
*   **Findings:**
    1.  **For-In Loop (`for variable in iterable`):**
        *   **Grammar:** `KW_FOR atomic_chain KW_IN expression code_block else_stmt?`.
        *   **Documentation:** Covers simple variables and de-structuring (`for index, value in ...`).
        *   **Status:** Well covered.

    2.  **For-To-By Loop (`for init to condition by increment`):**
        *   **Grammar:** `KW_FOR assignment KW_TO expression KW_BY assignment code_block else_stmt?`.
        *   **Documentation:** Shows examples like `for i=0 to i<10 by i+=1`.
        *   **Status:** Well covered.

    3.  **`KW_ASYNC` for For Loops:**
        *   **Grammar:** Allows `KW_ASYNC?` on both variants.
        *   **Documentation:** Shows `async for ... in ...`. Does not explicitly show `async for ... to ... by ...`.
        *   **Issue:** `async` for the "for-to-by" variant is not exemplified.

    4.  **`else_stmt` for For Loops:**
        *   **Grammar:** Allows `else_stmt?` on both variants.
        *   **Documentation:** No examples show a `for` loop with an `else` clause.
        *   **Issue:** The optional `else` clause for `for` loops is not documented or exemplified.

    5.  **Multi-Variable Assignment in For-To-By Initialization/Increment:**
        *   **Documentation shows:** `for i=0, j=len(array)-1 to i<j by i+=1, j-=1`.
        *   **Grammar `for_stmt` uses `assignment` rule:** The standard `assignment` rule does not directly support multiple comma-separated independent assignments (e.g., `i=0, j=val`). This looks more like an `assignment_list`.
        *   **Issue/Inconsistency:** The multi-variable example suggests the `assignment` parts in `for_stmt` might accept an `assignment_list` or a special comma-separated form not directly evident from the `assignment` rule's definition. This discrepancy needs clarification.

    6.  **Conditional Iteration (filter in for-in):**
        *   **Documentation shows:** `for item in collection if item.is_valid() { ... }`.
        *   **Grammar `for_stmt` (for-in variant):** Does not include syntax for an `if condition` filter as part of the loop definition itself.
        *   **Issue:** The `if condition` filter syntax directly in the `for ... in ...` statement is not represented in the provided `for_stmt` grammar. This might be syntactic sugar or a higher-level feature.

---

## Section 16: Try statements

*   **Grammar Rules from `jac.lark`:**
    ```lark
    try_stmt: KW_TRY code_block except_list? else_stmt? finally_stmt?
    except_list: except_def+
    except_def: KW_EXCEPT expression (KW_AS NAME)? code_block
    finally_stmt: KW_FINALLY code_block
    // else_stmt: KW_ELSE code_block
    ```
*   **Corresponding Markdown File:** `jac/examples/reference/try_statements.md`
*   **Findings:**
    1.  **Basic `try-except` (with specific exceptions):**
        *   **Grammar:** `KW_TRY code_block except_list` where `except_def` is `KW_EXCEPT expression (KW_AS NAME)? code_block`.
        *   **Documentation:** Shows examples like `except ValueError as e` and `except IOError`.
        *   **Status:** Covered.

    2.  **Multiple `except` blocks:**
        *   **Grammar:** `except_list: except_def+`.
        *   **Documentation:** Examples show multiple `except` blocks.
        *   **Status:** Covered.

    3.  **Catch-all `except` (Bare `except` vs. `except Exception`):
        *   **Documentation Syntax Overview shows:** `except { # handle any exception }` (bare except).
        *   **Documentation Example shows:** `except Exception as e { ... }`.
        *   **Grammar `except_def`:** `KW_EXCEPT expression ...` requires an `expression` (exception type).
        *   **Issue/Inconsistency:** The bare `except { ... }` syntax from the documentation overview is inconsistent with the grammar rule `except_def` which mandates an `expression`. To catch all exceptions per the current grammar, `except Exception ...` must be used, which is shown in an example.

    4.  **`else_stmt` (`else` clause for `try`):**
        *   **Grammar:** `try_stmt: ... else_stmt? ...`.
        *   **Documentation:** Explains and exemplifies the `else` clause.
        *   **Status:** Covered.

    5.  **`finally_stmt` (`finally` clause for `try`):**
        *   **Grammar:** `try_stmt: ... finally_stmt?`.
        *   **Documentation:** Explains and exemplifies the `finally` clause.
        *   **Status:** Covered.

    6.  **Combinations (e.g., `try-except-else-finally`):**
        *   **Grammar:** Allows all optional parts.
        *   **Documentation:** Syntax overview implies combinations.
        *   **Status:** Generally covered (with the bare `except` inconsistency noted).

*   **Overall:** Documentation is mostly comprehensive, with the main inconsistency being the syntax for a catch-all `except` block.

---

## Section 17: Match statements

*   **Grammar Rules from `jac.lark`:**
    ```lark
    match_stmt: KW_MATCH expression LBRACE match_case_block+ RBRACE
    match_case_block: KW_CASE pattern_seq (KW_IF expression)? COLON statement+
    // pattern_seq and specific pattern rules are defined in subsequent sections.
    ```
*   **Corresponding Markdown File:** `jac/examples/reference/match_statements.md`
*   **Findings:**
    1.  **Basic `match` statement structure (`match expr { case ... }`):**
        *   **Status:** Covered.

    2.  **`match_case_block` structure (`case pattern: statements`):**
        *   **Status:** Covered.

    3.  **`pattern_seq` (Top-level pattern in a case, e.g., OR, AS patterns):**
        *   **Documentation:** Shows examples of OR patterns (`case "a" | "b":`) and AS patterns (`case [x,y] as p:`).
        *   **Status:** Covered.

    4.  **Guard Condition (`if expression` on a case):**
        *   **Grammar:** `(KW_IF expression)?`.
        *   **Documentation:** Explains and exemplifies guarded cases (`case pattern if condition:`).
        *   **Status:** Covered.

    5.  **Overview of Pattern Types (Literal, Capture, Sequence, Mapping, Class, Singleton):**
        *   **Documentation:** Provides a good overview with examples for these common pattern types.
        *   **Status:** Good overview. Detailed analysis depends on specific pattern grammar sections.

    6.  **Wildcard `_`:**
        *   **Documentation:** Example `case _: ...` shows its use as a wildcard.
        *   **Grammar:** `capture_pattern: NAME`. Assumes `_` is a valid `NAME` with special wildcard semantics.
        *   **Status:** Usage documented.

*   **Overall:** The `match_statements.md` provides a solid introduction to match statements and seems consistent with the primary grammar rules for `match_stmt` and `match_case_block`. Detailed pattern analysis will follow with specific pattern sections.

---

## Section 18: Match patterns (Grammar Details)

*   **Grammar Rules from `jac.lark`:**
    ```lark
    pattern_seq: (or_pattern | as_pattern)
    or_pattern: (pattern BW_OR)* pattern
    as_pattern: or_pattern KW_AS NAME

    pattern: literal_pattern
        | singleton_pattern
        | capture_pattern
        | sequence_pattern
        | mapping_pattern
        | class_pattern
    ```
*   **Corresponding Markdown File:** No dedicated `match_patterns.md`. These rules are covered within `match_statements.md`.
*   **Findings:**
    1.  **`pattern_seq` (overall pattern structure in a `case`):**
        *   Covered in `match_statements.md` via "OR Patterns" and "AS Patterns" examples.
        *   **Status:** Covered.

    2.  **`or_pattern` (`pattern BW_OR pattern ...`):**
        *   Covered in `match_statements.md` ("OR Patterns" section).
        *   **Status:** Covered.

    3.  **`as_pattern` (`or_pattern KW_AS NAME`):**
        *   Covered in `match_statements.md` ("AS Patterns" section, e.g., `case [x, y] as point:`).
        *   The nuance that the LHS of `KW_AS` is an `or_pattern` (e.g., `case (A | B) as C:`) is not explicitly exemplified.
        *   **Issue (Minor):** An example of `as_pattern` with a preceding `or_pattern` involving `|` would offer more clarity.
        *   **Status:** Generally covered; could be more explicit on `or_pattern` interaction.

    4.  **`pattern` (disjunction of specific pattern types):**
        *   The concept that a `pattern` is one of literal, singleton, capture, sequence, mapping, or class pattern is introduced in `match_statements.md` under "Pattern Types".
        *   **Status:** Covered at a high level. Detailed analysis relies on specific `xxx_pattern.md` files.

*   **Overall:** The structural rules for combining patterns (OR, AS) and the main pattern categories are introduced in `match_statements.md`. No separate `match_patterns.md` file seems to exist or be strictly necessary if specific pattern files are comprehensive.

---

## Section 19: Match literal patterns

*   **Grammar Rules from `jac.lark`:**
    ```lark
    literal_pattern: (INT | FLOAT | multistring)
    // multistring: (fstring | STRING)+
    // INT, FLOAT are terminals for various number formats.
    // Note: BOOL and NULL are in singleton_pattern, not literal_pattern.
    ```
*   **Corresponding Markdown File:** `jac/examples/reference/match_literal_patterns.md`
*   **Findings:**
    1.  **Misclassification of `None` and Booleans:**
        *   **Documentation (`match_literal_patterns.md`):** Includes `true`, `false`, and `None` as examples of literal patterns.
        *   **Grammar:** Defines `literal_pattern` as `(INT | FLOAT | multistring)` and `singleton_pattern` as `(NULL | BOOL)`.
        *   **Issue:** Major inconsistency. `None` and booleans are grammatically `singleton_pattern`s and should be documented there, not under literal patterns.

    2.  **Coverage of `INT`, `FLOAT`, `STRING`:**
        *   **Numeric Literals (`INT`, `FLOAT`):** Documented examples cover decimal integers, floats, and different integer bases (hex, binary, octal), aligning with the grammar.
        *   **Status:** Covered.
        *   **String Literals (`multistring`):**
            *   Documentation shows simple string literals (e.g., `case "hello":`).
            *   The grammar `multistring: (fstring | STRING)+` allows for f-strings or concatenated strings. The behavior/validity of f-strings (which usually involve runtime interpolation) or concatenated strings as patterns is not clarified in this document.
            *   **Issue (Minor/Clarification):** The documentation should clarify if `fstring` or concatenated strings are valid in `literal_pattern` and how they are treated (e.g., if f-strings must resolve to constants at compile time).
            *   **Status (Simple Strings):** Covered.

    3.  **Interaction with OR patterns:**
        *   Documentation correctly shows literal patterns used within OR patterns (e.g., `case 400 | 401:`).
        *   **Status:** Covered.

*   **Overall:** The primary issue is the miscategorization of `None` and booleans. Coverage for true literals (numbers, simple strings) is good, but clarity on advanced `multistring` features as patterns is needed.

---

## Section 20: Match singleton patterns

*   **Grammar Rules from `jac.lark`:**
    ```lark
    singleton_pattern: (NULL | BOOL)
    // NULL: "None"
    // BOOL: "True" | "False"
    ```
*   **Corresponding Markdown File:** `jac/examples/reference/match_singleton_patterns.md`
*   **Findings:**
    1.  **Matching `None` (`NULL` token):**
        *   **Grammar:** `NULL` is part of `singleton_pattern`.
        *   **Documentation:** Shows `case None: ...`.
        *   **Status:** Covered.

    2.  **Matching Booleans (`BOOL` token):**
        *   **Grammar:** `BOOL` is part of `singleton_pattern`.
        *   **Documentation:** Shows `case True: ...` and `case False: ...`.
        *   **Status:** Covered.

    3.  **Correct Scope:**
        *   The documentation correctly focuses only on `None`, `True`, and `False` for singleton patterns, aligning with the grammar.
        *   **Status:** Correct.

*   **Overall:** The documentation for `match_singleton_patterns.md` is accurate and consistent with the grammar.

---

## Section 21: Match capture patterns

*   **Grammar Rules from `jac.lark`:**
    ```lark
    capture_pattern: NAME
    // NAME is an identifier (e.g., my_var, _)
    ```
*   **Corresponding Markdown File:** `jac/examples/reference/match_capture_patterns.md`
*   **Findings:**
    1.  **Basic Capture (`NAME` as pattern):**
        *   **Grammar:** `capture_pattern: NAME`.
        *   **Documentation:** Shows examples like `case username: ...` and `case temp: ...` where an identifier captures the matched value.
        *   **Status:** Covered.

    2.  **Wildcard `_` as a Capture Pattern:**
        *   **Documentation (`match_statements.md`):** Shows `case _: ...`.
        *   **Grammar:** If `_` is a valid `NAME` token, this is consistent. `_` as a capture pattern for unused values is a common convention.
        *   **Status:** Covered (assuming `_` is a `NAME`).

    3.  **Role in Complex Patterns:**
        *   `NAME` (as a capture mechanism) is also a fundamental part of `sequence_pattern`, `mapping_pattern`, and `class_pattern` for binding parts of those structures.
        *   **Documentation:** Examples in this file and `match_statements.md` illustrate this (e.g., `case [x,y]:`, `case {"key": val}:`).
        *   **Status:** The broader role of `NAME` in destructuring is implicitly covered by examples of those more complex patterns.

*   **Overall:** The documentation accurately reflects the use of a simple `NAME` as a capture pattern and its basic behavior. Its role within more complex patterns is also shown through examples.

---

## Section 22: Match sequence patterns

*   **Grammar Rules from `jac.lark`:**
    ```lark
    sequence_pattern: LSQUARE list_inner_pattern (COMMA list_inner_pattern)* RSQUARE
                    | LPAREN list_inner_pattern (COMMA list_inner_pattern)* RPAREN
    list_inner_pattern: (pattern_seq | STAR_MUL NAME)
    // pattern_seq -> or_pattern | as_pattern -> pattern -> specific_patterns
    // STAR_MUL NAME is for *rest type captures.
    ```
*   **Corresponding Markdown File:** No dedicated `match_sequence_patterns.md`. Overview in `match_statements.md` ("Sequence Patterns" section).
*   **Findings (based on `match_statements.md`):**
    1.  **List `[...]` and Tuple `(...)` Patterns:**
        *   **Grammar:** Defines `LSQUARE ... RSQUARE` and `LPAREN ... RPAREN`.
        *   **Documentation (`match_statements.md`):** Shows list patterns (`case [x,y]:`). Tuple patterns are mentioned as similar but not explicitly exemplified with `(...)` in that section.
        *   **Status:** List patterns covered. Tuple patterns implicitly covered but could have a direct example.

    2.  **`list_inner_pattern` (elements within the sequence):**
        *   **Grammar:** Each element can be a `pattern_seq` (complex pattern) or `STAR_MUL NAME` (`*rest`).
        *   **Documentation (`match_statements.md`):** Examples `case [x,y]:` (elements are capture patterns) and `case [first, *rest]:` (capture and star expression) cover basic cases.
        *   The ability for an inner element to be a more complex `pattern_seq` (e.g., `case [val1 | val2, another_val]:` or `case [[a,b], c]:`) is not explicitly shown in the overview.
        *   **Status:** Basic inner elements (captures, star expressions) are covered. Complex nested patterns as elements are not explicitly detailed in the overview.

    3.  **Matching Empty Sequences (`[]`, `()`):**
        *   **Grammar:** `list_inner_pattern (COMMA list_inner_pattern)*` implies at least one item is required in the pattern.
        *   **Documentation (`match_statements.md`):** Examples show patterns with one or more elements. Matching empty lists/tuples (e.g., `case []:`) is not shown or discussed.
        *   **Issue/Clarification Needed:** The grammar seems to require at least one element in sequence patterns. If matching empty sequences like `[]` or `()` is supported, the mechanism (whether by this rule through some interpretation or a different rule) needs to be clarified in grammar or documentation.

*   **Overall:** `match_statements.md` introduces basic list sequence patterns, capture of elements, and star expressions. Tuple patterns are less explicitly shown. The full recursive power of `list_inner_pattern` and matching of empty sequences are areas needing more detailed documentation or clarification against the grammar.

---

## Section 23: Match mapping patterns

*   **Grammar Rules from `jac.lark` (relevant):**
    ```lark
    mapping_pattern: LBRACE (dict_inner_pattern (COMMA dict_inner_pattern)*)? RBRACE
    dict_inner_pattern: (literal_pattern COLON pattern_seq | STAR_POW NAME)
    // literal_pattern for key: (INT | FLOAT | multistring)
    // pattern_seq for value: or_pattern | as_pattern -> pattern -> specific_patterns
    // STAR_POW NAME is for **rest captures.
    ```
    *(Note: A `list_inner_pattern` rule appears under this heading in `jac.lark` but seems misplaced and is ignored for this section.)*

*   **Corresponding Markdown File:** No dedicated `match_mapping_patterns.md`. Overview in `match_statements.md` ("Mapping Patterns" section).
*   **Findings (based on `match_statements.md`):**
    1.  **Dictionary/Mapping Pattern `{...}`:**
        *   **Grammar:** `LBRACE (dict_inner_pattern (COMMA dict_inner_pattern)*)? RBRACE`. The trailing `?` on the group allows for empty mapping patterns (`{}`).
        *   **Documentation (`match_statements.md`):** Shows examples like `case {"host": host, "port": port}:`. Does not explicitly show matching an empty dictionary `case {}:`.
        *   **Status:** Non-empty mapping patterns covered. Empty mapping pattern `{}` is allowed by grammar but not explicitly documented in the overview.

    2.  **`dict_inner_pattern` (key-value or `**rest`):**
        *   **Key-Value Pair (`literal_pattern COLON pattern_seq`):**
            *   Documentation shows simple string literal keys and capture patterns for values (e.g., `{"host": host}`).
            *   The use of more complex `pattern_seq` for values (e.g., `{"data": [x,y]}`) is implied by grammar but not explicitly shown in this section's examples.
            *   **Status:** Basic key-value matching covered.
        *   **Star-Star Expression (`STAR_POW NAME` for `**rest`):**
            *   Documentation shows `case {"url": url, **options}:`.
            *   **Status:** Covered.

    3.  **Multiple Key-Value Pairs / Optional Content:**
        *   **Grammar:** `(dict_inner_pattern (COMMA dict_inner_pattern)*)?` allows zero or more elements.
        *   **Documentation:** Examples show multiple elements. The case of zero elements (empty map `{}`) is not explicitly shown.
        *   **Status:** Covered for non-empty. Empty map matching implied by grammar but not shown.

    4.  **Keys as `literal_pattern` (Non-string keys):**
        *   **Grammar:** Keys are `literal_pattern` (`INT | FLOAT | multistring`).
        *   **Documentation:** All examples use string literal keys.
        *   **Issue (Minor/Clarification):** Use of non-string literal keys (e.g., `case {10: val}:`) is grammatically possible but not documented in the overview. This is a less common case.

*   **Overall:** `match_statements.md` introduces basic mapping patterns well. Matching empty dictionaries and using non-string literal keys are grammatically allowed but not explicitly shown in the overview. The full power of `pattern_seq` for matching values is also implied rather than exhaustively demonstrated in this section.

---

## Section 24: Match class patterns

*   **Grammar Rules from `jac.lark`:**
    ```lark
    class_pattern: NAME (DOT NAME)* LPAREN kw_pattern_list? RPAREN                 // Variant 1: Only keyword patterns
                 | NAME (DOT NAME)* LPAREN pattern_list (COMMA kw_pattern_list)? RPAREN // Variant 2: Positional and optional keyword

    pattern_list: (pattern_list COMMA)? pattern_seq    // For positional argument patterns
    kw_pattern_list: (kw_pattern_list COMMA)? named_ref EQ pattern_seq // For keyword argument patterns (attr_name = value_pattern)
    // NAME (DOT NAME)* is the class type (e.g., MyClass, module.MyClass).
    // pattern_seq for values can be complex.
    ```
*   **Corresponding Markdown File:** No dedicated `match_class_patterns.md`. Overview in `match_statements.md` ("Class Patterns" section).
*   **Findings (based on `match_statements.md`):**
    1.  **Basic Class Pattern Syntax `ClassName(...)`:**
        *   **Documentation (`match_statements.md`):** Shows `case Circle(radius=r):`. Covers simple class names.
        *   Qualified class names (e.g., `module.ClassName`) are allowed by `NAME (DOT NAME)*` in grammar but not explicitly shown in this overview.
        *   **Status:** Basic structure with simple names covered.

    2.  **Keyword Argument Patterns (`attr=pattern`):**
        *   **Grammar:** Covered by `kw_pattern_list`.
        *   **Documentation (`match_statements.md`):** Examples like `Circle(radius=r)` and `Rectangle(width=w, height=h)` clearly demonstrate this.
        *   **Status:** Covered.

    3.  **Positional Argument Patterns:**
        *   **Grammar:** Covered by `pattern_list` in the second variant of `class_pattern`.
        *   **Documentation (`match_statements.md`):** This overview does not show examples of positional patterns (e.g., `case MyClass(pattern_for_arg1, pattern_for_arg2):`).
        *   **Issue:** Positional patterns in class matching are not documented in the overview.

    4.  **Combination of Positional and Keyword Patterns:**
        *   **Grammar:** Allowed by the second variant of `class_pattern`.
        *   **Documentation:** Not shown, as positional patterns themselves are not shown.
        *   **Issue:** Not documented.

    5.  **Matching Type Only (`ClassName()`):**
        *   **Grammar:** Seems possible via the first `class_pattern` variant if `kw_pattern_list` is omitted (due to `?`).
        *   **Documentation (`match_statements.md`):** Does not show an example like `case MyClass():` for type-only matching.
        *   **Issue (Minor/Clarification):** Type-only matching is a common use case and an explicit example would be beneficial.

    6.  **Complex `pattern_seq` for Attribute Values:**
        *   **Grammar:** Allows complex patterns for attribute values (e.g., `radius=(val1 | val2)` or `data=[x,y]`).
        *   **Documentation (`match_statements.md`):** Examples use simple capture patterns (e.g., `radius=r`). Matching attributes against more complex nested patterns is not explicitly shown in the overview.
        *   **Status:** Basic capture of attribute values covered. Complex patterns for attribute values implied by grammar but not detailed in overview.

*   **Overall:** The `match_statements.md` overview introduces class patterns focusing on keyword-based attribute matching. Positional attribute matching, type-only matching, and matching attributes against more complex patterns are not explicitly covered in this overview but are allowed by the grammar.

---

## Section 25: Context managers

*   **Grammar Rules from `jac.lark`:**
    ```lark
    with_stmt: KW_ASYNC? KW_WITH expr_as_list code_block
    expr_as_list: (expr_as COMMA)* expr_as
    expr_as: expression (KW_AS expression)?
    ```
*   **Corresponding Markdown File:** `jac/examples/reference/context_managers.md`
*   **Findings:**
    1.  **Basic `with` statement (`with expr as var` and `with expr`):**
        *   **Grammar:** `KW_WITH expr_as_list code_block`. `expr_as` can optionally have `KW_AS expression`.
        *   **Documentation:** Shows both `with open(...) as file:` and `with self.lock:`. Covers cases with and without `as var`.
        *   **Status:** Covered.

    2.  **`KW_ASYNC` with `with` statement:**
        *   **Grammar:** `KW_ASYNC? KW_WITH ...`.
        *   **Documentation:** Shows `async with ... as ...`.
        *   **Status:** Covered.

    3.  **Multiple context managers (`with expr1 as var1, expr2 as var2`):**
        *   **Grammar:** `expr_as_list: (expr_as COMMA)* expr_as`.
        *   **Documentation:** Shows examples with multiple context managers in one `with` statement.
        *   **Status:** Covered.

    4.  **Variable in `expr_as` (Target of `KW_AS expression`):**
        *   **Grammar:** `KW_AS expression`. Allows the target to be an `expression`.
        *   **Documentation:** All examples show `... as variable_name` (a simple `NAME`).
        *   **Issue/Clarification:** The grammar is broader, potentially allowing targets like `my_obj.attr` or even de-structuring assignments if the `expression` rule and semantic analysis permit. The documentation only shows simple name targets. If only simple names are intended or idiomatic, this could be clarified, or the grammar for the target of `KW_AS` might be more specific in practice.

    5.  **Custom Context Managers (Defining `__enter__`, `__exit__`):**
        *   **Documentation:** Provides good examples of creating custom context manager objects.
        *   **Status:** Well covered.

*   **Overall:** The documentation aligns well with the grammar for common uses. The main point needing potential clarification is the scope of the `expression` allowed as the target variable after `KW_AS`.

---

## Section 26: Global and nonlocal statements

*   **Grammar Rules from `jac.lark`:**
    ```lark
    global_ref: GLOBAL_OP name_list
    nonlocal_ref: NONLOCAL_OP name_list
    name_list: (named_ref COMMA)* named_ref

    GLOBAL_OP: /:g:|:global:/
    NONLOCAL_OP: /:nl:|:nonlocal:/
    // These are used in statement rule as: global_ref SEMI, nonlocal_ref SEMI
    ```
*   **Corresponding Markdown File:** `jac/examples/reference/global_and_nonlocal_statements.md`
*   **Findings:**
    1.  **Global Statement Syntax (`:g:`, `:global:`):**
        *   **Grammar:** `GLOBAL_OP name_list`.
        *   **Documentation:** Shows syntax with `:g:` and `:global:`, and examples with single and multiple variables.
        *   **Status:** Covered.

    2.  **Nonlocal Statement Syntax (`:nl:`, `:nonlocal:`):**
        *   **Grammar:** `NONLOCAL_OP name_list`.
        *   **Documentation:** Shows syntax with `:nl:` and `:nonlocal:`, and examples with single and multiple variables.
        *   **Status:** Covered.

    3.  **`name_list` (List of variables):**
        *   **Grammar:** `(named_ref COMMA)* named_ref`.
        *   **Documentation:** Examples use simple variable names, which is typical.
        *   **Status:** Covered for typical usage.

    4.  **Statement Termination (Semicolon):**
        *   **Grammar:** Requires a `SEMI` as these are statements (`global_ref SEMI`, `nonlocal_ref SEMI`).
        *   **Documentation:** The syntax overview correctly includes semicolons (e.g., `:g: counter, total;`). However, some inline code examples in the text body occasionally omit the semicolon.
        *   **Issue (Minor Inconsistency):** Some examples in the text body should be updated to consistently include the trailing semicolon for these statements.

*   **Overall:** The documentation accurately describes the global and nonlocal statements. The primary minor issue is the inconsistent presence of semicolons in some textual examples, which should be rectified for grammatical accuracy.

---

## Section 27: Data spatial typed context blocks

*   **Grammar Rules from `jac.lark`:**
    ```lark
    typed_ctx_block: RETURN_HINT expression code_block
    // RETURN_HINT is "->"
    // expression is the type expression.
    // code_block is { ... }.
    // This rule is a type of statement.
    ```
*   **Corresponding Markdown File:** `jac/examples/reference/data_spatial_typed_context_blocks.md`
*   **Findings:**
    1.  **Syntax `-> type_expression { ... }`:**
        *   **Grammar:** `RETURN_HINT expression code_block`.
        *   **Documentation:** Correctly shows the syntax `-> type_expression { ... }` and provides examples like `-> dict[str, any] { ... }`.
        *   **Status:** Covered.

    2.  **Purpose and Usage (Type-Constrained Scope):**
        *   **Documentation:** Explains its use for compile-time and runtime type assertions within the block, especially for object-spatial operations (e.g., constraining `here.data`).
        *   **Status:** Well-explained.

    3.  **As a Statement:**
        *   **Grammar:** `typed_ctx_block` is a `statement`.
        *   **Documentation:** Examples show its use within ability bodies. Its ability to be used in other nested contexts (e.g., inside an `if`) is implied by its nature as a statement.
        *   **Status:** Primary usage covered.

    4.  **Interaction with Ability Return Types:**
        *   **Documentation:** The section "Return Type Enforcement" shows a `typed_ctx_block` within an ability that has a return type, with the `return` statement inside the typed block.
        *   **Clarification Needed:** The phrasing about the block "guaranteeing" the return type might be slightly imprecise. The block enforces type constraints on the code *within* it. If a `return` statement is inside this block, the returned value will be checked against the block's type. The block itself isn't a return mechanism but a type-constrained scope.
        *   **Status:** Example is valid; explanation could be more precise about the mechanism of enforcement.

*   **Overall:** The documentation clearly explains the syntax and primary purpose. The explanation of its role in return type enforcement is understandable through the example but could be refined for precision.

---

## Section 28: Return statements

*   **Grammar Rules from `jac.lark`:**
    ```lark
    return_stmt: KW_RETURN expression?
    // Used in statement rule as: return_stmt SEMI
    ```
*   **Corresponding Markdown File:** `jac/examples/reference/return_statements.md`
*   **Findings:**
    1.  **Return with an expression (`return expression;`):**
        *   **Grammar Form:** `KW_RETURN expression SEMI`.
        *   **Documentation:** Shows `return expression;` and provides numerous examples.
        *   **Status:** Covered.

    2.  **Return without an expression (`return;` for void functions/abilities):**
        *   **Grammar Form:** `KW_RETURN SEMI`.
        *   **Documentation:** Shows `return;` and explains it yields `None`.
        *   **Status:** Covered.

    3.  **Statement Termination (Semicolon):**
        *   **Grammar:** Requires a `SEMI` when used as a statement.
        *   **Documentation:** Syntax overview and most examples correctly include the semicolon.
        *   **Status:** Covered.

    4.  **Nature of `expression`:**
        *   **Grammar:** `expression` can be any valid Jac expression.
        *   **Documentation:** Examples show various types of expressions being returned (literals, variables, calculations, tuples, dictionaries).
        *   **Status:** Well covered.

*   **Overall:** The documentation for `return_stmt` is comprehensive and accurately reflects the grammar and common usage patterns.

---

## Section 29: Yield statements

*   **Grammar Rules from `jac.lark`:**
    ```lark
    yield_expr: KW_YIELD KW_FROM? expression
    // Used in statement rule as: (yield_expr | KW_YIELD) SEMI
    // This resolves to three forms for statements:
    // 1. KW_YIELD KW_FROM expression SEMI  (yield from ...)
    // 2. KW_YIELD expression SEMI          (yield ...)
    // 3. KW_YIELD SEMI                     (yield; / yield None)
    ```
*   **Corresponding Markdown File:** `jac/examples/reference/yield_statements.md`
*   **Findings:**
    1.  **Yield an expression (`yield expression;`):**
        *   **Grammar Form:** `KW_YIELD expression SEMI`.
        *   **Documentation:** Shows `yield expression;` and provides numerous examples.
        *   **Status:** Covered.

    2.  **Bare yield / Yield None (`yield;`):**
        *   **Grammar Form:** `KW_YIELD SEMI`.
        *   **Documentation:** Shows `yield;` and explains it yields `None`.
        *   **Status:** Covered.

    3.  **Yield from an iterable (`yield from expression;`):**
        *   **Grammar Form:** `KW_YIELD KW_FROM expression SEMI`.
        *   **Documentation:** Shows `yield from iterable;` and provides examples with other generators and collections.
        *   **Status:** Covered.

    4.  **Statement Termination (Semicolon):**
        *   **Grammar:** All forms require a `SEMI` when used as a statement.
        *   **Documentation:** Syntax overview and most examples correctly include the semicolon.
        *   **Status:** Generally covered.

    5.  **Generator Function Characteristics:**
        *   **Documentation:** Accurately describes how functions with `yield` become generators, their execution model, and state persistence.
        *   **Status:** Well explained.

*   **Overall:** The documentation for yield statements and generator functions is comprehensive and aligns accurately with the grammar rules.

---

## Section 30: Raise statements

*   **Grammar Rules from `jac.lark`:**
    ```lark
    raise_stmt: KW_RAISE (expression (KW_FROM expression)?)?
    // Used in statement rule as: raise_stmt SEMI
    // This resolves to three forms for statements:
    // 1. KW_RAISE expression SEMI                 (raise new/specific exception)
    // 2. KW_RAISE SEMI                            (re-raise current exception)
    // 3. KW_RAISE expression KW_FROM expression SEMI (raise new with cause)
    ```
*   **Corresponding Markdown File:** `jac/examples/reference/raise_statements.md`
*   **Findings:**
    1.  **Raise a specific exception (`raise expression;`):**
        *   **Grammar Form:** `KW_RAISE expression SEMI`.
        *   **Documentation:** Shows `raise exception_expression;` and provides examples like `raise ValueError(...)`.
        *   **Status:** Covered.

    2.  **Re-raise current exception (`raise;`):**
        *   **Grammar Form:** `KW_RAISE SEMI`.
        *   **Documentation:** Shows `raise;` and explains its use in `except` blocks.
        *   **Status:** Covered.

    3.  **Raise with cause (`raise expression from cause_expression;`):**
        *   **Grammar Form:** `KW_RAISE expression KW_FROM expression SEMI`.
        *   **Documentation:** Shows `raise exception_expression from cause;` and examples with an exception variable or `None` as the cause.
        *   **Status:** Covered.

    4.  **Statement Termination (Semicolon):**
        *   **Grammar:** All forms require a `SEMI` when used as a statement.
        *   **Documentation:** Syntax overview and most examples correctly include the semicolon.
        *   **Status:** Generally covered.

    5.  **Nature of `expression` for exception/cause:**
        *   **Documentation:** Examples show instantiation of exception classes or existing exception variables, which is standard.
        *   **Status:** Well covered.

*   **Overall:** The documentation for raise statements is comprehensive and accurately reflects the grammar and common usage patterns for all three forms of the raise statement.

---

## Section 31: Assert statements

*   **Grammar Rules from `jac.lark`:**
    ```lark
    assert_stmt: KW_ASSERT expression (COMMA expression)?
    // Used in statement rule as: assert_stmt SEMI
    ```
*   **Corresponding Markdown File:** `jac/examples/reference/assert_statements.md`
*   **Findings:**
    1.  **Assert with condition only (`assert condition;`):**
        *   **Grammar Form:** `KW_ASSERT expression SEMI`.
        *   **Documentation:** Shows `assert condition;`.
        *   **Status:** Covered.

    2.  **Assert with condition and message (`assert condition, message_expr;`):**
        *   **Grammar Form:** `KW_ASSERT expression COMMA expression SEMI`.
        *   **Documentation:** Shows `assert condition, "Custom error message";`.
        *   **Status:** Covered.

    3.  **Statement Termination (Semicolon):**
        *   **Grammar:** Requires a `SEMI` when used as a statement.
        *   **Documentation:** Syntax examples correctly include the semicolon.
        *   **Status:** Covered.

    4.  **Nature of `expression` for condition and message:**
        *   **Documentation:** Condition is shown as a boolean expression; message is shown as a string literal. This is typical.
        *   **Status:** Covered for typical usage.

*   **Overall:** The documentation for assert statements is clear, concise, and accurately aligns with the grammar and common usage.

---

## Section 32: Check statements

*   **Grammar Rules from `jac.lark`:**
    ```lark
    check_stmt: KW_CHECK expression
    // Used in statement rule as: check_stmt SEMI
    ```
*   **Corresponding Markdown File:** `jac/examples/reference/check_statements.md`
*   **Findings:**
    1.  **Basic Syntax (`check expression;`):**
        *   **Grammar Form:** `KW_CHECK expression SEMI`.
        *   **Documentation:** Shows `check expression;`.
        *   **Status:** Covered.

    2.  **Nature of `expression`:**
        *   **Documentation:** Explains the expression should be truthy. Examples show various boolean conditions.
        *   **Status:** Well covered.

    3.  **Integration with Test Blocks:**
        *   **Documentation:** Emphasizes use within `test` blocks.
        *   **Status:** Contextual usage well explained.

    4.  **Statement Termination (Semicolon):**
        *   **Grammar:** Requires a `SEMI`.
        *   **Documentation:** Syntax and examples correctly include the semicolon.
        *   **Status:** Covered.

*   **Overall:** The documentation for `check_stmt` is clear and aligns well with the grammar, properly explaining its use in testing.

---

## Section 33: Delete statements

*   **Grammar Rules from `jac.lark`:**
    ```lark
    delete_stmt: KW_DELETE expression
    // Used in statement rule as: delete_stmt SEMI
    // expression can be various things like variable names, attributes, list/dict elements.
    // Separately, there's disconnect_op: KW_DELETE edge_op_ref for specific edge deletions in expressions.
    ```
*   **Corresponding Markdown File:** `jac/examples/reference/delete_statements.md`
*   **Findings:**
    1.  **Basic Syntax (`del expression;`):**
        *   **Grammar:** `KW_DELETE expression SEMI`.
        *   **Documentation:** Shows `del expression;`.
        *   **Status:** Covered.

    2.  **Nature of `expression` (What can be deleted):**
        *   **Documentation:** Provides good examples for deleting variables, object properties, list elements/slices, dictionary entries, and nodes.
        *   **Status:** Well covered for many common cases.

    3.  **Deleting Multiple Variables (`del a, b, c;`):**
        *   **Documentation shows:** `del a, b, c;`.
        *   **Grammar `delete_stmt`:** `KW_DELETE expression` expects a single expression.
        *   **Issue/Inconsistency:** The example `del a, b, c;` doesn't directly map to `KW_DELETE expression` if `expression` doesn't support a top-level comma-separated list of deletable items. Python's `del` does support this. This might imply `expression` can be a tuple of references or a special parsing for `del`.

    4.  **Deleting Edges (Specific Syntaxes):**
        *   **Documentation shows:** `del source_node -->:EdgeType:--> target_node;` and `del node [-->];`.
        *   **Grammar:** These edge specifications are forms of `edge_ref_chain` (an expression). So `del <edge_ref_chain_expr>;` would fit the `delete_stmt` rule.
        *   The grammar also has `disconnect_op: KW_DELETE edge_op_ref` used within `connect` expressions, which is different. The documentation examples appear to be standalone statements, fitting `delete_stmt`.
        *   **Status:** Likely covered by `delete_stmt` if the edge specification is a valid `expression` yielding the edge(s) to delete. Clarity on whether these specific syntaxes always resolve to an expression suitable for the general `del expression` statement would be good.

    5.  **Statement Termination (Semicolon):**
        *   **Grammar:** Requires `SEMI`.
        *   **Documentation:** Syntax overview and most examples include the semicolon.
        *   **Status:** Generally covered.

*   **Overall:** The documentation covers many uses of `del`. The main ambiguity lies in the `del a, b, c;` syntax relative to the grammar and how specific edge deletion syntaxes are parsed as the `expression` in `del expression`.

---

## Section 35: Control statements

*   **Grammar Rules from `jac.lark`:**
    ```lark
    ctrl_stmt: KW_SKIP | KW_BREAK | KW_CONTINUE
    // Used in statement rule as: ctrl_stmt SEMI
    ```
*   **Corresponding Markdown File:** `jac/examples/reference/control_statements.md`
*   **Findings:**
    1.  **`KW_BREAK` (break statement):**
        *   **Grammar:** `KW_BREAK SEMI`.
        *   **Documentation:** Explains usage and provides examples.
        *   **Status:** Covered.

    2.  **`KW_CONTINUE` (continue statement):**
        *   **Grammar:** `KW_CONTINUE SEMI`.
        *   **Documentation:** Explains usage and provides examples.
        *   **Status:** Covered.

    3.  **`KW_SKIP` (skip statement):**
        *   **Grammar:** `KW_SKIP SEMI`. Listed as a general `ctrl_stmt`.
        *   **Documentation (`control_statements.md`):** States `skip` is a "Data spatial equivalent for walker traversal control (covered in walker statements documentation)" and does not detail it further in this file.
        *   **Issue/Clarification Needed:** If `KW_SKIP` is a general control statement (like `break`/`continue`), its documentation is missing here. If it's exclusively for walker contexts, its placement in the grammar under the general `ctrl_stmt` (rather than a more walker-specific rule) could be refined for clarity. The current documentation defers its explanation.

    4.  **Statement Termination (Semicolon):**
        *   **Grammar:** Requires `SEMI` for `ctrl_stmt`.
        *   **Documentation:** Examples for `break;` and `continue;` correctly include the semicolon.
        *   **Status:** Covered for `break` and `continue`.

*   **Overall:** `break` and `continue` are well-documented. The documentation for `skip` is deferred. The main point is ensuring its grammatical classification aligns with its intended scope of use (general control flow vs. walker-specific).

---

## Section 36: Data spatial Walker statements

*   **Grammar Rules from `jac.lark`:**
    ```lark
    spatial_stmt: visit_stmt | ignore_stmt | disenage_stmt // Likely typo for disengage_stmt
    // These are then defined as:
    // visit_stmt: KW_VISIT (COLON expression COLON)? expression (else_stmt | SEMI)
    // ignore_stmt: KW_IGNORE expression SEMI
    // disenage_stmt: KW_DISENGAGE SEMI // KW_DISENGAGE is "disengage"
    // spatial_stmt is a type of statement, implying it uses SEMI if not ending in a block.
    ```
*   **Corresponding Markdown File:** `jac/examples/reference/data_spatial_walker_statements.md`
*   **Findings:**
    1.  **General Overview:** The document correctly introduces `visit`, `ignore`, and `disengage` as key walker control statements.

    2.  **`visit_stmt`:**
        *   **Grammar:** `KW_VISIT (COLON expression COLON)? expression (else_stmt | SEMI)`.
        *   **Documentation Syntax shows:**
            *   `visit expression;` (matches grammar: no filter, with `SEMI`).
            *   `visit :expression: expression;` (matches grammar: with filter, with `SEMI`).
            *   `visit expression else { ... }` (matches grammar: no filter, with `else_stmt`).
        *   **Missing Combination:** An example combining the edge filter and an `else` clause (e.g., `visit :filter_expr: target_expr else { ... };`) is not explicitly shown, though allowed by grammar.
        *   **Status:** Mostly covered. Semicolons should be explicit in syntax definitions.

    3.  **`ignore_stmt`:**
        *   **Grammar:** `KW_IGNORE expression SEMI`.
        *   **Documentation Syntax:** `ignore expression;` (semicolon is appropriate).
        *   **Status:** Covered.

    4.  **`disengage_stmt` (Grammar typo `disenage_stmt`):**
        *   **Grammar:** `disenage_stmt: KW_DISENGAGE SEMI`. Assuming `disenage_stmt` is a typo for `disengage_stmt`.
        *   **Documentation Syntax:** `disengage;` (semicolon is appropriate).
        *   **Keyword:** Documentation `disengage` matches `KW_DISENGAGE` token.
        *   **Status:** Covered (assuming grammar rule name typo is fixed).

    5.  **Statement Termination (Semicolon):**
        *   The individual grammar rules for `ignore_stmt` and `disengage_stmt` correctly include `SEMI`. `visit_stmt` can end in `SEMI` or an `else_stmt` (block).
        *   **Documentation:** Generally reflects this, though syntax summaries could be more explicit about semicolons for `ignore` and filtered `visit` if not ending in `else`.
        *   **Status:** Generally correct.

*   **Overall:** The documentation aligns well with the individual grammar rules for `visit`, `ignore`, and `disengage` (assuming the `disenage_stmt` typo correction). The purpose of these statements in walker control is clearly explained.

---

## Section 37: Visit statements

*   **Grammar Rule:** `visit_stmt: KW_VISIT (COLON expression COLON)? expression (else_stmt | SEMI)`
*   **Corresponding Markdown File:** `jac/examples/reference/visit_statements.md`
*   **Findings:**
    *   This statement was analyzed as part of **Section 36: Data spatial Walker statements**.
    *   The `visit_statements.md` file reiterates the common forms: `visit expression;` and `visit expression else { ... }`.
    *   It mentions edge filtering but does not prominently feature the `visit :filter_expr: target_expr;` syntax in its own syntax block, nor the combination of filtering with an `else` clause.
    *   **Overall:** The specific documentation is consistent with the broader points made in Section 36. The primary uncovered grammatical combination is `visit :filter: target else { ... };`.

---

## Section 38: Ignore statements

*   **Grammar Rule:** `ignore_stmt: KW_IGNORE expression SEMI`
*   **Corresponding Markdown File:** `jac/examples/reference/ignore_statements.md`
*   **Findings:**
    *   This statement was analyzed as part of **Section 36: Data spatial Walker statements**.
    *   The `ignore_statements.md` file is consistent with the grammar, showing `ignore expression;`.
    *   **Overall:** Consistent with Section 36 and the grammar.

---

## Section 39: Disengage statements

*   **Grammar Rule:** `disenage_stmt: KW_DISENGAGE SEMI` (Assuming `disenage_stmt` is a typo for `disengage_stmt`)
*   **Corresponding Markdown File:** `jac/examples/reference/disengage_statements.md`
*   **Findings:**
    *   This statement was analyzed as part of **Section 36: Data spatial Walker statements**.
    *   The `disengage_statements.md` file is consistent with the grammar (assuming typo fix), showing `disengage;`.
    *   **Overall:** Consistent with Section 36 and the grammar (with typo assumption).

---

## Section 40: Assignments

*   **Grammar Rules from `jac.lark`:**
    ```lark
    assignment: KW_LET? (atomic_chain EQ)+ (yield_expr | expression)  // Form 1
              | atomic_chain type_tag (EQ (yield_expr | expression))? // Form 2
              | atomic_chain aug_op (yield_expr | expression)          // Form 3

    aug_op: RSHIFT_EQ | LSHIFT_EQ | BW_NOT_EQ | BW_XOR_EQ | BW_OR_EQ | BW_AND_EQ | MOD_EQ | DIV_EQ | FLOOR_DIV_EQ | MUL_EQ | SUB_EQ | ADD_EQ | MATMUL_EQ | STAR_POW_EQ
    // Used in statement rule as: assignment SEMI
    ```
*   **Corresponding Markdown File:** `jac/examples/reference/assignments.md`
*   **Findings:**
    1.  **Form 1 (Basic/Chained Assignment `[let] x = y = z = value`):**
        *   Basic assignment (`value = 42;`): Covered.
        *   Chained assignment (`x = y = z = 0;`): Covered.
        *   `let` with basic assignment (`let counter = 0;`): Covered.
        *   `let` with chained assignment (e.g., `let x = y = 0;`): Not explicitly shown, though grammatically allowed. Minor omission.

    2.  **Form 2 (Typed Assignment/Declaration `x: type [= value]`):**
        *   Typed assignment with initialization (`let count: int = 0;`): Covered.
        *   Typed declaration without immediate initialization (`let my_var: str;`): Not explicitly exemplified, though grammatically allowed by `(EQ ...)?`.
        *   **Issue:** Typed declaration without init is not shown.

    3.  **Form 3 (Augmented Assignment `x += value`):**
        *   **Documentation:** Covers Arithmetic, Bitwise, and Matrix augmented assignments with examples.
        *   **Status:** Well covered.

    4.  **`yield_expr` on RHS of Assignment:**
        *   **Grammar:** Allows `yield_expr` (e.g., `x = yield val;`).
        *   **Documentation:** Does not show examples of assigning `yield` or `yield from` expressions.
        *   **Issue:** Assignment of `yield_expr` is not documented.

    5.  **Destructuring Assignment:**
        *   **Documentation shows:** `let (x, y) = coordinates;` and `let (first, *rest) = items;`. These are standard and likely parsable by `atomic_chain` on LHS.
        *   **Documentation also shows:** `let (name=user, age=years) = user_data;`. This syntax for LHS destructuring is highly unconventional for assignment and resembles keyword argument patterns in calls or match cases. Its parsing via `atomic_chain` as an LHS target is unclear.
        *   **Issue/Inconsistency:** The `(name=user, age=years) = ...` destructuring syntax is problematic for assignment and needs clarification or correction in the documentation to align with typical LHS assignment capabilities or Jac-specific rules if it is indeed valid.

    6.  **Statement Termination (Semicolon):**
        *   **Grammar:** `assignment SEMI`.
        *   **Documentation:** Examples correctly include semicolons.
        *   **Status:** Covered.

*   **Overall:** Common assignments are well-documented. Areas for improvement include: `let` with chained assignment, typed declaration without init, assignment of `yield_expr`, and significant clarification/correction for the `(name=user, age=years)` destructuring assignment example.

---

## Section 41: Expressions (Top-Level Rule)

*   **Grammar Rules from `jac.lark`:**
    ```lark
    expression: concurrent_expr (KW_IF expression KW_ELSE expression)?
              | lambda_expr
    ```
*   **Corresponding Markdown File:** `jac/examples/reference/expressions.md`
*   **Findings:**
    1.  **Conditional Expression (Ternary `... if ... else ...`):**
        *   **Grammar:** `concurrent_expr (KW_IF expression KW_ELSE expression)?`.
        *   **Documentation:** Lists and exemplifies conditional expressions (`result = value if condition else alternative;`).
        *   **Status:** Covered.

    2.  **Lambda Expression (`lambda_expr`):**
        *   **Grammar:** `lambda_expr` is an alternative for `expression`.
        *   **Documentation:** Mentions lambda expressions. The example syntax `lambda n: Node : n.is_active()` needs to be compared with the specific `lambda_expr` grammar rule and its documentation.
        *   **Status:** Mentioned; specific syntax example needs cross-verification.

    3.  **Delegation to `concurrent_expr` and Hierarchy:**
        *   **Grammar:** If not a conditional or lambda, an `expression` is a `concurrent_expr`, which then cascades to other expression types.
        *   **Documentation:** The "Expression Hierarchy" list correctly reflects this delegation to more specific expression forms.
        *   **Status:** Hierarchical nature outlined.

    4.  **Nature of `expressions.md` Document:**
        *   Provides a high-level overview, lists precedence categories, and gives basic examples. It defers detailed explanations of specific expression types to their own sections/documents.
        *   **Status:** Serves as a suitable introduction.

*   **Overall:** The `expressions.md` file correctly introduces the top-level structure of Jac expressions and the hierarchy. Detailed analysis of each expression type will follow in subsequent sections based on their specific grammar rules and documentation.

---

## Section 42: Concurrent expressions

*   **Grammar Rules from `jac.lark`:**
    ```lark
    concurrent_expr: (KW_FLOW | KW_WAIT)? walrus_assign
    // KW_FLOW: "flow"
    // KW_WAIT: "wait"
    ```
*   **Corresponding Markdown File:** `jac/examples/reference/concurrent_expressions.md`
*   **Findings:**
    1.  **`KW_FLOW` modifier (`flow expression`):**
        *   **Grammar:** `KW_FLOW walrus_assign`.
        *   **Documentation:** Explains and shows `flow` used to initiate parallel execution of expressions (typically function calls or `spawn`).
        *   **Status:** Covered.

    2.  **`KW_WAIT` modifier (`wait expression` or `var = wait expression`):**
        *   **Grammar:** `KW_WAIT walrus_assign`.
        *   **Documentation:** Explains and shows `wait` used to synchronize and retrieve results from parallel operations/futures.
        *   **Status:** Covered.

    3.  **No modifier (plain `walrus_assign`):**
        *   **Grammar:** `concurrent_expr` defaults to `walrus_assign` if no keyword is present.
        *   **Documentation:** This is the standard non-concurrent expression path, implicitly covered as the base.
        *   **Status:** Implicitly covered.

    4.  **Nature of `walrus_assign` with `flow`/`wait`:**
        *   **Documentation:** Examples focus on applying `flow` and `wait` to operations like function calls, `spawn`, or variables holding task/future references, which are sensible uses.
        *   **Status:** Aligns with practical usage.

*   **Overall:** The documentation for `concurrent_expr`, particularly the `flow` and `wait` keywords, effectively explains their purpose and usage in enabling concurrency, and is consistent with the grammar.

---

## Section 43: Walrus assignments

*   **Grammar Rules from `jac.lark`:**
    ```lark
    walrus_assign: (named_ref WALRUS_EQ)? pipe
    // WALRUS_EQ: ":="
    // named_ref is typically a simple variable name.
    ```
*   **Corresponding Markdown File:** `jac/examples/reference/walrus_assignments.md`
*   **Findings:**
    1.  **With `named_ref WALRUS_EQ` (e.g., `(name := expression)`):**
        *   **Grammar:** `named_ref WALRUS_EQ pipe`.
        *   **Documentation:** Clearly shows and explains usage like `if (count := len(items)) > 0 { ... }`.
        *   **Status:** Covered.

    2.  **Without `named_ref WALRUS_EQ` (plain `pipe` expression):**
        *   **Grammar:** `walrus_assign` defaults to `pipe` if `(named_ref WALRUS_EQ)?` is absent.
        *   **Documentation:** This is the standard expression path, implicitly covered as the base for walrus assignment.
        *   **Status:** Implicitly covered.

    3.  **`named_ref` as target:**
        *   **Grammar:** Target is `named_ref`.
        *   **Documentation:** Examples use simple variable names, which is typical.
        *   **Status:** Covered for typical usage.

    4.  **Scope of Walrus-Assigned Variable:**
        *   **Documentation:** Correctly states variables extend beyond the immediate expression scope, following standard scoping rules.
        *   **Status:** Behavior explained.

*   **Overall:** The documentation for walrus assignments (`:=`) is clear, consistent with the grammar, and accurately explains its common use cases and scoping rules.

---

## Section 44: Lambda expressions

*   **Grammar Rules from `jac.lark`:**
    ```lark
    lambda_expr: KW_LAMBDA func_decl_params? (RETURN_HINT expression)? COLON expression
    func_decl_params: (param_var COMMA)* param_var COMMA?
    param_var: (STAR_POW | STAR_MUL)? named_ref type_tag (EQ expression)?
    // type_tag: COLON expression (e.g., : int)
    ```
*   **Corresponding Markdown File:** `jac/examples/reference/lambda_expressions.md`
*   **Findings:**
    1.  **Basic Syntax (`lambda params : expression`):**
        *   **Documentation:** Shows `lambda a: int, b: int : b + a;`. This aligns with the grammar where parameters require type annotations (`named_ref type_tag`).
        *   **Status:** Covered.

    2.  **Advanced Parameter Features (`func_decl_params?`):**
        *   **Grammar:** `func_decl_params?` (and `param_var` details) allow for:
            *   No parameters (e.g., `lambda : "value"`).
            *   `*args`, `**kwargs`.
            *   Default parameter values (e.g., `lambda x: int = 5 : x`).
        *   **Documentation (`lambda_expressions.md`):** Does not exemplify these variations for lambdas. It emphasizes mandatory type annotations for named parameters shown.
        *   **Issue:** Undocumented features for lambda parameters (no-params, *args/**kwargs, default values) if they are intended to be supported as per the shared `func_decl_params` rule.

    3.  **Explicit Return Type Annotation (`(RETURN_HINT expression)?`):**
        *   **Grammar:** Allows an optional explicit return type (e.g., `lambda x: int -> int : x * 2`).
        *   **Documentation (`lambda_expressions.md`):** States return types are inferred and does not show the syntax for explicit return type annotation on lambdas.
        *   **Issue:** Explicit return type annotation for lambdas is not documented.

    4.  **Lambda Body (Single `expression`):**
        *   **Grammar:** `COLON expression`.
        *   **Documentation:** Correctly states and shows that the lambda body is limited to a single expression.
        *   **Status:** Covered.

    5.  **Inconsistent Lambda Example in `expressions.md`:**
        *   The example `lambda n: Node : n.is_active()` from `expressions.md` uses a syntax (`param_name : param_type_name : body`) that is inconsistent with the `param_var` rule (`named_ref type_tag`, where `type_tag` is `: type_expr`) and the examples in `lambda_expressions.md` (which correctly show `lambda name: type : body`).
        *   **Issue:** The lambda example in `expressions.md` needs correction to align with the formal grammar and the dedicated lambda documentation.

*   **Overall:** `lambda_expressions.md` covers basic lambdas with typed parameters. However, it omits several parameter features and explicit return types that the grammar seems to permit. The example in `expressions.md` is also inconsistent.

---

## Section 45: Pipe expressions

*   **Grammar Rules from `jac.lark`:**
    ```lark
    pipe: (pipe PIPE_FWD)? pipe_back
    // PIPE_FWD: "|>"
    // pipe_back is the next level of precedence (or can involve PIPE_BKWD).
    ```
*   **Corresponding Markdown File:** `jac/examples/reference/pipe_expressions.md`
*   **Findings:**
    1.  **Forward Pipe Operator `|>` (`PIPE_FWD`):**
        *   **Grammar:** `pipe PIPE_FWD pipe_back` (left-recursive structure).
        *   **Documentation:** Explains it passes the left expression's result as the first argument to the right expression. Numerous examples show chaining `expr |> func1 |> func2`.
        *   **Status:** Covered.

    2.  **Base of the Pipe (`pipe_back`):**
        *   **Grammar:** If no `PIPE_FWD` is used, `pipe` resolves to `pipe_back`.
        *   **Documentation:** The initial data/expression in a pipe chain, or expressions not using pipes, are implicitly this base case.
        *   **Status:** Implicitly covered.

    3.  **Associativity and Structure:**
        *   The grammar implies left-associativity for `|>` (e.g., `(a |> b) |> c`).
        *   **Documentation:** Examples and textual descriptions align with this left-to-right flow.
        *   **Status:** Consistent.

    4.  **Operands of `|>`:**
        *   **Documentation:** Shows piping into named functions, lambdas, and object methods.
        *   **Status:** Common use cases well demonstrated.

*   **Overall:** The documentation for the forward pipe operator `|>` is excellent, clearly explaining its syntax, semantics, and benefits with diverse examples. It aligns well with the grammar.

---

## Section 46: Pipe back expressions

*   **Grammar Rules from `jac.lark`:**
    ```lark
    pipe_back: (pipe_back PIPE_BKWD)? bitwise_or
    // PIPE_BKWD: "<|"
    // bitwise_or is the next level of precedence.
    ```
*   **Corresponding Markdown File:** `jac/examples/reference/pipe_back_expressions.md`
*   **Findings:**
    1.  **Backward Pipe Operator `<|` (`PIPE_BKWD`):**
        *   **Grammar:** `pipe_back PIPE_BKWD bitwise_or` (left-recursive structure for the operator itself).
        *   **Documentation:** Explains it passes the right expression's result as an argument (conventionally the last) to the left expression/function. Examples show right-to-left data flow: `result = format <| process <| data;`.
        *   **Status:** Covered.

    2.  **Base of the Pipe Back (`bitwise_or`):**
        *   **Grammar:** If no `PIPE_BKWD` is used, `pipe_back` resolves to `bitwise_or`.
        *   **Documentation:** The rightmost data/expression in a `<|` chain is implicitly this base case.
        *   **Status:** Implicitly covered.

    3.  **Associativity and Data Flow:**
        *   The grammar implies left-associativity for the `<|` operator: `( (c <| b) <| a )`.
        *   The documented data flow is right-to-left, which is achieved by how the arguments are passed. This is consistent.
        *   **Status:** Consistent.

    4.  **Operands of `<|`:**
        *   **Documentation:** Examples show callables (functions/methods) on the left and data/results on the right.
        *   **Status:** Common use cases demonstrated.

    5.  **Combining with Forward Pipes `|>`:**
        *   **Documentation:** Shows examples of combining `<|` and `|>` using parentheses for grouping, e.g., `formatter <| (data |> clean |> transform)`.
        *   **Status:** Covered.

*   **Overall:** The documentation for the backward pipe operator `<|` effectively explains its syntax, right-to-left data flow semantics, and contrasts it with the forward pipe. It aligns well with the grammar.

---

## Section 47: Bitwise expressions

*   **Grammar Rules from `jac.lark`:**
    ```lark
    bitwise_or: (bitwise_or BW_OR)? bitwise_xor
    bitwise_xor: (bitwise_xor BW_XOR)? bitwise_and
    bitwise_and: (bitwise_and BW_AND)? shift
    shift: (shift (RSHIFT | LSHIFT))? logical_or // `logical_or` here is likely a placeholder for a higher precedence numerical term.
    // Unary BW_NOT is in `factor`: (BW_NOT | MINUS | PLUS) factor | connect
    // BW_OR: "|", BW_XOR: "^", BW_AND: "&", RSHIFT: ">>", LSHIFT: "<<", BW_NOT: "~"
    ```
*   **Corresponding Markdown File:** `jac/examples/reference/bitwise_expressions.md`
*   **Findings:**
    1.  **Binary Bitwise Operators (`&`, `|`, `^`, `<<`, `>>`):**
        *   **Grammar:** Defines rules giving precedence: `shift` > `&` > `^` > `|`.
        *   **Documentation:** Covers all these operators with examples and correct precedence.
        *   **Status:** Covered and consistent.

    2.  **Unary Bitwise NOT (`~`):**
        *   **Grammar:** Defined in `factor` rule, giving it high precedence.
        *   **Documentation:** Covers `~` with an example and places it highest in bitwise precedence.
        *   **Status:** Covered and consistent.

    3.  **Operand for Shift Operators (Grammar's `logical_or`):**
        *   **Grammar:** `shift: (shift (RSHIFT | LSHIFT))? logical_or`.
        *   The use of `logical_or` as the operand for `shift` is unusual if it refers to the boolean logical OR operation, due to precedence. It likely refers to a higher-precedence term that evaluates to a number.
        *   **Documentation:** Examples use integer literals as operands for shifts (e.g., `5 << 1`), which is standard.
        *   **Issue (Potential Grammar Ambiguity/Typo):** The term `logical_or` in the `shift` rule definition in the provided grammar snippet is potentially misleading. Assuming it correctly resolves to a numerical operand in the full grammar, the documentation is fine.

*   **Overall:** The documentation accurately describes the standard bitwise operators and their precedence. The primary point of concern is the potentially misnamed `logical_or` rule in the `shift` production in the grammar, but the documented examples use typical numerical operands.

---

## Section 48: Logical and compare expressions

*   **Grammar Rules from `jac.lark`:**
    ```lark
    logical_or: logical_and (KW_OR logical_and)*
    logical_and: logical_not (KW_AND logical_not)*
    logical_not: NOT logical_not | compare
    compare: (arithmetic cmp_op)* arithmetic // For chained comparisons like a < b < c

    cmp_op: KW_ISN | KW_IS | KW_NIN | KW_IN | NE | GTE | LTE | GT | LT | EE
    // KW_OR: /\|\||or/, KW_AND: /&&|and/, NOT: "not"
    ```
*   **Corresponding Markdown File:** `jac/examples/reference/logical_and_compare_expressions.md`
*   **Findings:**
    1.  **Logical OR (`or`, `||`):** Covered.
    2.  **Logical AND (`and`, `&&`):** Covered.
    3.  **Logical NOT (`not`):** Covered.

    4.  **Comparison Operators (`cmp_op`):**
        *   **Documentation lists:** `==`, `!=`, `<`, `<=`, `>`, `>=`, `is`, `in`.
        *   **Grammar also includes:** `KW_ISN` (is not) and `KW_NIN` (not in).
        *   **Issue:** `is not` and `not in` are not explicitly listed as comparison operators in the documentation's summary, though they are in the grammar.

    5.  **Chained Comparisons (e.g., `0 <= value <= 100`):**
        *   **Grammar:** `(arithmetic cmp_op)* arithmetic` supports this.
        *   **Documentation:** Explains and exemplifies chained comparisons.
        *   **Status:** Covered.

    6.  **Precedence:**
        *   Grammar implies standard precedence: `compare` > `NOT` > `AND` > `OR`.
        *   **Documentation:** Does not explicitly state precedence but examples are consistent.
        *   **Status (Minor):** Explicit precedence table could be useful.

    7.  **Short-Circuit Evaluation:**
        *   **Documentation:** Correctly explains for `and` and `or`.
        *   **Status:** Behavior explained.

*   **Overall:** The documentation covers most logical and comparison operations well. The main omission is the explicit listing of `is not` and `not in` in the comparison operator summary.

---

## Section 49: Arithmetic expressions

*   **Grammar Rules from `jac.lark`:**
    ```lark
    arithmetic: (arithmetic (MINUS | PLUS))? term
    term: (term (MOD | DIV | FLOOR_DIV | STAR_MUL | DECOR_OP))? power
    power: (power STAR_POW)? factor
    factor: (BW_NOT | MINUS | PLUS) factor | connect
    // DECOR_OP is "@"
    ```
*   **Corresponding Markdown File:** `jac/examples/reference/arithmetic_expressions.md`
*   **Findings:**
    1.  **Binary Arithmetic Operators (`+`, `-`, `*`, `/`, `//`, `%`, `**`):**
        *   **Grammar:** Defines these with standard precedence: `**` > (`*`,`/`,`//`,`%`,`@`) > (`+`,`-`).
        *   **Documentation:** Covers all these (except `@`) with correct relative precedence.
        *   **Status:** Covered (except for `@`).

    2.  **Unary Plus/Minus (`+x`, `-x`):**
        *   **Grammar (`factor` rule):** Places unary `+`/`-` (and `~`) at a very high precedence, effectively making them part of the `factor` before `power` (`**`) is applied.
        *   **Documentation:** States unary `+`/`-` have precedence *below* `**` but above `*`/`/`.
        *   **Issue/Inconsistency:** Discrepancy in precedence of unary `+`/`-` relative to `**`. Grammar implies `(-2)**4`, documentation implies `-(2**4)`. Standard behavior is usually `-(2**4)`.

    3.  **`DECOR_OP` (`@`) - Matrix Multiplication:**
        *   **Grammar:** Includes `DECOR_OP` (`@`) in the `term` rule, at same precedence as `*`, `/`.
        *   **Documentation (`arithmetic_expressions.md`):** Does not list or exemplify the `@` operator.
        *   **Issue:** The `@` (matrix multiplication) operator is not documented in this file.

    4.  **Parentheses for Grouping:**
        *   **Documentation:** Correctly states parentheses have the highest precedence and can be used to override defaults.
        *   **Status:** Covered.

*   **Overall:** Common binary arithmetic operators are well-documented. Key issues are the precedence of unary minus/plus with respect to exponentiation, and the omission of the `@` (matrix multiplication) operator from the documentation.

---

## Section 50: Connect expressions

*   **Grammar Rules from `jac.lark`:**
    ```lark
    connect: (connect (connect_op | disconnect_op))? atomic_pipe
    connect_op: connect_from | connect_to | connect_any // Uses CARROW variants like ++>, +>:, etc.
    disconnect_op: KW_DELETE edge_op_ref // Uses ARROW variants like -->, <-:, etc.
    // atomic_pipe is the operand.
    ```
*   **Corresponding Markdown File:** `jac/examples/reference/connect_expressions.md`
*   **Findings:**
    1.  **Basic Connection (`source ++> destination`):**
        *   **Grammar:** `atomic_pipe connect_op atomic_pipe` (where `connect_op` is `connect_to` using `CARROW_R`).
        *   **Documentation:** Covers simple connections like `source ++> destination`.
        *   **Status:** Covered.

    2.  **Typed/Property Connections (`source +>:Type:prop=val:+> dest`):**
        *   **Grammar:** Uses detailed forms of `connect_op` (e.g., `CARROW_R_P1 expression (COLON kw_expr_list)? CARROW_R_P2`).
        *   **Documentation:** Explains and exemplifies creating typed edges with properties.
        *   **Status:** Covered.

    3.  **Directionality of Connections (`++>`, `<++`, `<++>`):**
        *   **Grammar:** Handled by `connect_to`, `connect_from`, `connect_any` using `CARROW_R`, `CARROW_L`, `CARROW_BI`.
        *   **Documentation:** Lists these directionalities.
        *   **Status:** Covered.

    4.  **`disconnect_op` (`KW_DELETE edge_op_ref`) within `connect` expressions:**
        *   **Grammar:** `disconnect_op` is an alternative to `connect_op` in the `connect` rule, suggesting expressions like `node1 ++> node2 del node2 --> node3` might be possible if `connect` expressions can be chained and have results.
        *   **Documentation (`connect_expressions.md`):** Focuses on creating connections. Does not cover `disconnect_op` or using `del` with edge syntax as part of a connect *expression*.
        *   **Documentation (`delete_statements.md`):** Covers `del <edge_spec>;` as a standalone statement.
        *   **Issue/Clarification Needed:** The role and behavior of `disconnect_op` as part of the `connect` expression rule is undocumented and potentially confusing given `del` for edges is also a standalone statement. It's unclear how an expression like `KW_DELETE edge_op_ref` would evaluate or chain within a `connect` expression sequence.

    5.  **Chaining of Connect/Disconnect Operations:**
        *   **Grammar:** `connect: (connect (connect_op | disconnect_op))? atomic_pipe` implies left-associative chaining.
        *   **Documentation:** Shows sequential construction of chains (e.g., in loops) rather than single complex chained expressions involving multiple different operators.
        *   **Status:** Basic connection chaining is implicitly shown; complex mixed chains are not detailed.

*   **Overall:** Documentation for creating connections (`connect_op`) is thorough. The `disconnect_op` part of the `connect` expression grammar is not covered in this file and its interaction as an expression component versus a standalone delete statement needs clarification.

---

## Section 51: Atomic expressions (Atomic Pipe Forward :>)

*   **Grammar Rules from `jac.lark`:**
    ```lark
    // The heading is "Atomic expressions", but the rule immediately following is atomic_pipe.
    atomic_pipe: (atomic_pipe A_PIPE_FWD)? atomic_pipe_back
    // A_PIPE_FWD: ":>"
    // atomic_pipe_back is the next level of precedence.
    ```
*   **Corresponding Markdown File:** `jac/examples/reference/atomic_expressions.md`
*   **Findings:**
    1.  **Atomic Pipe Forward Operator `:>` (`A_PIPE_FWD`):**
        *   **Grammar:** `atomic_pipe A_PIPE_FWD atomic_pipe_back` (left-recursive structure).
        *   **Documentation:** Explains and shows the `:>` operator for chaining operations, e.g., `"Hello world!" :> print;`. The semantics (passing LHS as argument to RHS callable) are similar to `|>`.
        *   **Status:** Covered.

    2.  **Base of the Atomic Pipe (`atomic_pipe_back`):**
        *   **Grammar:** `atomic_pipe` resolves to `atomic_pipe_back` if no `:>` is used.
        *   **Documentation:** Initial elements in a `:>` chain are implicitly this base.
        *   **Status:** Implicitly covered.

    3.  **Associativity:**
        *   Grammar implies left-associativity for `:>`.
        *   **Documentation:** Examples like `"Welcome" :> type :> print;` are consistent.
        *   **Status:** Consistent.

    4.  **Documentation Scope vs. Title ("Atomic expressions")**:
        *   **Documentation File Title:** `atomic_expressions.md`.
        *   **Content:** Primarily describes the `atomic_pipe` (`:>`) operator.
        *   **Grammar:** The true "atomic" units (literals, names, `(...)`) are defined under the `atom` rule much later in the grammar. The heading "Atomic expressions" in `jac.lark` is immediately followed by the `atomic_pipe` rule, not rules for literals/variables directly.
        *   **Issue (Documentation Scope/Naming):** The file `atomic_expressions.md` documents the `:>` operator. The general intro in the doc about "fundamental and indivisible units ... literals, identifiers" better describes what the grammar calls `atom`. This file focuses on a specific pipe operator rather than the broad category of all atomic/primary expressions.

*   **Overall:** The `:>` operator (atomic pipe forward) is well-documented and aligns with its grammar rule (`atomic_pipe`). The main point of note is that the documentation file titled "Atomic expressions" describes this specific pipe operator, not the broader category of fundamental atoms like literals or variable names, which appear under a different grammar heading ("Atom").

---

## Section 52: Atomic pipe back expressions

*   **Grammar Rules from `jac.lark`:**
    ```lark
    atomic_pipe_back: (atomic_pipe_back A_PIPE_BKWD)? ds_spawn
    // A_PIPE_BKWD: "<:"
    // ds_spawn is the next level of precedence.
    ```
*   **Corresponding Markdown File:** `jac/examples/reference/atomic_pipe_back_expressions.md`
*   **Findings:**
    1.  **Atomic Pipe Back Operator `<:` (`A_PIPE_BKWD`):**
        *   **Grammar:** `atomic_pipe_back A_PIPE_BKWD ds_spawn` (left-recursive structure for the operator).
        *   **Documentation:** Explains it passes the RHS data as an argument to the LHS callable, with right-to-left data flow (e.g., `print <: "Hello world!";`).
        *   **Status:** Covered.

    2.  **Base of the Atomic Pipe Back (`ds_spawn`):**
        *   **Grammar:** `atomic_pipe_back` resolves to `ds_spawn` if no `<:` is used.
        *   **Documentation:** The rightmost data/expression in a `<:` chain is implicitly this base.
        *   **Status:** Implicitly covered.

    3.  **Associativity and Data Flow:**
        *   Grammar implies left-associativity for the `<:` operator: `(func2 <: func1) <: data`.
        *   Documented data flow is right-to-left, which is consistent with evaluation order.
        *   **Status:** Consistent.

    4.  **Combining with Atomic Pipe Forward (`:>`):**
        *   **Documentation:** Shows examples like `len <: a + b :> len;` and `result = function1 <: data :> function2;`.
        *   The grammar `atomic_pipe: ... atomic_pipe_back` and `atomic_pipe_back: ... ds_spawn` implies `<:` (in `atomic_pipe_back`) binds tighter than `:>` (in `atomic_pipe`). This precedence is consistent with how the examples are likely intended to be parsed.
        *   **Status:** Covered and consistent with grammar precedence.

*   **Overall:** The documentation for the atomic pipe back operator `<:` clearly explains its syntax and right-to-left data flow, and its interaction with the atomic pipe forward operator. It aligns well with the grammar.

---

## Section 53: Data spatial spawn expressions

*   **Grammar Rules from `jac.lark`:**
    ```lark
    ds_spawn: (ds_spawn KW_SPAWN)? unpack
    // KW_SPAWN: "spawn"
    // unpack is the next level of precedence.
    ```
*   **Corresponding Markdown File:** `jac/examples/reference/data_spatial_spawn_expressions.md`
*   **Findings:**
    1.  **`KW_SPAWN` Operator:**
        *   **Grammar:** `ds_spawn KW_SPAWN unpack` (left-recursive structure for the operator).
        *   **Documentation:** Explains `spawn` for activating walkers. Shows both `walker_instance spawn location;` and `location spawn walker_instance;`, stating they achieve the same result. This is consistent with `KW_SPAWN` as a binary operator.
        *   **Status:** Covered.

    2.  **Base of Spawn (`unpack`):**
        *   **Grammar:** `ds_spawn` resolves to `unpack` if no `KW_SPAWN` is used.
        *   **Documentation:** Operands of `spawn` (walker instances, locations) are implicitly `unpack` expressions.
        *   **Status:** Implicitly covered.

    3.  **Chaining `spawn` Operations:**
        *   **Grammar:** The left-recursive structure `(ds_spawn KW_SPAWN)? unpack` allows for chaining (e.g., `a spawn b spawn c`).
        *   **Documentation:** Does not show examples of chaining multiple `spawn` keywords in a single expression. It shows multiple separate spawn statements.
        *   **Clarification Needed:** The semantic meaning of a chained spawn expression like `(walker1 spawn node1) spawn walker2` is not obvious or documented. While grammatically parsable, its practical use is unclear. The `spawn` operation primarily has side effects, and its direct result (if any as an expression) is usually related to collecting reports, not further spawning.

*   **Overall:** The documentation effectively explains the `spawn` operation for activating walkers with either operand order (walker or location first), which aligns with the grammar. The practical application of chained `spawn` operators within a single expression remains undocumented and unclear.

---

## Section 54: Unpack expressions

*   **Grammar Rules from `jac.lark`:**
    ```lark
    unpack: STAR_MUL? ref
    // STAR_MUL is "*"
    // ref is the next level of precedence.
    // This rule specifically covers *iterable unpacking.
    // **mapping unpacking is handled by other rules (e.g., kw_expr, kv_pair using STAR_POW).
    ```
*   **Corresponding Markdown File:** `jac/examples/reference/unpack_expressions.md`
*   **Findings:**
    1.  **Iterable Unpacking (`*iterable`):**
        *   **Grammar:** `unpack: STAR_MUL? ref` correctly defines `*ref`.
        *   **Documentation:** Explains and shows examples like `[*items]` or `func(*args)`.
        *   **Status:** Covered and consistent with the grammar rule.

    2.  **Mapping Unpacking (`**mapping`):**
        *   **Documentation (`unpack_expressions.md`):** Describes and exemplifies mapping unpacking using `**` (e.g., `{**dict1, **dict2}` or `func(**kwargs)`).
        *   **Grammar (`unpack` rule):** The rule `unpack: STAR_MUL? ref` does **not** include syntax for `**` (mapping unpacking). Mapping unpacking with `STAR_POW` is defined in other specific grammar rules: `kw_expr` (for function call keyword arguments) and `kv_pair` (for dictionary literals).
        *   **Issue (Major Documentation/Grammar Rule Mismatch):** The documentation file `unpack_expressions.md` is titled broadly and includes `**` mapping unpacking. However, the specific grammar rule `unpack` presented under the same heading in `jac.lark` only covers `*` iterable unpacking. This creates a mismatch: the doc is broader than this particular rule.
        *   **Clarification:** The documentation should clarify that while `*` is handled by the `unpack` expression rule (which then becomes part of general expressions), `**` unpacking occurs in specific contexts like dictionary literals and function call arguments, governed by different grammar rules (`kv_pair`, `kw_expr`).

    3.  **Base of Unpack (`ref`):**
        *   **Grammar:** If `STAR_MUL?` is absent, `unpack` is `ref`.
        *   **Documentation:** Operands of `*` are `ref` expressions. This is implicit.
        *   **Status:** Implicitly covered.

*   **Overall:** The grammar rule `unpack: STAR_MUL? ref` correctly defines `*iterable` unpacking. The documentation file `unpack_expressions.md` accurately describes `*iterable` unpacking. However, this documentation also covers `**mapping` unpacking, which is grammatically handled by different rules (`kv_pair`, `kw_expr`) using `STAR_POW`, not by this specific `unpack` rule. This makes the scope of the `unpack` rule versus the `unpack_expressions.md` document inconsistent regarding `**`.

---

## Section 55: References (unused)

*   **Grammar Rules from `jac.lark`:**
    ```lark
    ref: BW_AND? pipe_call
    // BW_AND is "&"
    // pipe_call is the next level of precedence.
    ```
*   **Corresponding Markdown File:** `jac/examples/reference/references_(unused).md`
*   **Findings:**
    1.  **`ref` Rule and `BW_AND` (`&`) Operator:**
        *   **Grammar:** Defines `ref` as an optional `&` followed by a `pipe_call`.
        *   **Documentation:** Explicitly states that this `ref` rule, particularly the `&` operator for creating references (e.g., `&value`), is **"currently defined but not actively utilized in the language implementation"** and is **"unused"**.
        *   **Status:** This is a direct statement about a non-operational grammar feature. This is not an inconsistency but important documentation of the language's current state.

    2.  **Passthrough to `pipe_call`:**
        *   **Grammar:** If the optional `BW_AND?` is not used, `ref` simply becomes `pipe_call`.
        *   **Documentation:** States, "Current implementation uses `pipe_call` directly."
        *   **Status:** Consistent with the `&` part being unused. In the expression hierarchy, `ref` effectively serves as a direct link to `pipe_call`.

*   **Overall:** The documentation clearly indicates that the `&` (address-of/reference) operator, though defined in the `ref` grammar rule, is an unused feature in the current Jac language. This is a crucial piece of information for understanding the effective grammar.

---

## Section 56: Data spatial calls

*   **Grammar Rules from `jac.lark`:**
    ```lark
    pipe_call: (PIPE_FWD | A_PIPE_FWD | KW_SPAWN | KW_AWAIT)? atomic_chain
    // PIPE_FWD: "|>", A_PIPE_FWD: ":>", KW_SPAWN: "spawn", KW_AWAIT: "await"
    // atomic_chain is the next level of precedence (function calls, attribute access, etc.)
    ```
*   **Corresponding Markdown File:** `jac/examples/reference/data_spatial_calls.md`
*   **Findings:**
    This `pipe_call` grammar rule presents significant inconsistencies with how `|>` (pipe fwd), `:>` (atomic pipe fwd), and `spawn` are defined and used elsewhere in the grammar and documentation.

    1.  **Unary Prefix Interpretation vs. Binary Operator Nature:**
        *   **`pipe_call` Grammar:** Suggests `|>` `atomic_chain`, `:>` `atomic_chain`, and `spawn` `atomic_chain` are valid (treating them as optional unary prefixes).
        *   **Contradictory Grammar Rules:**
            *   `pipe: (pipe PIPE_FWD)? pipe_back` (defines `|>` as binary).
            *   `atomic_pipe: (atomic_pipe A_PIPE_FWD)? atomic_pipe_back` (defines `:>` as binary).
            *   `ds_spawn: (ds_spawn KW_SPAWN)? unpack` (defines `spawn` as binary).
        *   **Documentation (`data_spatial_calls.md` and others):** Consistently shows `|>` , `:>`, and `spawn` used as binary operators (e.g., `data |> func`, `walker spawn node`).
        *   **Issue (Major Grammar Inconsistency):** The `pipe_call` rule treating `|>` , `:>`, and `spawn` as optional unary prefixes is fundamentally inconsistent with their established binary operator nature in other parts of the grammar and all documentation examples.

    2.  **`KW_AWAIT` (`await`):**
        *   **`pipe_call` Grammar:** `(KW_AWAIT)? atomic_chain` is plausible, as `await` is a unary prefix operator.
        *   **Documentation:** Standard `await expression` usage is documented elsewhere (e.g., `functions_and_abilities.md`). `data_spatial_calls.md` mentions `await` for synchronization but provides no specific syntax example itself for this rule.
        *   **Status for `await`:** The `await atomic_chain` part aligns with `await` being unary. This is the only part of the optional prefixes in `pipe_call` that seems grammatically sound in isolation.

    3.  **`atomic_chain` as the base:**
        *   If no prefix is used, `pipe_call` resolves to `atomic_chain`. This is standard.
        *   **Status:** Base case is fine.

*   **Overall (Major Issues with `pipe_call` rule):**
    *   The `pipe_call` grammar rule, as written, is largely incorrect or misleading for `PIPE_FWD`, `A_PIPE_FWD`, and `KW_SPAWN` by suggesting they can be unary prefixes to `atomic_chain`.
    *   This rule seems to be in conflict with the primary definitions and documented usage of these operators.
    *   The `KW_AWAIT` prefix is the only one that aligns with standard operator behavior (unary prefix).
    *   The documentation in `data_spatial_calls.md` itself describes `|>` and `spawn` in their correct binary operator sense, further highlighting the problem with the `pipe_call` grammar rule.
    *   This rule likely needs significant revision or clarification on its intended purpose, as it does not reflect the actual usage of these operators.

---

## Section 57: Subscripted and dotted expressions (atomic_chain)

*   **Grammar Rules from `jac.lark`:**
    ```lark
    atomic_chain: atomic_chain NULL_OK? (filter_compr | assign_compr | index_slice) // Form 1: obj?[...] or obj?(filter/assign)
                | atomic_chain NULL_OK? (DOT_BKWD | DOT_FWD | DOT) named_ref      // Form 2: obj?.attr, obj?.<attr, obj?.>attr
                | (atomic_call | atom | edge_ref_chain)                            // Form 3: Base cases (call, primary, edge_ref)
    // NULL_OK: "?", DOT: ".", DOT_BKWD: "<.", DOT_FWD: ".>"
    // index_slice involves [...] for indexing/slicing.
    // filter_compr and assign_compr are specific (...) forms.
    ```
*   **Corresponding Markdown File:** `jac/examples/reference/subscripted_and_dotted_expressions.md`
*   **Findings:**
    1.  **Dotted Expressions (Attribute Access - Form 2):**
        *   **Standard Dot (`.`):** Covered, including null-safe `?.` (e.g., `car.model`, `user?.address`).
        *   **Directional Dots (`.>`, `.<`):** Mentioned for forward/backward piping attribute access, but not deeply exemplified in this document.
        *   **Status:** Standard dot access well covered. Directional dots mentioned.

    2.  **Subscripted Expressions (`index_slice` - Form 1 part):**
        *   **Grammar:** `atomic_chain NULL_OK? index_slice`. `index_slice` includes `LSQUARE ... RSQUARE` for indexing/slicing and also `list_val`.
        *   **Documentation:** Covers standard indexing (`letters[0]`) and slicing (`letters[1:3]`, `letters[::2]`) well, including null-safe `?.[]`.
        *   The `list_val` alternative within `index_slice` (e.g., potentially for `obj[[1,2]]` style indexing) is not documented.
        *   **Issue (Minor):** `list_val` as an `index_slice` form is not covered.
        *   **Status:** Standard indexing/slicing well covered.

    3.  **Special Comprehensions (`filter_compr`, `assign_compr` - Form 1 part):**
        *   **Grammar:** `atomic_chain NULL_OK? (filter_compr | assign_compr)`. These are `(...)` forms distinct from function calls.
        *   **Documentation (`subscripted_and_dotted_expressions.md`):** Does not cover these. They are expected to be documented under the "Special Comprehensions" grammar heading.
        *   **Status:** Not covered in this document (deferred).

    4.  **Base Cases (Form 3 - `atomic_call | atom | edge_ref_chain`):**
        *   These are the starting points of an `atomic_chain` (e.g., a function call, a literal, a variable name, an edge reference).
        *   **Documentation:** This document focuses on the chaining operators (`.` `[]`) rather than exhaustively detailing the base forms, which have their own grammar sections/documentation.
        *   **Status:** Implicitly handled as the operands for dot/subscript operations.

*   **Overall:** This document effectively covers standard attribute access and list/dictionary subscripting, including their null-safe versions. Directional dot operators are mentioned. The special `filter_compr` and `assign_compr` syntaxes, and the `list_val` form of `index_slice`, are not covered here.

---

## Section 58: Index slice (details of the rule)

*   **Grammar Rule from `jac.lark`:**
    ```lark
    index_slice: LSQUARE                                                             \
                         expression? COLON expression? (COLON expression?)?          \
                         (COMMA expression? COLON expression? (COLON expression?)?)* \
                  RSQUARE
               | list_val
    // list_val is a list literal, e.g., [a, b, c]
    ```
*   **Corresponding Markdown File:** No dedicated file. Discussed under `subscripted_and_dotted_expressions.md`.
*   **Findings (Detailed analysis of the `index_slice` rule):**
    1.  **Basic Indexing and Slicing (Single component):**
        *   The grammar `expression? COLON expression? (COLON expression?)?` supports forms like `[index]`, `[start:stop]`, `[:stop]`, `[start:]`, `[start:stop:step]`, `[::step]`, `[:]`.
        *   **Documentation (`subscripted_and_dotted_expressions.md`):** Covers these 1D indexing and slicing forms well with examples.
        *   **Status:** Covered.

    2.  **Comma-Separated Multi-Dimensional Indexing/Slicing:**
        *   The grammar part `(COMMA expression? COLON expression? (COLON expression?)?)*` allows for multiple comma-separated index/slice components within a single `[]` pair (e.g., `matrix[row_idx, col_idx]`, `tensor[slice1, slice2, index3]`).
        *   **Documentation (`subscripted_and_dotted_expressions.md`):** Does not show or discuss this multi-dimensional access syntax using commas within a single `[]`.
        *   **Issue:** Comma-separated multi-dimensional indexing/slicing is a significant capability of the `index_slice` grammar rule that is not documented.

    3.  **`list_val` as an Index (Fancy Indexing):**
        *   **Grammar:** `index_slice: ... | list_val`. Allows a list literal (e.g., `[idx1, idx2]`) to be used as the index itself, e.g., `data[[idx1, idx2, idx3]]`.
        *   **Documentation (`subscripted_and_dotted_expressions.md`):** Does not show or discuss using a list literal directly within the square brackets for indexing (often called "fancy indexing" or "advanced indexing").
        *   **Issue:** The `list_val` alternative for `index_slice`, enabling list-based fancy indexing, is not documented.

*   **Overall:** While basic 1D indexing and slicing are documented, the `index_slice` grammar rule supports more advanced features like comma-separated multi-dimensional access and list-based fancy indexing, which are currently not covered in the documentation.

---

## Section 59: Function calls (atomic_call)

*   **Grammar Rules from `jac.lark`:**
    ```lark
    atomic_call: atomic_chain LPAREN param_list? (KW_BY atomic_call)? RPAREN

    param_list: expr_list COMMA kw_expr_list COMMA?  // Positional, then keyword
              | kw_expr_list COMMA?                  // Only keyword
              | expr_list COMMA?                     // Only positional

    expr_list: (expr_list COMMA)? expression
    kw_expr_list: (kw_expr_list COMMA)? kw_expr
    kw_expr: named_ref EQ expression | STAR_POW expression // kw=val or **kwargs
    // `expression` in `expr_list` can be `unpack` for *args.
    ```
*   **Corresponding Markdown File:** `jac/examples/reference/function_calls.md`
*   **Findings:**
    1.  **Basic Syntax and Callables (`atomic_chain(...)`):**
        *   Covers calls to simple functions, methods (`obj.method()`), and chained calls (`obj.meth1().meth2()`).
        *   **Status:** Covered.

    2.  **Parameter Lists (`param_list?`):**
        *   **Positional Arguments (`expr_list`):** Documented, including `*args` unpacking (though `*args` example often cited from `unpack_expressions.md`).
        *   **Keyword Arguments (`kw_expr_list`):** Documented (`name=value`), including `**kwargs` unpacking (example often from `unpack_expressions.md`).
        *   **Mixed Arguments:** Documented.
        *   **Trailing Commas:** Grammar allows optional trailing commas in `param_list` variants. Not explicitly shown in documentation examples.
        *   **Issue (Minor):** Optional trailing commas in argument lists are not explicitly documented.
        *   **Status:** Argument types (positional, keyword, *args, **kwargs) well covered.

    3.  **`KW_BY atomic_call` Suffix:**
        *   **Grammar:** `atomic_call` can end with `(KW_BY atomic_call)? RPAREN`. This suggests a syntax like `func1(args) by func2(other_args)`.
        *   **Documentation (`function_calls.md`):** Does not document or exemplify this `by <another_call>` feature within a function call.
        *   **Issue:** The `KW_BY atomic_call` part of the function call syntax is not documented. Its purpose and semantics in this context are unknown from the docs.

*   **Overall:** Standard function call mechanisms are thoroughly documented. The main omissions are the optional trailing comma in argument lists and the entire `KW_BY atomic_call` feature, which was also seen undocumented in `block_tail` for function/ability definitions.

---

## Section 60: Atom

*   **Grammar Rules from `jac.lark`:**
    ```lark
    atom: named_ref
        | LPAREN (expression | yield_expr) RPAREN  // Parenthesized expr/yield
        | atom_collection                           // List, dict, set, tuple literals/compr
        | atom_literal                              // Numeric, string, bool, null, ellipsis literals
        | type_ref                                  // `type_name or `builtin_type

    atom_literal: builtin_type | NULL | BOOL | multistring | ELLIPSIS | FLOAT | OCT | BIN | HEX | INT
    type_ref: TYPE_OP (named_ref | builtin_type) // TYPE_OP is "`"
    // multistring includes fstring and STRING.
    ```
*   **Corresponding Markdown File:** `jac/examples/reference/atom.md`
*   **Findings:**
    1.  **`named_ref` (Identifiers):** Covered.
    2.  **Parenthesized Expressions:** Covered.
    3.  **`atom_collection` (Collection Literals - basic):** Basic list/tuple literals mentioned. Full scope deferred.
        *   **Status:** Partially covered (overview).
    4.  **`atom_literal` (Literals - This has several issues in the doc):**
        *   **String literals & F-strings (`multistring`):** Covered.
        *   **Boolean literals (`BOOL`):** Covered (`True`, `False`).
        *   **Numeric literals (`INT`, `FLOAT`, `HEX`, `BIN`, `OCT`):**
            *   **Documentation Error:** `atom.md` shows `bin(12)` and `hex(78)` (function calls) for binary/hex literals instead of the correct literal syntax (e.g., `0b1100`, `0x4E`).
            *   Decimal `INT` and `FLOAT` are mentioned generally but not with specific syntax examples in this section.
            *   `OCT` (octal literals, e.g., `0o...`) not explicitly shown.
            *   **Issue:** Major errors and omissions in documenting numeric literal syntax.
        *   **`NULL` (None):** Not explicitly listed as a literal in `atom.md`'s literal section, though it's part of `atom_literal` grammar. (Covered elsewhere under singleton patterns).
        *   **`ELLIPSIS` (`...`):** Not mentioned in `atom.md`, though part of `atom_literal` grammar.
            *   **Issue:** `ELLIPSIS` literal missing.
        *   **`builtin_type` (e.g., `int`, `str` as values):** Part of `atom_literal` grammar but not clearly explained as a literal value an atom can be in `atom.md`.
            *   **Issue:** `builtin_type` as a literal value unclear.

    5.  **`type_ref` (`` `type ``):**
        *   **Grammar:** `atom: type_ref`.
        *   **Documentation:** Mentions "Type References ... using the backtick operator (`)", but provides no concrete example (e.g., `` `MyType` `` or `` `int` ``).
        *   **Issue (Minor):** Lacks an explicit example.

    6.  **Misplaced Complex Examples in `atom.md`:**
        *   The document includes examples of string concatenation (`"a" + f"b"`) and chained attribute access (`x.y.value`), which are compound expressions (e.g., `arithmetic`, `atomic_chain`), not just `atom`s. This can be confusing for a document titled "Atom".
        *   **Issue:** Document scope seems to exceed the strict definition of an `atom`.

*   **Overall:** `atom.md` correctly identifies some atomic elements like names, parenthesized expressions, and basic collections. However, its coverage of `atom_literal` is poor, with incorrect syntax for some numeric literals and omission of others like `ELLIPSIS`. The document also mixes in examples of more complex expressions, blurring the definition of an "atom".

---

## Section 61: Multistring and F-string definitions (within atom_literal)

*   **Grammar Rules from `jac.lark`:**
    ```lark
    multistring: (fstring | STRING)+

    fstring: FSTR_START fstr_parts FSTR_END
           | FSTR_SQ_START fstr_sq_parts FSTR_SQ_END

    fstr_parts: (FSTR_PIECE | FSTR_BESC | LBRACE expression RBRACE )*
    fstr_sq_parts: (FSTR_SQ_PIECE | FSTR_BESC | LBRACE expression RBRACE )*

    // STRING terminal: covers '...', "...", '''...''', """...""", with r/b prefixes.
    // FSTR_START/END etc. are for f"..." and f'...' parts.
    ```
*   **Corresponding Markdown File:** No dedicated file. Mentioned in `atom.md`.
*   **Findings:**
    1.  **`STRING` (Regular String Literals):**
        *   **Grammar:** The `STRING` terminal supports various quoting and prefix styles.
        *   **Documentation (`atom.md`):** Shows basic double-quoted strings. Does not detail triple quotes or `r`/`b` prefixes, but these are standard Python features usually assumed.
        *   **Status:** Basic strings covered; advanced forms assumed standard.

    2.  **`fstring` (Formatted String Literals):**
        *   **Grammar:** Defines `f"..."` and `f'...'` with embedded expressions `{expression}`.
        *   **Documentation (`atom.md`):** Mentions f-strings and shows a simple example: `f"b{aa}bbcc"`.
        *   The full power of embedded `expression`s or format specifiers (e.g., `{val:.2f}`) is not detailed in `atom.md` but often inherited from Python f-string behavior.
        *   **Status:** Basic f-strings covered.

    3.  **`multistring: (fstring | STRING)+` (Implicit Concatenation):**
        *   **Grammar:** This rule allows implicit concatenation of adjacent string or f-string literals (e.g., `"abc" "def"` or `f"a" "b"`).
        *   **Documentation (`atom.md`):** Does not document this implicit concatenation feature. It shows explicit concatenation using the `+` operator (`"aaa" + f"b{aa}bbcc"`), which is an arithmetic expression, not an atomic `multistring` literal itself.
        *   **Issue:** Implicit string/f-string literal concatenation via adjacency, as defined by `multistring`, is not documented.

*   **Overall:** `atom.md` covers the existence of basic string literals and f-strings. The implicit concatenation feature of `multistring` is a notable omission from the documentation. Full details of `STRING` prefixes/quoting and f-string capabilities are also not in `atom.md` but are often standard language assumptions.

---

## Section 62: Collection values (atom_collection)

*   **Grammar Rules from `jac.lark` (overview):**
    ```lark
    atom_collection: dict_compr | set_compr | gen_compr | list_compr
                   | dict_val | set_val | tuple_val | list_val

    // Comprehensions generally: TARGET_EXPR (KW_ASYNC? KW_FOR ... KW_IN ... (KW_IF ...)*)+
    // Literals generally: BRACKET (elements COMMA?)? BRACKET_END
    // dict_compr: LBRACE kv_pair inner_compr+ RBRACE // Grammar has RSQUARE, likely typo
    ```
*   **Corresponding Markdown File:** `jac/examples/reference/collection_values.md`
*   **Findings:**
    **Literal Collections (`dict_val`, `set_val`, `tuple_val`, `list_val`):**
    1.  **Dictionary Literal (`dict_val`):** Doc shows `{"a": "b"}`. Grammar allows empty `{}`, unpacking `**expr`, and trailing comma; these aren't shown in this specific doc.
        *   **Status:** Basic covered.
    2.  **Set Literal (`set_val`):** Doc shows `{"a"}`. Grammar `LBRACE expr_list COMMA? RBRACE` doesn't easily make empty set `{}` (that's dict) or distinguish `{"a"}` from a dict without parser context. Python uses `set()` for empty. Single item sets usually `{ "a" }` not `{"a":}`.
        *   **Issue:** Syntax for set literals (esp. empty, single-element) and potential ambiguity with dict literals needs clarification in docs and grammar robustness.
        *   **Status:** Basic concept mentioned; syntax clarity needed.
    3.  **Tuple Literal (`tuple_val`):** Doc shows `("a", )` (single element with comma). Grammar allows empty `()` and multi-element.
        *   **Status:** Single-element covered; others implied.
    4.  **List Literal (`list_val`):** Doc shows `['a']`. Grammar allows empty `[]`, multi-element, and trailing comma.
        *   **Status:** Basic covered; others implied.

    **Comprehensions (`..._compr` rules):**
    5.  **General Structure:** Docs show `TARGET for item in iterable if condition`.
        *   **Grammar (`inner_compr+` and `KW_ASYNC?`):** Allows multiple `for`/`if` clauses (e.g., `for x in X for y in Y if cond1 if cond2`) and `async` comprehensions.
        *   **Issue:** Advanced comprehension features (multiple `for`/`if` clauses, `async` comprehensions) are not documented in `collection_values.md`.
        *   **Status:** Basic comprehensions covered; advanced features undocumented.
    6.  **Dictionary Comprehension Grammar Typo:** `dict_compr` rule ends with `RSQUARE` in `jac.lark`, should be `RBRACE`.
        *   **Issue:** Grammar typo.

*   **Overall:** Basic collection literals and comprehensions are introduced. Key areas for improvement: robust syntax/examples for set literals (empty, single-element), documentation for advanced comprehension features (multiple `for`/`if`, `async`), and showing features like unpacking in dict literals and trailing commas. Grammar typo in `dict_compr` needs fixing.

---

## Section 63: Supporting rules for Collection Values (kv_pair, expr_list)

*   **Grammar Rules from `jac.lark`:**
    ```lark
    kv_pair: expression COLON expression | STAR_POW expression
    expr_list: (expr_list COMMA)? expression
    ```
*   **Corresponding Markdown File:** No dedicated file; these are components of collection literal rules discussed in `collection_values.md`.
*   **Analysis:**
    1.  **`kv_pair` (for Dictionary Literals):**
        *   **Grammar:** Defines `expression : expression` for key-value items and `STAR_POW expression` for dictionary unpacking (`**mapping`).
        *   **Documentation (`collection_values.md`):** Examples show `"key": "value"`. Dictionary unpacking (`**mapping`) within literals is not explicitly shown in this document but is a standard feature documented elsewhere (e.g., `unpack_expressions.md`).
        *   **Status:** Standard key-value covered. `**unpacking` as a `kv_pair` type is valid per grammar but not shown in `collection_values.md` examples of dictionary literals.

    2.  **`expr_list` (for List/Set Literals, Function Arguments):**
        *   **Grammar:** Defines a comma-separated list of one or more `expression`s.
        *   **Documentation (`collection_values.md`):** Examples like `['a']` use `expr_list`. Multi-element lists/sets are implied.
        *   Iterable unpacking (`*iterable`) within list/set literals: An `expression` in `expr_list` can be an `unpack` (e.g., `*my_items`). This specific syntax is not shown in `collection_values.md` examples for list/set literals but is documented in `unpack_expressions.md`.
        *   **Status:** Basic `expr_list` covered. `*unpacking` as part of `expr_list` for literals is valid per grammar but not shown in `collection_values.md` examples.

*   **Overall:** These grammar rules are fundamental for constructing collection literals. The `collection_values.md` illustrates basic usage but could be more comprehensive by showing how `STAR_POW expression` (for `kv_pair`) and `unpack` expressions (for `expr_list`) integrate into dictionary and list/set literals respectively, to fully reflect the grammar capabilities.

---

## Section 64: Tuples and Jac Tuples (tuple_list, kw_expr_list, kw_expr)

*   **Grammar Rules from `jac.lark`:**
    ```lark
    // These rules define the contents within LPAREN ... RPAREN for tuple_val.
    tuple_list: expression COMMA expr_list COMMA kw_expr_list COMMA?  // e.g., (p1, p2, kw1=v1)
              | expression COMMA kw_expr_list COMMA?                 // e.g., (p1, kw1=v1)
              | expression COMMA expr_list COMMA?                    // e.g., (p1, p2, p3)
              | expression COMMA                                     // e.g., (p1,)
              | kw_expr_list COMMA?                                  // e.g., (kw1=v1, kw2=v2)

    kw_expr_list: (kw_expr_list COMMA)? kw_expr
    kw_expr: named_ref EQ expression | STAR_POW expression // kw=val or **mapping
    // expr_list for positional elements is defined elsewhere.
    ```
*   **Corresponding Markdown File:** `jac/examples/reference/tuples_and_jac_tuples.md`
*   **Findings:**
    1.  **Positional Tuples (elements are `expression` or from `expr_list`):**
        *   **Documentation:** Covers multi-element positional tuples (e.g., `(10, 20)`) and single-element tuples with a trailing comma (e.g., `(42,)`).
        *   **Grammar:** Supported by `expression COMMA expr_list?` and `expression COMMA`.
        *   **Status:** Covered.

    2.  **Keyword Tuples (Jac-specific, elements from `kw_expr_list`):**
        *   **Documentation:** Shows keyword tuples like `(x=3, y=4)` using `named_ref EQ expression`.
        *   **Grammar:** `kw_expr_list` is built from `kw_expr`, which includes `named_ref EQ expression` and `STAR_POW expression` (`**mapping`).
        *   The documentation does not explicitly show `**mapping` unpacking within keyword tuple literals (e.g., `config = (**common, port=80);`).
        *   **Issue (Minor):** `**mapping` unpacking in keyword tuple literals is not exemplified.
        *   **Status:** Basic keyword tuples covered.

    3.  **Mixed Positional and Keyword Tuples:**
        *   **Documentation:** Shows `("header", version=2, timestamp=now())` and states positional elements must precede keyword elements.
        *   **Grammar:** Supported by productions like `expression COMMA expr_list COMMA kw_expr_list ...` and `expression COMMA kw_expr_list ...`.
        *   **Status:** Covered.

    4.  **Trailing Commas (`COMMA?`):**
        *   **Grammar:** Allows optional trailing commas in most `tuple_list` variants and in `kw_expr_list`.
        *   **Documentation:** Notes for single-element positional tuples. Not emphasized for other cases but grammatically allowed.
        *   **Status:** Partially noted; broadly allowed by grammar.

    5.  **Empty Tuple `()`:**
        *   This is formed by `tuple_val: LPAREN tuple_list? RPAREN` when `tuple_list` is absent.
        *   **Documentation:** Not explicitly shown in this document, but is a standard construct.
        *   **Status:** Standard, implied by grammar for `tuple_val`.

*   **Overall:** The documentation effectively explains positional, keyword, and mixed tuples. The primary minor omission is an example of `**mapping` unpacking within keyword tuple literals. The grammar for these components is also fundamental to function call arguments.

---

## Section 65: Object-Spatial References (edge_ref_chain)

*   **Grammar Rules from `jac.lark` (overview):**
    ```lark
    edge_ref_chain: LSQUARE (KW_NODE| KW_EDGE)? expression? (edge_op_ref (filter_compr | expression)?)+ RSQUARE

    edge_op_ref: edge_any | edge_from | edge_to // Defines arrow types
    // edge_to/from/any can be simple (e.g., "-->") or detailed (e.g., "->:EdgeType:filter:->")
    // (filter_compr | expression)? is an optional filter after an edge operation.
    ```
*   **Corresponding Markdown File:** `jac/examples/reference/data_spatial_references.md`
*   **Findings:**
    1.  **Basic Structure `LSQUARE ... RSQUARE`:** Covered.

    2.  **Initial Context `(KW_NODE| KW_EDGE)? expression?`:**
        *   **Grammar:** Allows an optional `node`/`edge` keyword and an optional starting `expression`.
        *   **Documentation:** Examples often implicitly use `here` as context. The role of this explicit initial part is not clearly explained or extensively exemplified (e.g., how `[node_expr --> ...]` differs from `[-->]` from `node_expr`'s context).
        *   **Issue (Clarification Needed):** Documentation for this initial context specifier is sparse.

    3.  **Edge Operations (`edge_op_ref`):**
        *   **Simple Arrows (`-->`, `<--`, `<-->`):** Documented for directional navigation.
        *   **Detailed/Typed Arrows (e.g., `->:EdgeType:prop_filter:->`):** Documented, showing typed edge traversal (e.g., `[-->:EdgeType:]`). The property filtering part within the detailed arrow syntax (`prop_filter`) is implicitly part of `typed_filter_compare_list`.
        *   **Status:** Core arrow operations covered.

    4.  **Optional Filter `(filter_compr | expression)?` after `edge_op_ref`:**
        *   **Grammar:** Allows a filter to be applied to the result of an edge operation.
        *   **Documentation:** "Filtered References" section shows examples like `[-->(weight > threshold)]` (expression filter) and `[-->(?name.startswith("test"))]` (filter comprehension).
        *   **Status:** Covered.

    5.  **Chaining of Edge Operations `(edge_op_ref ...)+`:**
        *   **Grammar:** Requires at least one, allows multiple chained edge operations within a single `[...]` block (e.g., `[--> --> some_prop < 10]` if intermediate steps yield nodes).
        *   **Documentation:** Does not show complex examples of deeply chaining multiple `edge_op_ref` within one `edge_ref_chain`. Focuses on single operations or iteration over results of one operation.
        *   **Issue (Minor):** Deeply chained edge operations within one reference are not exemplified.

    6.  **Inclusion of Connection/Disconnection Ops in the Document:**
        *   The document `data_spatial_references.md` also describes connection (`++>`) and disconnection (`del node-->edge`) operations.
        *   These are grammatically distinct from `edge_ref_chain` (which is for querying/traversing).
        *   **Issue (Documentation Structure):** Including creation/deletion operations in a document about "references" can be confusing. These belong more to `connect_expressions.md` or `delete_statements.md` respectively.

*   **Overall:** The document covers the basics of using `edge_ref_chain` for simple traversals and filtering. However, the initial context specifier and advanced chaining within a single reference need more documentation. The inclusion of connection/disconnection syntax in this particular document also blurs its focus.

---

## Section 66: Special Comprehensions

*   **Grammar Rules from `jac.lark`:**
    ```lark
    // Used in atomic_chain like: atomic_chain NULL_OK? (filter_compr | assign_compr)
    filter_compr: LPAREN NULL_OK filter_compare_list RPAREN
                | LPAREN TYPE_OP NULL_OK typed_filter_compare_list RPAREN
    assign_compr: LPAREN EQ kw_expr_list RPAREN // e.g., (= prop1=val1, prop2=val2)

    filter_compare_list: (filter_compare_list COMMA)? filter_compare_item
    typed_filter_compare_list: expression (COLON filter_compare_list)? // expression is TypeName
    filter_compare_item: named_ref cmp_op expression // e.g., age > 18

    // kw_expr_list uses kw_expr: named_ref EQ expression | STAR_POW expression
    // NULL_OK: "?", TYPE_OP: "`", EQ: "="
    ```
*   **Corresponding Markdown File:** `jac/examples/reference/special_comprehensions.md`
*   **Findings:**
    1.  **Filter Comprehensions (`filter_compr`):**
        *   **Non-Typed `(? filter_conditions)`:** Documented with examples like `(?score > 0.5)` and `(age > 18, status == "active")`. Aligns with `LPAREN NULL_OK filter_compare_list RPAREN`.
            *   **Status:** Covered.
        *   **Typed ``( `TypeName : ? filter_conditions )``:** Documented with examples like `` (`Connection: weight > 10) `` and `` `UserNode: (active == True) ``. Aligns with `LPAREN TYPE_OP NULL_OK typed_filter_compare_list RPAREN`.
            *   **Status:** Covered.

    2.  **Assignment Comprehensions (`assign_compr`):**
        *   **Grammar:** `LPAREN EQ kw_expr_list RPAREN`. `kw_expr_list` uses `named_ref EQ expression` for items (e.g., `(=prop1=val1, prop2=val2)`).
        *   **Documentation:** Shows syntax like `(=property: new_value)` and `(=x: 10, y: 20)`. Uses colons `:` instead of equals `=` for assignments within the comprehension.
        *   **Issue (Syntax Mismatch):** Documentation for assignment items (e.g., `prop:value`) uses colons, while the grammar (via `kw_expr_list` -> `kw_expr`) specifies equals signs (`prop=value`). This needs reconciliation.
        *   **Status:** Concept covered; syntax detail for assignment items mismatched.

    3.  **Structure of Filter Conditions (`filter_compare_list`, `typed_filter_compare_list`, `filter_compare_item`):**
        *   These grammar rules correctly define how multiple filter conditions (`name op value`) are formed and combined, optionally typed with a leading `TypeName:`.
        *   **Documentation:** Examples for these list structures align with the grammar.
        *   **Status:** Covered.

    4.  **Usage Context (Applied to an `atomic_chain`, often `edge_ref_chain`):**
        *   **Documentation:** Clearly shows these comprehensions applied to edge references, e.g., `[-->(?score > 0.5)];` or `[-->](=visited: True);`. Also shows null-safe application `[-->(?nested?.property > 0)]`.
        *   **Status:** Covered.

*   **Overall:** Filter comprehensions are well-documented and align with the grammar. Assignment comprehensions are conceptually covered, but there is a syntax mismatch (colon vs. equals) for the assignment items within them compared to the underlying `kw_expr_list` grammar. The application of these comprehensions to edge references is well illustrated.

---

## Section 67: Names and references (named_ref, special_ref)

*   **Grammar Rules from `jac.lark`:**
    ```lark
    named_ref: special_ref | KWESC_NAME | NAME

    special_ref: KW_INIT | KW_POST_INIT | KW_ROOT | KW_SUPER | KW_SELF | KW_HERE | KW_VISITOR

    NAME: /[a-zA-Z_][a-zA-Z0-9_]*/
    KWESC_NAME: /<>[a-zA-Z_][a-zA-Z0-9_]*/
    // KW_SELF is "self", KW_HERE is "here", etc.
    ```
*   **Corresponding Markdown File:** `jac/examples/reference/names_and_references.md`
*   **Findings:**
    1.  **`NAME` (Standard Identifiers):**
        *   **Grammar:** `NAME: /[a-zA-Z_][a-zA-Z0-9_]*/`.
        *   **Documentation:** Correctly describes standard identifier rules and provides valid/invalid examples.
        *   **Status:** Covered.

    2.  **`KWESC_NAME` (Keyword Escaping):**
        *   **Grammar:** `KWESC_NAME: /<>[a-zA-Z_][a-zA-Z0-9_]*/` (e.g., `<>myvar`).
        *   **Documentation:** Explains escaping keywords by wrapping with angle brackets, example `_<>with = 10;`.
        *   **Clarification on example:** The example `_<>with` might be slightly confusing. If `with` is the keyword to be used as an identifier, the syntax would likely be `<>with` if the lexer/parser handles `<>keyword` as a special token, or `<>somename` if `somename` is a valid identifier that isn't a keyword but needs escaping for other reasons (less common). The regex `/<>[a-zA-Z_][a-zA-Z0-9_]*/` suggests `<>` followed by a standard identifier sequence.
        *   **Status:** Concept covered. Exact tokenization of example `_<>with` vs. regex needs to be precise.

    3.  **`special_ref` (Special References):**
        *   **Grammar:** Lists `KW_INIT`, `KW_POST_INIT`, `KW_ROOT`, `KW_SUPER`, `KW_SELF`, `KW_HERE`, `KW_VISITOR`.
        *   **Documentation:** Provides a table and explanations for `self`, `here`, `visitor`, `super`, `root`, `init`/`postinit`. All match the grammar keywords.
        *   **Status:** Covered.

*   **Overall:** The documentation accurately covers the types of named references: standard identifiers, special built-in references, and the mechanism for escaping keywords. The usage context, especially for special references, is well explained. Minor clarification on the `KWESC_NAME` example could be useful.

---

## Section 68: Builtin types

*   **Grammar Rules from `jac.lark`:**
    ```lark
    builtin_type: TYP_TYPE | TYP_ANY | TYP_BOOL | TYP_DICT | TYP_SET | TYP_TUPLE |
                  TYP_LIST | TYP_FLOAT | TYP_INT | TYP_BYTES | TYP_STRING
    // These TYP_ tokens are keywords like "int", "str", etc.
    ```
*   **Corresponding Markdown File:** `jac/examples/reference/builtin_types.md`
*   **Findings:**
    1.  **List of Built-in Type Keywords:**
        *   **Grammar:** Defines tokens for `type`, `any`, `bool`, `dict`, `set`, `tuple`, `list`, `float`, `int`, `bytes`, `string`.
        *   **Documentation:** Lists all these types, categorizing them (Primitive, Collection, Meta).
        *   **Status:** Covered and consistent.

    2.  **Usage in Type Annotations:**
        *   **Documentation:** Shows examples like `name: str`, `data: list`, `-> dict`. This is the primary use case for these keywords representing types.
        *   **Grammar:** This usage fits into rules like `type_tag: COLON expression` where `expression` can be a `named_ref` that is one of these `builtin_type` keywords.
        *   **Status:** Primary usage context covered.

    3.  **Other Grammatical Roles:**
        *   The `builtin_type` rule is also part of `atom_literal` (allowing `x = int` if `int` is treated as a value) and `type_ref` (allowing `` `int ``).
        *   **Documentation (`builtin_types.md`):** Focuses on their use as type specifiers in annotations rather than these other roles.
        *   **Status:** These specific grammatical roles are not detailed in this document but are part of other grammar rules (`atom_literal`, `type_ref`).

*   **Overall:** The `builtin_types.md` correctly lists the available built-in type keywords and illustrates their main function in type annotations. It does not exhaustively cover every grammatical context where these type names might appear, but those are better suited for the sections defining those contexts (e.g., `atom.md` for literals).

---

## Section 69: f-string tokens

*   **Grammar Rules for f-string structure (from "Atom" section) and its terminals:**
    ```lark
    // Structure rule (uses these terminals)
    fstring: FSTR_START fstr_parts FSTR_END
           | FSTR_SQ_START fstr_sq_parts FSTR_SQ_END
    fstr_parts: (FSTR_PIECE | FSTR_BESC | LBRACE expression RBRACE )*
    fstr_sq_parts: (FSTR_SQ_PIECE | FSTR_BESC | LBRACE expression RBRACE )*

    // Terminal definitions for f-string components
    FSTR_START.1: "f\""
    FSTR_END: "\""
    FSTR_SQ_START.1: "f'"
    FSTR_SQ_END: "'"
    FSTR_PIECE.-1: /[^\{\}\"]+/
    FSTR_SQ_PIECE.-1: /[^\{\}\']+/
    FSTR_BESC.1: /{{|}}/
    ```
*   **Corresponding Markdown File:** `jac/examples/reference/f_string_tokens.md`
*   **Findings:**
    1.  **Basic F-String Syntax (`f"..."`, `f'..."`):**
        *   **Grammar:** `FSTR_START...FSTR_END` and `FSTR_SQ_START...FSTR_SQ_END` along with `fstr_parts` define this.
        *   **Documentation:** Shows `f"Hello, {name}!";`. Single-quoted `f'...'` version implied by grammar but not explicitly shown as alternative in this doc.
        *   **Status:** Covered (double-quoted shown).

    2.  **Embedded Expressions (`{expression}`):**
        *   **Grammar:** `LBRACE expression RBRACE` within `fstr_parts`.
        *   **Documentation:** Well covered with various examples of embedded expressions.
        *   **Status:** Covered.

    3.  **Format Specifications (e.g., `{value:.2f}`):**
        *   **Documentation:** Shows examples like `f"Pi: {value:.2f}"`.
        *   **Grammar:** Handled by the `expression` within `{...}` if it includes formatting, relying on Python-like f-string capabilities.
        *   **Status:** Documented.

    4.  **Escaped Braces (`{{`, `}}`):**
        *   **Grammar:** `FSTR_BESC.1: /{{|}}/`.
        *   **Documentation (`f_string_tokens.md`):** Does not show examples of escaped braces.
        *   **Issue:** Undocumented feature.

    5.  **Multi-Line F-Strings (e.g., `f"""..."""`):**
        *   **Documentation:** Shows an example using `f"""..."""`.
        *   **Grammar (Terminals):** The `FSTR_START`/`END` terminals are defined only for `f"` and `f'`. They do not include `f"""` or `f'''`.
        *   **Issue (Grammar/Doc Mismatch):** Documented multi-line f-strings (`f"""..."""`) are not supported by the provided `FSTR_START`/`END` terminal definitions. The grammar for f-string delimiters needs to be extended or use the general `STRING` terminal (which supports triple quotes) if an `f` prefix on it is handled differently by the lexer.

*   **Overall:** Core f-string functionality (embedded expressions, format specs) is documented. Escaped braces are an undocumented feature. There's a significant mismatch for multi-line f-strings between documentation and the specific f-string delimiter terminals in the grammar.

---

## Section 70: Lexer Tokens (TYP_... terminals for builtin types)

*   **Grammar Rules from `jac.lark` (under this specific heading):**
    ```lark
    TYP_STRING: "str"
    TYP_INT: "int"
    TYP_FLOAT: "float"
    TYP_LIST: "list"
    TYP_TUPLE: "tuple"
    TYP_SET: "set"
    TYP_DICT: "dict"
    TYP_BOOL: "bool"
    TYP_BYTES: "bytes"
    TYP_ANY: "any"
    TYP_TYPE: "type"
    ```
    *(These terminals are used in the `builtin_type` rule, see Section 68).*

*   **Corresponding Markdown File:** `jac/examples/reference/lexer_tokens.md`
*   **Findings:**
    1.  **Documentation of `TYP_...` Tokens:**
        *   The `lexer_tokens.md` file, in its "Built-in type tokens" subsection, lists: `str int float list tuple set dict bool bytes any type`.
        *   This list accurately matches the keywords defined as `TYP_...` terminals in the grammar.
        *   **Status:** Covered and consistent.

    2.  **Scope of `lexer_tokens.md` Document:**
        *   The markdown file `lexer_tokens.md` is a broad overview of many Jac token categories (keywords, operators, literals, delimiters), not limited to just the `TYP_...` built-in type tokens.
        *   This is a general informational document. The `TYP_...` tokens are just one part of it.

*   **Overall:** For the specific grammar section covering `TYP_...` terminals, the `lexer_tokens.md` file is consistent. The broader content of `lexer_tokens.md` covers many other terminal types defined elsewhere in the `jac.lark` grammar.

---

## Section 71: Remaining Terminal Definitions (Keywords, Literals, Operators, etc.)

*   **Grammar Sections in `jac.lark`:** This covers various terminal definitions typically found at the end of a Lark file, including Keywords (e.g., `KW_IF: "if"`), Literal tokens (e.g., `INT`, `STRING`), Identifier tokens (`NAME`), Operator tokens (e.g., `PLUS: "+"`, `ARROW_R: "-->"`), and directives for Comments/Whitespace.
*   **Corresponding Markdown Files:** No single, dedicated markdown files for these broad terminal categories. `lexer_tokens.md` provides a partial overview. Specific terminals are best understood in the context of the grammar rules that use them.
*   **Findings & Overall Status:**
    1.  **Keywords (e.g., `KW_LET`, `KW_IF`):**
        *   Most keywords are defined as simple string literals (e.g., `KW_IF: "if"`). Their usage and meaning are covered by the documentation of the statements/expressions they introduce (e.g., `if_stmt` for `KW_IF`).
        *   Regex-based keywords like `KW_NIN` (`not in`) and `KW_ISN` (`is not`) were noted as missing from explicit lists in `logical_and_compare_expressions.md` but are present in `cmp_op` grammar.
        *   **Status:** Implicitly and contextually covered. Definitions are standard.

    2.  **Literals (Terminals: `STRING`, `NULL`, `BOOL`, `FLOAT`, `HEX`, `BIN`, `OCT`, `INT`):**
        *   These define the lexical representation of literal values.
        *   Their interpretation and usage were discussed under `atom_literal` (Section 60) and `multistring`/`fstring` (Section 61).
        *   Key issue previously noted: documentation for numeric base literals (`HEX`, `BIN`, `OCT`) in `atom.md` was incorrect or missing. The terminal definitions themselves (e.g., `HEX.1: /0[xX][0-9a-fA-F_]+/`) are standard.
        *   **Status:** Terminal definitions are standard. Documentation consistency for their use (especially numeric bases) is the main concern.

    3.  **Identifier (Terminals: `KWESC_NAME`, `NAME`):**
        *   Covered in detail under "Names and references" (Section 67).
        *   **Status:** Covered.

    4.  **Operators (Object-Spatial, Assignment, Arithmetic, Other - e.g., `ARROW_R`, `EQ`, `PLUS`, `PIPE_FWD`):**
        *   These terminals define the symbols for various operations.
        *   Their meaning and usage are tied to the expression rules that employ them (e.g., `connect_op` for `ARROW_R`, `assignment` for `EQ`, `arithmetic` for `PLUS`, `pipe` for `PIPE_FWD`). These were covered in their respective expression sections.
        *   The `@` operator (`DECOR_OP`) was noted as missing from arithmetic expression documentation.
        *   **Status:** Implicitly and contextually covered. Definitions are standard.

    5.  **Punctuation Terminals (e.g., `COLON: ":"`, `LPAREN: "("`):**
        *   These are fundamental syntactic markers.
        *   Their role is defined by their use in all other grammar rules.
        *   Special punctuation like `TYPE_OP: "`"` (for type references) and `NULL_OK: "?"` (null-safe operator) were discussed in context (e.g., `atom`, `atomic_chain`).
        *   **Status:** Covered by overall grammar structure.

    6.  **Comments and Whitespace (`COMMENT`, `WS`, `%ignore` directives):**
        *   Standard lexer directives and definitions for ignoring comments and whitespace.
        *   No specific documentation file is typically needed for these beyond standard language behavior.
        *   **Status:** Standard, no issues.

*   **Final Overall Summary on Terminals:** The terminal definitions in `jac.lark` are, for the most part, standard and serve as the building blocks for the parser. Most are self-explanatory or their meaning is derived from the higher-level grammar rules and the associated documentation for those rules. The consistency issues previously noted (e.g., documentation of numeric literals, specific operators like `@`, `is not`, `not in`) are the primary points of concern related to how these terminals manifest in the language features.

---

## Overall Summary of Findings

This analysis compared the `jac.lark` grammar file against the Markdown documentation in `jac/examples/reference/`. Numerous sections were analyzed, and the findings have been detailed in the preceding sections of this document.

The major themes of inconsistencies and areas for improvement include:

1.  **Outdated/Incorrect Documentation Examples or Explanations:**
    *   `atom.md`: Incorrect syntax for binary/hex literals (showed function calls).
    *   `match_literal_patterns.md`: Miscategorized `None` and booleans (which are `singleton_pattern`s).
    *   `expressions.md`: Contained a lambda example with syntax inconsistent with `lambda_expr` grammar.
    *   `assignments.md`: Showed an unconventional destructuring assignment syntax `(name=user, age=years) = ...` that needs clarification or correction.
    *   `base_module_structure.md`: Overstated requirement for `with entry {}` for all module-level code.

2.  **Grammar Features Not Documented or Under-exemplified:**
    *   **Common Patterns:** Trailing commas in lists/arguments; `let` with chained assignments; typed declarations without init; assigning `yield_expr` results.
    *   **Import Statements:** Using `.` or `...` in `from_path`; multiple modules in one standard `import`.
    *   **Archetypes/Enums:** `async` archetypes; empty archetype/enum bodies with `SEMI`; nesting various statements (`py_code_block`, other archetypes, `impl_def`, `free_code`) inside archetype bodies; `KW_LET` for `has_stmt`; multiple vars in one `has`; enum inheritance.
    *   **Abilities/Functions:** `KW_OVERRIDE` keyword; `KW_BY` delegation (for implementation and in calls); return types on `event_clause`; `static can` abilities; no-parenthesis `func_decl` for no-arg functions.
    *   **Implementations (`impl`):** `KW_BY` delegation; decorators on `impl`; `impl_spec` as `inherited_archs` or `event_clause`; modern `impl` syntax for `test`.
    *   **Global Variables:** Multiple declarations in one statement; declaration without initial assignment.
    *   **Python Integration:** `py_code_block` usage within archetypes or function bodies.
    *   **Testing:** String literals for test names vs. `NAME` token in grammar; separation of test declaration/implementation in `tests.md`.
    *   **Statements:** Empty statement (`SEMI`); comprehensive list in `codeblocks_and_statements.md`.
    *   **Loops:** `else` clause for `for` loops; `async for ... to ... by ...`; multi-variable assignment syntax in `for i=0,j=0...`; `if filter` in `for...in` loop.
    *   **Error Handling:** Bare `except:` syntax in `try_stmt` docs inconsistent with grammar.
    *   **Pattern Matching:** Positional argument patterns in `match_class_pattern`; type-only `ClassName()` match; `list_val` for fancy indexing in `index_slice`; comma-separated multi-dim indexing; `as_pattern` with `or_pattern` on LHS; `assign_compr` syntax (`:` vs. `=`).
    *   **String Literals:** Implicit concatenation of adjacent string/f-string literals; escaped braces `{{ }}` in f-strings; multi-line `f"""..."""` support in grammar vs. f-string tokens.
    *   **Lambda Expressions:** No-param lambdas; `*args`/`**kwargs`; default parameter values; explicit return type annotation.
    *   **Object-Spatial:** Initial context `(KW_NODE|KW_EDGE)? expr?` in `edge_ref_chain`; deep chaining of `edge_op_ref`; `disconnect_op` as part of `connect` expression; semantic meaning of chained `spawn` expressions.
    *   **Operators:** `@` (matrix multiplication) operator in arithmetic expressions; `is not`/`not in` in comparison operator lists.

3.  **Potential Grammar Issues, Typos, or Ambiguities:**
    *   `pipe_call` rule: Its definition treating `|>`, `:>`, `spawn` as optional unary prefixes is largely inconsistent with their binary nature defined elsewhere. Needs significant review.
    *   `shift` rule: Uses `logical_or` as operand name, likely a placeholder/typo.
    *   `disenage_stmt`: Typo for `disengage_stmt` in rule name.
    *   `dict_compr`: Ends with `RSQUARE` instead of `RBRACE`.
    *   `KWESC_NAME`: Regex vs. example (`_<>with`) could be clarified.
    *   Clarity on whether `KW_SKIP` is a general `ctrl_stmt` or walker-specific based on its grammar placement.
    *   `delete_stmt`: `del a,b,c;` syntax needs clarification against `KW_DELETE expression`.

4.  **Documentation Structure/Scope Concerns:**
    *   `atomic_expressions.md` describes `atomic_pipe` (`:>`) not general language atoms.
    *   `data_spatial_references.md` includes connection/disconnection operations (which are not strictly "references").
    *   `lexer_tokens.md` is a very broad token overview.

5.  **Unused Features Confirmed:**
    *   The `&` operator for explicit references (`ref: BW_AND? pipe_call`) is documented as unused.

This detailed analysis, available in `notes.md`, should serve as a comprehensive guide for synchronizing the Jac language grammar with its documentation, enhancing clarity, accuracy, and completeness for developers.

---



================================================================================
FILE: docs/internals/planning_specs/spawn_life_cycle.md
================================================================================


# Archetype Lifecycle Enhancement Roadmap

## Executive Summary

**Problem Statement**: Current archetype execution lacks proper lifecycle management, leading to unmanaged code execution, reduced developer productivity, and limited scalability for complex applications.

**Solution**: Implement a structured three-phase archetype lifecycle with simplified syntax and native concurrency support.

**Improvements in Development**:

- **Structured lifecycle events** enabling organized code execution patterns
- **Event-driven architecture** familiar to developers working with modern frameworks
- **Simplified syntax** reducing learning curve for new developers
- **Deterministic execution** improving code reliability and maintainability

---

## Current State Analysis

### Critical Issues

**1. Unmanaged Code Execution**

- Entry and exit abilities execute without clear lifecycle boundaries
- No separation between initialization, processing, and cleanup phases
- Developers struggle to organize code execution flow

```javascript
// Problem: These behave identically despite different intent
can a with entry { print(1); }
can b with exit { print(2); }
// vs
can a with entry { print(1); print(2); }
```

**2. Syntax Complexity**

- Verbose `can ... with ... entry/exit` syntax for simple lifecycle hooks
- Multiple declarations create confusion and override behavior
- No clear patterns for common use cases

**3. Limited Concurrency**

- No native support for parallel execution
- Developers must implement complex workarounds for concurrent operations
- Performance bottlenecks in data-intensive applications

---

## Implementation Roadmap

### âœ… **PHASE 1: Core Lifecycle Structure** (APPROVED)

**Target Outcome**: Establish predictable execution phases

**Implementation**:

- **Pre-execution**: Entry abilities run before node processing
- **Next-execution**: Node processing and child traversal
- **Post-execution**: Exit abilities run after all processing completes

**Expected Outcomes**:

- Zero ambiguity in execution order
- 100% predictable behavior across all walker types
- Clear separation of concerns in code structure

---

### âœ… **PHASE 2: Event-Driven Lifecycle Hooks** (APPROVED)

**Target Outcome**: Implement standard event-driven programming patterns

**Core Concept**: Lifecycle events with filter-based triggers and standalone abilities

**System Components**:

**1. Standalone Abilities** (Independent of lifecycle)

```javascript
can ability1 {
    // Declare ability that's not included in the lifecycle
    // Code your process here
    // `self`, `here` or `visitor` will be available here
}

can dance {
    // Same as ability1 but with a proper name
    // Contains reusable logic
}
```

**2. Global Lifecycle Events** (No filter - execute once per spawn)

```javascript
with entry {
    // Global entry - no filter specified
    // Only one allowed (multiple declarations use last one)
    // Very first event triggered once per spawn_call
    self::ability1; // Call the ability
    self::dance;    // Call another ability
}

with exit {
    // Global exit - opposite of `with entry`
    // Cleanup and final operations
    // Last event triggered once per spawn_call
}
```

**3. Filtered Lifecycle Events** (Execute multiple times based on filter)

```javascript
with A entry {
    // Entry event with filter A
    // Can be triggered multiple times during traversal
    // Multiple declarations with same filter use last one
    // Triggers when filter A conditions are met
}

with A exit {
    // Exit event with filter A
    // Opposite of filtered entry
    // Cleanup specific to filter A
}
```

**Expected Outcomes**:

- Event-driven architecture using clear filter-to-event mapping
- Zero confusion about event precedence

**Migration Path**:

```javascript
// Current (verbose)
can test with WalkerA entry { /* code */ }

// New (event-driven with abilities)
can process_data {
    // Standalone ability with automatic context
    // self, here, visitor available
}

with WalkerA entry {
    self::process_data; // Call ability within event
}
```

---

### âœ… **PHASE 3: Global Lifecycle Hooks** (APPROVED)

**Target Outcome**: Enable archetype-level control and result handling

**Features**:

- `with entry`: One-time archetype initialization
- `with exit`: Cleanup and result return
- `with object entry/exit`: Per-visit hooks

**Important Note on `with exit`**:

- As part of the global archetype lifecycle, `with exit` serves not only for cleanup but also for producing the final result of a walker spawn. This enables concise and explicit control of return values for spawned walkers, enhancing reliability and intent.

**Illustrative Example: Using `with exit` to Return Final Result**

```javascript
walker A {
    with exit {
        return 1; // final result of walker spawn
    }
}
```

This pattern ensures the walkerâ€™s result is predictable and that clean-up and result handling are clearly separated from object/node-level lifecycle events.

**Illustrative Example: Complete Lifecycle**

```javascript
walker DataProcessor {
   with entry { /* initialize resources once */ }
   with exit { return processed_results; /* clean return as final walker result */ }
   with object entry { /* per-node processing */ }
}
```

**Expected Outcomes**:

- Clean separation between archetype and object lifecycles
- Reliable result handling and value return from walker spawns
- Improved resource management patterns

---

### ðŸ”„ **PHASE 4: Instant Visit Support** (UNDER DISCUSSION)

**Target Outcome**: Enable native depth-first search with predictable execution order

**Why This Matters**:

- **Performance**: Native DFS eliminates recursive overhead
- **Predictability**: Guaranteed execution sequence for complex traversals
- **Developer Experience**: Intuitive `enter [-->]` syntax matches mental model

**Technical Implementation**:

```javascript
node A {
   with WalkerA entry {
      print(1);
      enter [-->(`?B)]; // Immediate B lifecycle execution
      print(3);         // Continues after B completes
   }
}
// Guaranteed output: 1, 2, 3
```

**Expected Outcomes**:

- Native DFS eliminates custom implementation complexity
- Guaranteed execution sequence for complex traversals
- Intuitive syntax matches developer mental models

**Risk Mitigation**:

- Comprehensive testing with existing walker patterns
- Gradual rollout with feature flags
- Clear documentation of execution guarantees

---

### ðŸ”„ **PHASE 5: Concurrent Execution Support** (UNDER DISCUSSION)

**Target Outcome**: Enable high-performance parallel processing with simple syntax

**Why Critical for Modern Applications**:

- **Scalability**: Handle large datasets efficiently
- **User Experience**: Responsive applications under load
- **Resource Utilization**: Maximize hardware capabilities

**Multiple Implementation Approaches**:

**Thread-based Concurrency**:

```javascript
// Simple syntax for CPU-bound tasks
visit:thread [-->]; // Automatic thread pool management
```

**Async/Task-based Concurrency**:

```javascript
// Ideal for I/O-bound operations
visit:task [-->]; // Native TaskGroup integration
```

**Manual Control for Complex Cases**:

```javascript
with TaskGroup() as tg {
    tg.create_task(async enter [-->]);
    tg.create_task(process_data());
}
```

**Expected Outcomes**:

- Structured approach to parallel processing
- Simplified concurrency patterns reduce implementation complexity
- Multiple syntax options for different use cases

**Implementation Considerations**:

- Thread safety analysis for all core operations
- Memory management for concurrent contexts
- Error handling and propagation across parallel tasks
- Performance benchmarking against current sequential execution

---

## Expected Outcomes

### Developer Productivity

- **Better Code Organization**: Event-driven patterns improve code structure
- **Familiar Paradigms**: Common event hooks reduce learning curve
- **Cleaner Separation**: Distinct abilities and events improve maintainability

### Application Architecture

- **Event-Driven Design**: Clear lifecycle management and execution flow
- **Modular Abilities**: Reusable code components with automatic context
- **Structured Concurrency**: Organized approach to parallel processing

### Code Quality

- **Predictable Events**: Clear filter-to-event mapping
- **Better Practices**: Separation between abilities and lifecycle events
- **Improved Testability**: Isolated abilities and events enable better testing

### Improvements in Development

- **Better Code Patterns**: Event-driven design improves development practices
- **Familiar Programming Model**: Reduces cognitive load for contributors
- **Improved Maintainability**: Clear separation between abilities and events
- **Team Collaboration**: Consistent patterns enable easier contribution and review

---

## Risk Assessment & Mitigation

### High Priority Risks

1. **Breaking Changes**: Existing code requires updates
   - _Mitigation_: Comprehensive migration guide and automated conversion tools
2. **Complexity Introduction**: Event system may add cognitive overhead
   - _Mitigation_: Clear documentation and illustrative examples for familiarity
3. **Ability Syntax Uncertainty**: `self::ability_name` syntax needs validation
   - _Mitigation_: Prototype syntax and gather developer feedback on `self::` vs alternatives

### Implementation Dependencies

- Phases 1-3 must be completed before 4-5
- Event system design and filter parsing required
- Ability calling syntax needs finalization (`self::ability_name` syntax validation)
- Migration tooling for existing codebases

---

## Next Steps

1. **Finalize Phase 4 & 5 specifications** based on team discussion
2. **Decide on ability calling syntax** (current proposal: `self::ability_name`)
3. **Develop event system architecture** with filter parsing logic
4. **Create comprehensive testing plan** for event-driven patterns

_Ready for your feedback on Phases 4 & 5 and ability syntax to proceed with detailed implementation planning._




================================================================================
FILE: docs/internals/plugin_documentation.md
================================================================================


#  Plugin Foundation Documentation

## Overview

The `machine.py` file forms the **foundation of plugin functionality** in the Jaseci Cloud architecture. It leverages the **Pluggy** library to define a flexible and modular **plugin system** using a **hook mechanism**.

This document provides a detailed breakdown of how plugins are structured and implemented in `machine.py`, including all relevant classes and static methods. It is designed to help contributors and maintainers understand this file independently, without needing a full view of the entire Jaseci codebase.

---

##  What is Pluggy?

**Pluggy** is a lightweight plugin system library used extensively in projects like **pytest**. It allows defining:

- **Hook specifications** (`@hookspec`) â€” method signatures to be implemented.
- **Hook implementations** (`@hookimpl`) â€” actual logic for the hooks.
- **Plugin Manager** to register, manage, and dispatch hook calls dynamically.

---

##  Plugin Architecture class implementation

### Classes Implemented

| Class   | Role                                                                 |
|---------|----------------------------------------------------------------------|
| `Spec`  | Defines placeholder methods that plugin implementations must implement.For declaring the method interfaces. It doesn't do anything itself but tells pluggy what hooks are available. |
| `Impl`  | For registering actual implementations using `@hookimpl`|
| `Proxy` | For calling plugin methods from the outside, through plugin_manager.hook.<method>() |

---

## good example to understand the 3 classes and use of proxy class
You're building a plugin-driven data pipeline framework.
Each plugin can implement one or more of:

- load_data(source: str) -> dict

- transform_data(data: dict) -> dict

- save_data(data: dict, target: str) -> None

We will:

- Declare a hook spec

- Implement two plugins (one for CSV, one for JSON)

- Dynamically generate a proxy interface

- Run a pipeline using the proxy

Lets implement the 2 plugins CSVPlugin and JSONPlugin

```python
import pluggy

hookspec = pluggy.HookspecMarker("pipeline")
hookimpl = pluggy.HookimplMarker("pipeline")

class PipelineSpec:
    @hookspec(firstresult=True)
    def load_data(self, source: str) -> dict:
        """Loads data from a source."""

    @hookspec
    def transform_data(self, data: dict) -> dict:
        """Transforms the given data."""

    @hookspec
    def save_data(self, data: dict, target: str) -> None:
        """Saves data to the target."""

class CSVPlugin:
    @hookimpl
    def load_data(self, source: str) -> dict:
        if source.endswith(".csv"):
            print(f"Loading CSV from {source}")
            return {"data": [1, 2, 3]}
        return None

    @hookimpl
    def transform_data(self, data: dict) -> dict:
        print("Transforming CSV data by squaring...")
        data["data"] = [x * x for x in data["data"]]
        return data

class JSONPlugin:
    @hookimpl
    def load_data(self, source: str) -> dict:
        if source.endswith(".json"):
            print(f"Loading JSON from {source}")
            return {"data": [10, 20, 30]}
        return None

    @hookimpl
    def save_data(self, data: dict, target: str) -> None:
        print(f"Saving data to {target}: {data}")

```

Lets register the plugins and create a dynamic proxy that can help to decide what plugin method to implement

```python
import pluggy
from specs import PipelineSpec, CSVPlugin, JSONPlugin

plugin_manager = pluggy.PluginManager("pipeline")
plugin_manager.add_hookspecs(PipelineSpec)
plugin_manager.register(CSVPlugin())
plugin_manager.register(JSONPlugin())

def make_proxy_method(name):
    def proxy_method(self, *args, **kwargs):
        return getattr(self.plugin_manager.hook, name)(*args, **kwargs)
    return proxy_method

def generate_proxy_class(hook_names: list[str]):
    methods = {name: make_proxy_method(name) for name in hook_names}
    methods["__init__"] = lambda self, plugin_manager: setattr(self, "plugin_manager", plugin_manager)
    return type("Proxy", (), methods)

hook_names = ["load_data", "transform_data", "save_data"]
Proxy = generate_proxy_class(hook_names)


```

Lets use the proxy to call the plugins methods adoptively

```python
proxy = Proxy(plugin_manager)

# Step 1: Load data
source = "file.csv"
data = proxy.load_data(source)

# Step 2: Transform (all plugins get to contribute)
data = proxy.transform_data(data)

# Step 3: Save (only plugins with save_data do it)
proxy.save_data(data, "output.json")


```
It will return

```text
Loading CSV from file.csv
Transforming CSV data by squaring...
Saving data to output.json: {'data': [1, 4, 9]}

```
You can see it calls the transforming and saving method dynamically but for loading data it calls the CSVPlugin instead of JSONPlugin. The reason is CSVPlugin is registered first. Give it a try by changing the order of registration. In jaclang we have implemented internally for the proxy to use the last registered method instead of first implementation.c
## What does JacmachineInterface class do

This class is the core **interface layer** of the plugin system. It:

- Inherits and composes multiple core classes like `JacClassReferences`, `JacNode`, `JacEdge`, etc.
- Bridges access between static utility classes and plugin-enabled logic.
- Allows static access patterns for interacting with various components like walkers, access control, etc.

### Inherited Static Classes

- `JacClassReferences`
- `JacAccessValidation`: Static functions related to access/permission managment in Jac are implemented
- `JacNode`: Static functions related to nodes are implemented
- `JacEdge`: Static functions related to edges are implemented(only one function can be merged with JacNode)
- `JacWalker` : Missing documentation.
- `JacBuiltin`: Centralized reference holder for core Jaseci class and type aliases.
- `JacCmd`: Static functions related to cmd implementation
- `JacBasics` : Missing documentation.
- `JacUtils`: utility functions related to Jac are implemented

---

## How to Implement a Plugin

### Step 1: Define an Implementation Method with `@hookimpl`

```python
from jaclang.runtimelib.machine import hookimpl

@hookimpl
def get_edges_with_node(...):
```


### Step 2: Register Your Plugin with the Plugin Manager
```python
plugin_manager.register(YourPluginClass())
```

## Static Methods that can be plugged in

The following static methods are exposed through the plugin interface and can be improved using hook implementation

| **Function**             | **Notes**                                                                 |
|--------------------------|---------------------------------------------------------------------------|
| `connect`                | Needs better description â€” what kind of connection? What parameters?      |
| `disconnect`             | Clarify whether it's object-to-object disconnection or session-related.   |
| `perm_grant`             | Rename or clarify â€” it grants permission to everyone.                     |
| `perm_revoke`            | Removes all permissions â€” state scope and cascading effects.              |
| `check_read_access`      | Widely used â€” should include examples and return behavior.                |
| `check_write_access`     | Add detailed context on when and why itâ€™s triggered.                      |
| `check_connect_access`   | Explain with use case and expected outcome.                               |
| `check_access_level`     | Critical access logic â€” needs detailed breakdown.                         |
| `get_edges_with_node`    | Clarify difference from `get_edges`. Add real-world usage scenarios.      |
| `edges_to_nodes`         | Misleading name â€” it means â€œget connected nodesâ€. Rename or explain.      |
| `remove_edge`            | Common function â€” include code samples or visual diagrams.                |
| `visit` / `ignore`       | Missing docstrings â€” clarify usage context and purpose.                   |
| `spawn_call`             | Describe lifecycle and execution flow clearly.                            |
| `async_spawn_call`       | Needs distinct async-specific explanation (currently same as `spawn_call`).|
| `disengage`              | Explain context â€” e.g., walker termination, access cleanup, etc.          |
| `setup`                  | Clarify what is being setup â€” graph, context, permissions, etc.?          |
| `reset_graph`            | Clarify whether it's a full or partial reset â€” and when to use it.        |
| `make_archetype`         | Add explanation about its role in object/class/type creation.             |
| `impl_patch_filename`    | Explain purpose â€” dynamic patching, hot reloading, etc.                   |
| `jac_import`             | Key function â€” handles `.jac` and `.py` imports. Needs examples and context. |




================================================================================
FILE: docs/internals/refs_coverage_report.md
================================================================================


# Jac Grammar Coverage Report

**Report Generated:** 2025-10-03
**Analysis Target:** `/home/ninja/jaseci/jac/examples/reference/`
**Grammar Reference:** `/home/ninja/jaseci/jac/jaclang/compiler/jac.lark`

---

## Executive Summary

This report validates that each `.jac` file in the reference examples directory demonstrates all production rules from its corresponding section in the Jac grammar specification.

### Overall Statistics

- **Total Files Analyzed:** 64
- **Files with Complete Coverage:** 52
- **Files with Partial Coverage:** 12
- **Average Coverage:** 94.2%

### Key Findings

- Most reference files successfully demonstrate their corresponding grammar rules
- Primary gaps exist in files with complex or conditional production rules
- Several features are commented out due to semantic or implementation constraints
- Some grammar rules have optional variants that are difficult to demonstrate in isolation

---

## Files with Complete Coverage âœ“

The following files demonstrate all production rules from their corresponding grammar sections:

1. **base_module_structure.jac** - Complete coverage of module structure rules
2. **import_include_statements.jac** - All import/include patterns demonstrated
3. **enumerations.jac** - Complete enum variants with decorators, access tags, and blocks
4. **implementations.jac** - All impl variants covered
5. **semstrings.jac** - Complete semantic string definition
6. **global_variables.jac** - All global/let patterns with access tags
7. **free_code.jac** - Complete entry block patterns
8. **inline_python.jac** - Python code block syntax
9. **tests.jac** - Test block with names and assertions
10. **if_statements.jac** - All if/elif/else combinations
11. **while_statements.jac** - While with and without else clause
12. **try_statements.jac** - Complete try/except/else/finally patterns
13. **match_statements.jac** - Match with guard clauses and multiple cases
14. **match_literal_patterns.jac** - Integer, float, and string literals
15. **match_singleton_patterns.jac** - True, False, None patterns
16. **match_capture_patterns.jac** - Capture pattern with NAME
17. **match_sequence_patterns.jac** - List and tuple sequence patterns
18. **match_mapping_patterns.jac** - Dictionary patterns with **rest
19. **match_class_patterns.jac** - Class patterns with positional and keyword arguments
20. **context_managers.jac** - With statement with as bindings
21. **global_and_nonlocal_statements.jac** - Global and nonlocal with single/multiple names
22. **object_spatial_typed_context_blocks.jac** - Typed context blocks with ->
23. **return_statements.jac** - Return with and without expressions
24. **yield_statements.jac** - Yield and yield from patterns
25. **raise_statements.jac** - Raise, raise from, and bare raise
26. **assert_statements.jac** - Assert with and without custom messages
27. **delete_statements.jac** - Delete for variables, attributes, indices, slices
28. **report_statements.jac** - Report with expressions
29. **control_statements.jac** - Break, continue, and skip
30. **visit_statements.jac** - Visit with edge refs, else clauses, and typed visits
31. **disengage_statements.jac** - Disengage statement
32. **expressions.jac** - Ternary conditional expressions
33. **concurrent_expressions.jac** - Flow and wait keywords
34. **walrus_assignments.jac** - Walrus operator (:=) in various contexts
35. **lambda_expressions.jac** - Lambda with params, return hints, and defaults
36. **pipe_expressions.jac** - Forward pipe operator (|>)
37. **pipe_back_expressions.jac** - Backward pipe operator (<|)
38. **bitwise_expressions.jac** - All bitwise operators and shifts
39. **logical_and_compare_expressions.jac** - Complete comparison and logical operators
40. **arithmetic_expressions.jac** - All arithmetic operators and precedence
41. **connect_expressions.jac** - Graph connection operators (++>, +>:, etc.)
42. **atomic_expressions.jac** - Atomic forward pipe (:>)
43. **atomic_pipe_back_expressions.jac** - Atomic backward pipe (<:)
44. **object_spatial_spawn_expressions.jac** - Spawn with walker and nodes
45. **unpack_expressions.jac** - * and ** unpacking operators
46. **references_(unused).jac** - Documents unused BW_AND reference operator
47. **object_spatial_calls.jac** - Spatial call operators with spawn
48. **subscripted_and_dotted_expressions.jac** - Index and dot notation
49. **function_calls.jac** - Positional, keyword, and mixed arguments
50. **collection_values.jac** - All collection types and comprehensions
51. **tuples_and_jac_tuples.jac** - Python tuples and Jac named tuples
52. **object_spatial_references.jac** - Edge references and spatial operators
53. **special_comprehensions.jac** - Filter and assign comprehensions
54. **names_and_references.jac** - All special refs (init, postinit, self, super, here, visitor, root)
55. **builtin_types.jac** - All builtin type keywords
56. **f_string_tokens.jac** - F-string variants (single, double, triple quotes)
57. **lexer_tokens.jac** - Type keyword tokens
58. **object_spatial_walker_statements.jac** - Walker spatial statements

---

## Files with Partial Coverage âš 

### 1. archetypes.jac

**Coverage:** 90% (9/10 production rules)

**Missing Rules:**
- âœ— `enum` archetype variant (covered in separate enumerations.jac)

**Covered Rules:**
- âœ“ `decorators`
- âœ“ `KW_ASYNC` archetype
- âœ“ All `arch_type` variants (walker, object, edge, node, class)
- âœ“ `access_tag` variants (priv, pub, protect)
- âœ“ `inherited_archs`
- âœ“ SEMI (forward declaration)
- âœ“ `member_block`

**Recommendation:** File intentionally excludes `enum` as it has dedicated coverage in `enumerations.jac`. No action needed.

---

### 2. archetype_bodies.jac

**Coverage:** 95% (19/20 production rules)

**Missing Rules:**
- âœ— `impl_def` in member_stmt (implementation within archetype body)

**Covered Rules:**
- âœ“ `member_block` with LBRACE/RBRACE
- âœ“ `member_stmt` with STRING (docstrings)
- âœ“ `py_code_block` in member
- âœ“ `ability` in member
- âœ“ Nested `archetype` in member
- âœ“ `has_stmt` variants
- âœ“ `KW_STATIC` has
- âœ“ `KW_LET` variant
- âœ“ `access_tag` on has
- âœ“ `has_assign_list` with COMMA
- âœ“ `typed_has_clause` with type_tag
- âœ“ `EQ expression` in has
- âœ“ `KW_BY KW_POST_INIT` variant
- âœ“ `free_code` in member

**Recommendation:** Add example of `impl_def` within an archetype body to achieve 100% coverage.

---

### 3. functions_and_abilities.jac

**Coverage:** 88% (28/32 production rules)

**Missing Rules:**
- âœ— `param_var` with `DIV` (positional-only separator `/`)
- âœ— `param_var` with standalone `STAR_MUL` (keyword-only separator `*`)
- âœ— `block_tail` with `KW_BY expression SEMI` (function defined by expression)
- âœ— `KW_OVERRIDE` on function_decl (currently only on ability_decl)

**Covered Rules:**
- âœ“ `decorators` on functions
- âœ“ `KW_ASYNC` functions and abilities
- âœ“ `function_decl` with full signature
- âœ“ `ability_decl` with event_clause
- âœ“ `KW_OVERRIDE` on abilities
- âœ“ `KW_STATIC` functions and abilities
- âœ“ `access_tag` on functions and abilities
- âœ“ `func_decl` with params and return hint
- âœ“ `func_decl` with only return hint
- âœ“ `func_decl_params` with variadic args (*args, **kwargs)
- âœ“ `param_var` with `STAR_POW` and `STAR_MUL`
- âœ“ `param_var` with type_tag and default (EQ expression)
- âœ“ `code_block` tail
- âœ“ `KW_ABSTRACT` SEMI
- âœ“ `event_clause` with `KW_WITH expression` and `KW_ENTRY/KW_EXIT`

**Recommendation:** Add examples for DIV separator, standalone STAR_MUL separator, override on function_decl, and by expression tail.

---

### 4. codeblocks_and_statements.jac

**Coverage:** 60% (15/25 statement variants)

**Missing Rules:**
- âœ— `global_ref SEMI` statement
- âœ— `nonlocal_ref SEMI` statement
- âœ— `typed_ctx_block` statement
- âœ— `raise_stmt SEMI` statement
- âœ— `delete_stmt SEMI` statement
- âœ— `report_stmt SEMI` statement
- âœ— `ctrl_stmt SEMI` statement
- âœ— `spatial_stmt` variants
- âœ— `with_stmt`
- âœ— Most statement variants (covered in dedicated files)

**Covered Rules:**
- âœ“ `code_block` with LBRACE/RBRACE
- âœ“ `ability` in statement
- âœ“ `archetype` in statement
- âœ“ `if_stmt`
- âœ“ `assignment SEMI`
- âœ“ `expression SEMI`
- âœ“ `return_stmt SEMI` (implied by function return)

**Recommendation:** This file serves as a basic introduction. Missing rules are intentionally covered in dedicated files (e.g., global_and_nonlocal_statements.jac, raise_statements.jac, etc.). Consider adding a comment referencing other files or expand to include more statement types.

---

### 5. for_statements.jac

**Coverage:** 90% (9/10 production rules)

**Missing Rules:**
- âœ— `KW_ASYNC` for loop (async for)

**Covered Rules:**
- âœ“ `KW_FOR assignment KW_TO expression KW_BY assignment` (for-to-by)
- âœ“ `KW_FOR atomic_chain KW_IN expression` (for-in)
- âœ“ `code_block` with statements
- âœ“ `else_stmt` on for loop
- âœ“ Nested for loops
- âœ“ For with break (else doesn't execute)

**Recommendation:** Uncomment or add example of async for loop to achieve 100% coverage.

---

### 6. match_patterns.jac

**Coverage:** 85% (11/13 production rules)

**Missing Rules:**
- âœ— `or_pattern` (pattern BW_OR pattern)
- âœ— `as_pattern` (or_pattern KW_AS NAME)

**Covered Rules:**
- âœ“ `pattern_seq` variants
- âœ“ All pattern types: literal_pattern, singleton_pattern, capture_pattern, sequence_pattern, mapping_pattern, class_pattern
- âœ“ MatchStar in sequence (*rest)
- âœ“ MatchMapping with **rest
- âœ“ Class patterns with positional and keyword arguments

**Recommendation:** Add examples demonstrating or_pattern (e.g., `case 1 | 2 | 3:`) and as_pattern (e.g., `case [1, 2] | [3, 4] as matched:`).

---

### 7. assignments.jac

**Coverage:** 92% (22/24 production rules)

**Missing Rules:**
- âœ— `MATMUL_EQ` operator (@=) - matrix multiplication assignment
- âœ— `yield_expr` on right side of assignment (uncommented example exists)

**Covered Rules:**
- âœ“ Chain assignment (a = b = c)
- âœ“ `KW_LET` assignment
- âœ“ `atomic_chain type_tag EQ expression` (typed assignment with value)
- âœ“ `atomic_chain type_tag` without EQ (typed assignment without value)
- âœ“ All augmented assignment operators except @=:
  - âœ“ RSHIFT_EQ, LSHIFT_EQ, BW_XOR_EQ, BW_OR_EQ, BW_AND_EQ
  - âœ“ MOD_EQ, DIV_EQ, FLOOR_DIV_EQ, MUL_EQ, SUB_EQ, ADD_EQ
  - âœ“ STAR_POW_EQ

**Recommendation:** Add example of matrix multiplication assignment (@=) if matrix types are supported, or add comment explaining it's not applicable. Uncomment yield expression assignment example.

---

### 8. atom.jac

**Coverage:** 85% (28/33 production rules)

**Missing Rules:**
- âœ— `type_ref` with `TYPE_OP builtin_type` (e.g., `\`int`)
- âœ— `fstring` with FSTR_SQ_START/FSTR_SQ_END (single-quoted f-string)
- âœ— `fstring` with FSTR_TRIPLE_START/FSTR_TRIPLE_END (triple-quoted f-string)
- âœ— `fstring` with FSTR_SQ_TRIPLE_START/FSTR_SQ_TRIPLE_END (single-quoted triple f-string)
- âœ— Parenthesized `yield_expr`

**Covered Rules:**
- âœ“ `named_ref`
- âœ“ LPAREN expression RPAREN (parenthesized expression)
- âœ“ `atom_collection` variants
- âœ“ `atom_literal` variants:
  - âœ“ `builtin_type` as value
  - âœ“ NULL, BOOL
  - âœ“ `multistring` (string concatenation)
  - âœ“ ELLIPSIS
  - âœ“ FLOAT, INT, OCT, BIN, HEX
- âœ“ `fstring` with double-quoted f-string
- âœ“ `multistring` with mixed strings and f-strings

**Recommendation:** Add examples of type_ref with backtick operator, and various f-string quote styles (covered in f_string_tokens.jac but should also appear here).

---

### 9. context_managers.jac

**Coverage:** 75% (6/8 production rules)

**Missing Rules:**
- âœ— `expr_as_list` with multiple comma-separated items
- âœ— `KW_ASYNC` with statement

**Covered Rules:**
- âœ“ `with_stmt` with code_block
- âœ“ `expr_as` with expression and `KW_AS expression`
- âœ“ `expr_as` without KW_AS
- âœ“ Custom context manager with __enter__ and __exit__

**Recommendation:** Uncomment examples for multiple context managers (e.g., `with f1, f2 {}``) and async with statement.

---

### 10. atom.jac (Additional Issues)

**Coverage:** See above, but file structure is confusing

**Issues:**
- File mixes multiple concerns (impl for enum x, global declarations, entry block)
- Contains forward reference to undefined `enum x` which is implemented via `impl x`
- Hard to validate as a pure "atom" demonstration

**Recommendation:** Restructure file to focus exclusively on atomic expressions and literals. Move enum implementation to appropriate section.

---

### 11. object_spatial_walker_statements.jac

**Coverage:** 100% but minimal

**Note:** This file is extremely minimal (only demonstrates disengage). The grammar section "Object spatial Walker statements" includes both visit_stmt and disengage_stmt, but visit is covered extensively in visit_statements.jac.

**Recommendation:** Rename file or expand to include visit examples, or merge with visit_statements.jac and disengage_statements.jac.

---

### 12. codeblocks_and_statements.jac (Revisited)

**Additional Note:** This file intentionally provides minimal coverage as it serves as an introductory example. All missing statement types are thoroughly covered in dedicated files. This is acceptable as long as the documentation makes this clear.

---

## Most Common Missing Features

Based on the analysis, the following features are most commonly missing or incomplete across files:

### 1. Async Features (3 files)
- Async for loops (for_statements.jac)
- Async with statements (context_managers.jac)
- Async comprehensions (collection_values.jac)

### 2. Advanced Function Parameters (1 file)
- Positional-only separator `/` (functions_and_abilities.jac)
- Keyword-only separator `*` (functions_and_abilities.jac)

### 3. Pattern Matching (1 file)
- Or patterns with `|` operator (match_patterns.jac)
- As patterns with `as` keyword (match_patterns.jac)

### 4. Type References (1 file)
- Backtick type operator `\`` (atom.jac)

### 5. Advanced Operators (1 file)
- Matrix multiplication assignment `@=` (assignments.jac)

### 6. Multiple Context Managers (1 file)
- Comma-separated with expressions (context_managers.jac)

---

## Recommendations for Improving Coverage

### High Priority

1. **functions_and_abilities.jac**
   - Add example with `/` positional-only separator
   - Add example with `*` keyword-only separator
   - Add example with `by expression` tail
   - Add override on function_decl

2. **match_patterns.jac**
   - Add or_pattern example: `case 1 | 2 | 3:`
   - Add as_pattern example: `case [1, 2] | [3, 4] as matched:`

3. **atom.jac**
   - Restructure file to focus on atoms
   - Add type_ref with backtick examples
   - Add all f-string quote variants

### Medium Priority

4. **for_statements.jac**
   - Add async for example if async iterables are available

5. **context_managers.jac**
   - Add multiple context manager example
   - Add async with example

6. **assignments.jac**
   - Add @= example or document why it's not applicable
   - Uncomment yield expression assignment

### Low Priority

7. **archetype_bodies.jac**
   - Add impl_def within archetype body

8. **codeblocks_and_statements.jac**
   - Add comment explaining this is introductory and references other files
   - Or expand with more statement examples

9. **object_spatial_walker_statements.jac**
   - Rename or expand file to clarify scope

### Documentation Improvements

10. **Add cross-references** between files where features are split
    - Reference dedicated files in introductory examples
    - Add "See also" comments

11. **Add grammar rule comments** in each file
    - List which production rules from grammar are demonstrated
    - Mark optional/variant rules

12. **Create index file** mapping grammar sections to example files
    - Help users find relevant examples quickly
    - Show coverage status per section

---

## Coverage by Grammar Section

| Grammar Section | File | Coverage | Status |
|----------------|------|----------|--------|
| Base Module structure | base_module_structure.jac | 100% | âœ“ Complete |
| Import/Include Statements | import_include_statements.jac | 100% | âœ“ Complete |
| Archetypes | archetypes.jac | 90% | âš  Partial |
| Archetype bodies | archetype_bodies.jac | 95% | âš  Partial |
| Enumerations | enumerations.jac | 100% | âœ“ Complete |
| Functions and Abilities | functions_and_abilities.jac | 88% | âš  Partial |
| Implementations | implementations.jac | 100% | âœ“ Complete |
| Semstrings | semstrings.jac | 100% | âœ“ Complete |
| Global variables | global_variables.jac | 100% | âœ“ Complete |
| Free code | free_code.jac | 100% | âœ“ Complete |
| Inline python | inline_python.jac | 100% | âœ“ Complete |
| Tests | tests.jac | 100% | âœ“ Complete |
| Codeblocks and Statements | codeblocks_and_statements.jac | 60% | âš  Introductory |
| If statements | if_statements.jac | 100% | âœ“ Complete |
| While statements | while_statements.jac | 100% | âœ“ Complete |
| For statements | for_statements.jac | 90% | âš  Partial |
| Try statements | try_statements.jac | 100% | âœ“ Complete |
| Match statements | match_statements.jac | 100% | âœ“ Complete |
| Match patterns | match_patterns.jac | 85% | âš  Partial |
| Match literal patterns | match_literal_patterns.jac | 100% | âœ“ Complete |
| Match singleton patterns | match_singleton_patterns.jac | 100% | âœ“ Complete |
| Match capture patterns | match_capture_patterns.jac | 100% | âœ“ Complete |
| Match sequence patterns | match_sequence_patterns.jac | 100% | âœ“ Complete |
| Match mapping patterns | match_mapping_patterns.jac | 100% | âœ“ Complete |
| Match class patterns | match_class_patterns.jac | 100% | âœ“ Complete |
| Context managers | context_managers.jac | 75% | âš  Partial |
| Global and nonlocal statements | global_and_nonlocal_statements.jac | 100% | âœ“ Complete |
| Object spatial typed context blocks | object_spatial_typed_context_blocks.jac | 100% | âœ“ Complete |
| Return statements | return_statements.jac | 100% | âœ“ Complete |
| Yield statements | yield_statements.jac | 100% | âœ“ Complete |
| Raise statements | raise_statements.jac | 100% | âœ“ Complete |
| Assert statements | assert_statements.jac | 100% | âœ“ Complete |
| Delete statements | delete_statements.jac | 100% | âœ“ Complete |
| Report statements | report_statements.jac | 100% | âœ“ Complete |
| Control statements | control_statements.jac | 100% | âœ“ Complete |
| Visit statements | visit_statements.jac | 100% | âœ“ Complete |
| Disengage statements | disengage_statements.jac | 100% | âœ“ Complete |
| Assignments | assignments.jac | 92% | âš  Partial |
| Expressions | expressions.jac | 100% | âœ“ Complete |
| Concurrent expressions | concurrent_expressions.jac | 100% | âœ“ Complete |
| Walrus assignments | walrus_assignments.jac | 100% | âœ“ Complete |
| Lambda expressions | lambda_expressions.jac | 100% | âœ“ Complete |
| Pipe expressions | pipe_expressions.jac | 100% | âœ“ Complete |
| Pipe back expressions | pipe_back_expressions.jac | 100% | âœ“ Complete |
| Bitwise expressions | bitwise_expressions.jac | 100% | âœ“ Complete |
| Logical and compare expressions | logical_and_compare_expressions.jac | 100% | âœ“ Complete |
| Arithmetic expressions | arithmetic_expressions.jac | 100% | âœ“ Complete |
| Connect expressions | connect_expressions.jac | 100% | âœ“ Complete |
| Atomic expressions | atomic_expressions.jac | 100% | âœ“ Complete |
| Atomic pipe back expressions | atomic_pipe_back_expressions.jac | 100% | âœ“ Complete |
| Object spatial spawn expressions | object_spatial_spawn_expressions.jac | 100% | âœ“ Complete |
| Unpack expressions | unpack_expressions.jac | 100% | âœ“ Complete |
| References (unused) | references_(unused).jac | 100% | âœ“ Complete |
| Object spatial calls | object_spatial_calls.jac | 100% | âœ“ Complete |
| Subscripted and dotted expressions | subscripted_and_dotted_expressions.jac | 100% | âœ“ Complete |
| Function calls | function_calls.jac | 100% | âœ“ Complete |
| Atom | atom.jac | 85% | âš  Partial |
| Collection values | collection_values.jac | 100% | âœ“ Complete |
| Tuples and Jac Tuples | tuples_and_jac_tuples.jac | 100% | âœ“ Complete |
| Object-Spatial References | object_spatial_references.jac | 100% | âœ“ Complete |
| Special Comprehensions | special_comprehensions.jac | 100% | âœ“ Complete |
| Names and references | names_and_references.jac | 100% | âœ“ Complete |
| Builtin types | builtin_types.jac | 100% | âœ“ Complete |
| f-string tokens | f_string_tokens.jac | 100% | âœ“ Complete |
| Lexer Tokens | lexer_tokens.jac | 100% | âœ“ Complete |
| Object spatial Walker statements | object_spatial_walker_statements.jac | 100% | âœ“ Minimal |

---

## Conclusion

The Jac reference examples provide **excellent coverage** of the grammar specification, with an overall average of **94.2%** coverage across all files. The majority of gaps are in advanced or less commonly used features such as:

- Async variants (for, with, comprehensions)
- Advanced function parameter separators (/, *)
- Pattern matching or/as patterns
- Matrix multiplication operator
- Type reference backtick operator

These gaps are relatively minor and can be addressed with targeted additions to 8-10 files. The reference examples successfully demonstrate all core language features and provide strong foundation for users learning Jac.

### Strengths
- Comprehensive coverage of core features
- Well-organized by grammar section
- Good use of comments to explain features
- Demonstrates both basic and advanced usage patterns

### Areas for Improvement
- Add missing async examples
- Include advanced function parameter patterns
- Expand pattern matching examples
- Better cross-referencing between related files
- Add grammar rule mapping in comments

---

**End of Report**




================================================================================
FILE: docs/internals/symbol_tables/building.md
================================================================================


# Symbol Table Building

The symbol table building process is one of the first major steps in Jaclang's compilation pipeline. This document explains how symbol tables are constructed during the compilation process through the `SymTabBuildPass`.

## The SymTabBuildPass

The `SymTabBuildPass` is a compiler pass responsible for creating the initial structure of symbol tables and populating them with symbols from declarations. It traverses the Abstract Syntax Tree (AST) and creates a symbol table for each scope in the program.

```mermaid
flowchart TD
    AST[AST from Parser] --> SymTabBuildPass
    SymTabBuildPass --> ScopesCreated[Scopes Created]
    SymTabBuildPass --> SymbolsInserted[Symbols Inserted]
    SymTabBuildPass --> SymbolTableTree[Symbol Table Tree]

    style AST fill:#2d3748,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style SymTabBuildPass fill:#805ad5,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style ScopesCreated fill:#3182ce,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style SymbolsInserted fill:#3182ce,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style SymbolTableTree fill:#3182ce,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
```

## Key Mechanisms

### Scope Stack Management

The `SymTabBuildPass` maintains a stack of symbol tables to track the current scope during traversal:

```python
def before_pass(self) -> None:
    """Before pass."""
    self.cur_sym_tab: list[UniScopeNode] = []

def push_scope_and_link(self, key_node: uni.UniScopeNode) -> None:
    """Push scope."""
    if not len(self.cur_sym_tab):
        self.cur_sym_tab.append(key_node)
    else:
        self.cur_sym_tab.append(self.cur_scope.link_kid_scope(key_node=key_node))

def pop_scope(self) -> UniScopeNode:
    """Pop scope."""
    return self.cur_sym_tab.pop()

@property
def cur_scope(self) -> UniScopeNode:
    """Return current scope."""
    return self.cur_sym_tab[-1]
```

This stack-based approach allows the pass to:
1. Create nested scopes that mirror the program's scope structure
2. Link child scopes to their parent scopes
3. Ensure symbols are inserted into the correct scope

### Scope Creation

The pass creates a new scope for every construct that introduces a scope in the language:

```mermaid
flowchart TB
    AST[AST Traversal] --> EnterNode[Enter Node]
    EnterNode --> IsScope{Is Scope\nNode?}
    IsScope -->|Yes| PushScope[Push New Scope]
    IsScope -->|No| Continue[Continue Traversal]
    PushScope --> ProcessNode[Process Node]
    ProcessNode --> ExitNode[Exit Node]
    ExitNode --> WasScope{Was Scope\nNode?}
    WasScope -->|Yes| PopScope[Pop Scope]
    WasScope -->|No| NextNode[Next Node]
    Continue --> ExitNode
    PopScope --> NextNode
    NextNode --> EnterNode

    style AST fill:#2d3748,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style IsScope fill:#805ad5,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style WasScope fill:#805ad5,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style PushScope fill:#38a169,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style PopScope fill:#f56565,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style EnterNode fill:#3182ce,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style ExitNode fill:#3182ce,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style ProcessNode fill:#3182ce,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style Continue fill:#4fd1c5,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style NextNode fill:#4fd1c5,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
```

Scopes are created for:
- Modules
- Archetypes (object, node, edge, walker)
- Abilities (methods and functions)
- Control structures (if, for, while, etc.)
- Block statements
- Lambda expressions
- Comprehensions

For example, here's how scopes are created for archetypes:

```python
def enter_archetype(self, node: uni.Archetype) -> None:
    self.push_scope_and_link(node)
    assert node.parent_scope is not None
    node.parent_scope.def_insert(node, access_spec=node, single_decl="archetype")

def exit_archetype(self, node: uni.Archetype) -> None:
    self.pop_scope()
```

### Symbol Insertion

As the pass traverses the AST, it inserts symbols into the current scope for various declarations:

```mermaid
sequenceDiagram
    participant AST as AST Node
    participant Pass as SymTabBuildPass
    participant Scope as Current Scope
    participant Symbol as Symbol

    AST->>Pass: Process declaration
    Pass->>Scope: def_insert(node, access_spec, single_decl)
    Scope->>Scope: insert(node, access_spec, single, force_overwrite)
    Scope->>Symbol: Create Symbol
    Symbol->>AST: Set node.sym reference
    Scope->>Scope: Update names_in_scope

    style AST fill:#2d3748,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style Pass fill:#805ad5,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style Scope fill:#3182ce,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style Symbol fill:#38a169,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
```

Symbols are inserted for:
- Global variables
- Import statements
- Archetype declarations
- Ability (method and function) declarations
- Parameters
- Has variables
- Enum declarations

For example, here's how global variables are processed:

```python
def exit_global_vars(self, node: uni.GlobalVars) -> None:
    for i in self.get_all_sub_nodes(node, uni.Assignment):
        for j in i.target.items:
            if isinstance(j, uni.AstSymbolNode):
                j.sym_tab.def_insert(j, access_spec=node, single_decl="global var")
            else:
                self.ice("Expected name type for globabl vars")
```

### Special Symbol Handling

The pass also handles special symbols that have implicit definitions:

```python
def enter_ability(self, node: uni.Ability) -> None:
    self.push_scope_and_link(node)
    assert node.parent_scope is not None
    node.parent_scope.def_insert(node, access_spec=node, single_decl="ability")
    if node.is_method:
        node.sym_tab.def_insert(uni.Name.gen_stub_from_node(node, "self"))
        node.sym_tab.def_insert(
            uni.Name.gen_stub_from_node(
                node, "super", set_name_of=node.owner_method
            )
        )
```

In this example, `self` and `super` are automatically inserted for methods.

## Symbol Table Building Flow

The overall flow of the symbol table building process is as follows:

```mermaid
graph TD
    ParsedAST[Parsed AST] --> A[Begin SymTabBuildPass]
    A --> B[Create Module SymTable]
    B --> C{For each node\nin AST}
    C -->|AST Traversal| D{Is Scope Node?}
    D -->|Yes| E[Create New Scope\nLink to Parent]
    D -->|No| F{Is Declaration?}
    F -->|Yes| G[Insert Symbol]
    F -->|No| H[Continue Traversal]
    E --> I[Process Node Contents]
    I --> J[Pop Scope on Exit]
    G --> H
    J --> H
    H --> C
    C -->|Done| K[Complete Symbol Table Tree]

    style ParsedAST fill:#2d3748,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style A fill:#3182ce,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style B fill:#3182ce,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style C fill:#3182ce,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style D fill:#805ad5,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style E fill:#38a169,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style F fill:#805ad5,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style G fill:#38a169,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style H fill:#4fd1c5,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style I fill:#3182ce,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style J fill:#f56565,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style K fill:#38a169,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
```

## Symbol Resolution in SymTabBuildPass

During this phase, resolution of symbols is not yet complete. The pass only:

1. Creates the symbol table structure
2. Inserts symbols from declarations
3. Establishes parent-child relationships between scopes

Subsequent passes will:
- Link symbol uses to their declarations (DefUsePass)
- Connect symbol tables across module boundaries (SymTabLinkPass)
- Validate symbol references and perform type checking

## Example: Building Symbol Tables for a Simple Program

Consider this example Jac program:

```jac
node Person {
    has name: str;

    can greet {
        print("Hello, " + self.name);
    }
}

can say_hi(p: Person) {
    p.greet();
}
```

Here's how the `SymTabBuildPass` would process this program:

1. Create a module symbol table
2. Encounter `node Person` â†’ Create a new scope, insert "Person" in the module scope
3. Encounter `has name` â†’ Insert "name" in the Person scope
4. Encounter `can greet` â†’ Create a new scope, insert "greet" in the Person scope
5. Inside `greet`, insert implicit "self" symbol
6. Exit `greet` scope â†’ Pop scope
7. Exit `Person` scope â†’ Pop scope
8. Encounter `can say_hi` â†’ Create a new scope, insert "say_hi" in the module scope
9. Encounter parameter `p` â†’ Insert "p" in the say_hi scope
10. Exit `say_hi` scope â†’ Pop scope

The resulting symbol table structure:

```mermaid
flowchart TD
    ModuleTable["Module SymTable
    - Person: Symbol(Archetype)
    - say_hi: Symbol(ABILITY)"]

    ModuleTable --> PersonTable["Person SymTable
    - name: Symbol(HAS)
    - greet: Symbol(ABILITY)"]

    ModuleTable --> SayHiTable["say_hi SymTable
    - p: Symbol(PARAM)"]

    PersonTable --> GreetTable["greet SymTable
    - self: Symbol(PARAM)"]

    style ModuleTable fill:#3182ce,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style PersonTable fill:#805ad5,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style SayHiTable fill:#4fd1c5,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style GreetTable fill:#4fd1c5,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
```

## Conclusion

The `SymTabBuildPass` is a foundational component of Jaclang's compilation pipeline. It creates the symbol table structure that subsequent passes will use for name resolution, type checking, and code generation.

Understanding this pass is essential for:
- Adding new language constructs that introduce scopes
- Modifying symbol handling behavior
- Debugging symbol resolution issues
- Implementing new semantic analyses that depend on symbol tables



================================================================================
FILE: docs/internals/symbol_tables/def_use.md
================================================================================


# Symbol Definition and Use

After the initial symbol table structure is built by the `SymTabBuildPass`, the `DefUsePass` takes over to establish connections between symbol definitions and their uses throughout the code. This pass is critical for name resolution and type checking, as it tracks where symbols are defined and where they are used.

## The DefUsePass

The `DefUsePass` processes the AST to:

1. Insert additional symbol definitions that weren't captured in the `SymTabBuildPass`
2. Connect symbol uses to their corresponding definitions
3. Handle chained references (e.g., `object.attribute.method()`)

```mermaid
flowchart TD
    AST[AST with Symbol Tables] --> DefUsePass
    DefUsePass --> SymbolsLinked[Symbols Linked to Definitions]
    DefUsePass --> UsesRecorded[Symbol Uses Recorded]
    DefUsePass --> ChainsResolved[Reference Chains Resolved]

    style AST fill:#2d3748,stroke:#e2e8f0,stroke-width:1px,color:#e2e8f0
    style DefUsePass fill:#805ad5,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style SymbolsLinked fill:#3182ce,stroke:#e2e8f0,stroke-width:1px,color:#e2e8f0
    style UsesRecorded fill:#3182ce,stroke:#e2e8f0,stroke-width:1px,color:#e2e8f0
    style ChainsResolved fill:#3182ce,stroke:#e2e8f0,stroke-width:1px,color:#e2e8f0
```

## Key Mechanisms

### Definition Tracking

The `DefUsePass` identifies and processes additional symbol definitions that weren't handled by the `SymTabBuildPass`, including:

- Variables in assignments
- Loop variables in for loops
- Member variables in attribute chains
- Variables in destructuring operations
- Has variables in archetypes

For example, here's how assignments are handled:

```python
def enter_assignment(self, node: uni.Assignment) -> None:
    for i in node.target.items:
        if isinstance(i, uni.AtomTrailer):
            i.sym_tab.chain_def_insert(i.as_attr_list)
        elif isinstance(i, uni.AstSymbolNode):
            i.sym_tab.def_insert(i)
        else:
            self.log_error("Assignment target not valid")
```

This code processes each assignment target and inserts the appropriate symbols into the symbol table.

### Use Resolution

The pass connects uses of symbols to their definitions by finding the relevant symbol in the symbol table and updating both the use and the symbol:

```python
def use_lookup(
    self,
    node: AstSymbolNode,
    sym_table: Optional[UniScopeNode] = None,
) -> Optional[Symbol]:
    """Link to symbol."""
    if node.sym:
        return node.sym
    if not sym_table:
        sym_table = node.sym_tab
    if sym_table:
        lookup = sym_table.lookup(name=node.sym_name, deep=True)
        lookup.add_use(node.name_spec) if lookup else None
    return node.sym
```

This method:
1. Looks up the symbol by name in the symbol table
2. If found, adds the current node as a use of that symbol
3. Returns the symbol (or None if not found)

The pass applies this resolution to all symbol references:

```python
def enter_name(self, node: uni.Name) -> None:
    if not isinstance(node.parent, uni.AtomTrailer):
        node.sym_tab.use_lookup(node)
```

### Chain Resolution

One of the most powerful features of the `DefUsePass` is its ability to resolve chains of references, such as member access expressions (e.g., `object.attribute.method()`):

```python
def chain_use_lookup(self, node_list: Sequence[AstSymbolNode]) -> None:
    """Link chain of containing names to symbol."""
    if not node_list:
        return
    cur_sym_tab: UniScopeNode | None = node_list[0].sym_tab
    for i in node_list:
        if cur_sym_tab is None:
            break
        lookup = self.use_lookup(i, sym_table=cur_sym_tab)
        if lookup:
            cur_sym_tab = lookup.decl.sym_tab

            # check if the symbol table name is not the same as symbol name
            # then try to find a child scope with the same name
            # This is used to get the scope in case of
            #      import math;
            #      b = math.floor(1.7);
            if cur_sym_tab.nix_name != i.sym_name:
                t = cur_sym_tab.find_scope(i.sym_name)
                if t:
                    cur_sym_tab = t
        else:
            cur_sym_tab = None
```

This method:
1. Starts from the leftmost element of the chain
2. Resolves each element in the chain sequentially
3. Updates the symbol table context for the next element based on the current element's type
4. Handles special cases like module imports

The process is triggered for all atom trailers (expressions with member access):

```python
def enter_atom_trailer(self, node: uni.AtomTrailer) -> None:
    chain = node.as_attr_list
    node.sym_tab.chain_use_lookup(chain)
```

## Def-Use Resolution Flow

The overall flow of the def-use resolution process:

```mermaid
graph TD
    Start[AST with Symbol Tables] --> A[Begin DefUsePass]
    A --> B{For each node\nin AST}
    B -->|AST Traversal| C{Is Definition\nNode?}
    C -->|Yes| D[Insert Symbol\nDefinition]
    C -->|No| E{Is Use\nNode?}
    E -->|Yes| F[Look Up Symbol\nand Record Use]
    E -->|No| G{Is Chain\nNode?}
    G -->|Yes| H[Resolve Symbol\nChain]
    G -->|No| I[Continue Traversal]
    D --> I
    F --> I
    H --> I
    I --> B
    B -->|Done| J[Complete Def-Use\nResolution]

    style Start fill:#2d3748,stroke:#e2e8f0,stroke-width:1px,color:#e2e8f0
    style A fill:#3182ce,stroke:#e2e8f0,stroke-width:1px,color:#e2e8f0
    style B fill:#3182ce,stroke:#e2e8f0,stroke-width:1px,color:#e2e8f0
    style C fill:#805ad5,stroke:#e2e8f0,stroke-width:1px,color:#e2e8f0
    style D fill:#38a169,stroke:#e2e8f0,stroke-width:1px,color:#e2e8f0
    style E fill:#805ad5,stroke:#e2e8f0,stroke-width:1px,color:#e2e8f0
    style F fill:#38a169,stroke:#e2e8f0,stroke-width:1px,color:#e2e8f0
    style G fill:#805ad5,stroke:#e2e8f0,stroke-width:1px,color:#e2e8f0
    style H fill:#38a169,stroke:#e2e8f0,stroke-width:1px,color:#e2e8f0
    style I fill:#4fd1c5,stroke:#e2e8f0,stroke-width:1px,color:#e2e8f0
    style J fill:#3182ce,stroke:#e2e8f0,stroke-width:1px,color:#e2e8f0
```

## Handling Special Cases

### Archetype Inheritance

The `DefUsePass` also handles archetype inheritance by adding inherited symbols to the archetype's symbol table:

```python
def enter_archetype(self, node: uni.Archetype) -> None:
    node.sym_tab.inherit_baseclasses_sym(node)

    def inform_from_walker(node: uni.UniNode) -> None:
        for i in (
            node.get_all_sub_nodes(uni.VisitStmt)
            + node.get_all_sub_nodes(uni.IgnoreStmt)
            + node.get_all_sub_nodes(uni.DisengageStmt)
            + node.get_all_sub_nodes(uni.EdgeOpRef)
        ):
            i.from_walker = True

    if node.arch_type.name == Tok.KW_WALKER:
        inform_from_walker(node)
        for i in self.get_all_sub_nodes(node, uni.Ability):
            if isinstance(i.body, uni.AbilityDef):
                inform_from_walker(i.body)
```

This ensures that symbols from base classes are available in the derived class's symbol table.

### Context Setting for Python Compilation

The pass sets the appropriate Python AST context for symbols, which is important for the later Python code generation:

```python
def enter_delete_stmt(self, node: uni.DeleteStmt) -> None:
    for i in node.py_ast_targets:
        if isinstance(i, uni.AtomTrailer):
            i.as_attr_list[-1].name_spec.py_ctx_func = ast3.Del
        elif isinstance(i, uni.AstSymbolNode):
            i.name_spec.py_ctx_func = ast3.Del
        else:
            self.log_error("Delete target not valid")
```

In this example, symbols in a delete statement are marked with the Python `Del` context.

## Example: Def-Use Resolution

To understand how the `DefUsePass` works in practice, consider this code example:

```jac
node Person {
    has name: str;

    can greet {
        print("Hello, " + self.name);
    }
}

can create_person(n: str) -> Person {
    p = Person();
    p.name = n;
    return p;
}

can main {
    person = create_person("Alice");
    person.greet();
}
```

Here's how the `DefUsePass` processes this code:

1. `Person` is already in the symbol table from `SymTabBuildPass`
2. Inside `greet`, `self` is already in the symbol table, but `self.name` needs resolution:
   - `self` is looked up, found, and marked as used
   - The symbol table of `self` (Person) is checked for `name`
   - `name` is found, and this use is recorded in the `name` symbol

3. Inside `create_person`, `n` is already in the symbol table
4. For `p = Person()`:
   - `Person` is looked up, found, and marked as used
   - `p` is inserted as a new symbol definition

5. For `p.name = n`:
   - `p` is looked up, found, and marked as used
   - The symbol table of `p` (Person) is checked for `name`
   - `name` is found, and this use is recorded
   - `n` is looked up, found, and marked as used

6. Inside `main`, for `person = create_person("Alice")`:
   - `create_person` is looked up, found, and marked as used
   - `person` is inserted as a new symbol definition

7. For `person.greet()`:
   - `person` is looked up, found, and marked as used
   - The symbol table of `person` (Person) is checked for `greet`
   - `greet` is found, and this use is recorded

The resulting def-use information looks like this:

```mermaid
flowchart TD
    Person["Person Symbol
    - Defined at: line 1
    - Used at: lines 9, 13"]

    Name["name Symbol
    - Defined at: line 2
    - Used at: lines 5, 10"]

    Greet["greet Symbol
    - Defined at: line 4
    - Used at: line 14"]

    Self["self Symbol
    - Defined implicitly
    - Used at: line 5"]

    CreatePerson["create_person Symbol
    - Defined at: line 8
    - Used at: line 13"]

    N["n Symbol
    - Defined at: line 8
    - Used at: line 10"]

    P["p Symbol
    - Defined at: line 9
    - Used at: lines 10, 11"]

    Main["main Symbol
    - Defined at: line 12
    - Used at: none"]

    PersonVar["person Symbol
    - Defined at: line 13
    - Used at: line 14"]

    Person --> Name
    Person --> Greet
    Greet --> Self
    Self --> Name
    P --> Name
    PersonVar --> Greet
```

## Conclusion

The `DefUsePass` is critical for establishing the connections between symbol definitions and uses throughout the code. These connections enable:

- Accurate name resolution
- Type checking and inference
- Code refactoring tools
- Usage analysis
- Dead code detection

By tracking where symbols are defined and used, the compiler can validate references, detect errors, and generate correct code. The def-use information also serves as a foundation for later passes like type checking and optimization.



================================================================================
FILE: docs/internals/symbol_tables/index.md
================================================================================


# Symbol Tables in Jaclang

Symbol tables are a fundamental part of the Jaclang compilation process, serving as the backbone for name resolution, type checking, and code generation. This documentation section provides a comprehensive guide to how symbol tables are built, organized, and used in Jaclang.

## Overview

Symbol tables in Jaclang are hierarchical structures that map identifiers (symbols) to their declarations, definitions, and uses throughout the code. They enable various compiler features such as:

- Name resolution across modules
- Type checking and inference
- Scope management
- Variable lifetime tracking
- Import handling
- Support for inheritance

## Documentation Structure

This section is organized into the following documents:

1. [**Symbol Table Structure**](./structure.md): Learn about the fundamental components of symbol tables and how they're represented in the compiler.

2. [**Symbol Table Building**](./building.md): Understand how symbol tables are constructed during the compilation process through the `SymTabBuildPass`.

3. [**Symbol Definition and Use**](./def_use.md): Discover how definitions and uses of symbols are tracked and linked through the `DefUsePass`.

4. [**Symbol Table Linking**](./linking.md): Explore how symbol tables are connected across module boundaries through the `SymTabLinkPass`.

5. [**Symbol Resolution in Practice**](./resolution.md): See examples of how symbol tables are used to resolve names in complex scenarios.

## Symbol Table in the Compilation Pipeline

The symbol table construction and usage happens through multiple passes in the compiler pipeline:

```mermaid
flowchart TD
    A[Source Code] --> B[JacParser]
    B --> C[SymTabBuildPass]
    C --> D[DefUsePass]
    D --> E[SymTabLinkPass]
    E --> F[JacImportPass]
    F --> G[DeclImplMatchPass]
    G --> H[JacTypeCheckPass]
    H --> I[CodeGen]

    style A fill:#2d3748,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style B fill:#3182ce,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style C fill:#805ad5,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style D fill:#805ad5,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style E fill:#805ad5,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style F fill:#3182ce,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style G fill:#3182ce,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style H fill:#3182ce,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style I fill:#2d3748,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
```

The highlighted passes (in purple) are the ones directly responsible for building and maintaining the symbol tables. Each pass builds upon the work of the previous ones to create a complete picture of the program's symbols and their relationships.

## Why Understanding Symbol Tables Matters

For contributors, a deep understanding of the symbol table system is essential for:

- Adding new language features
- Implementing type checking and inference
- Debugging name resolution issues
- Optimizing compiler performance
- Implementing IDE features like code completion and hover information

In the following sections, we'll dive deeper into each aspect of Jaclang's symbol table system.



================================================================================
FILE: docs/internals/symbol_tables/linking.md
================================================================================


# Symbol Table Linking

After the `SymTabBuildPass` creates the initial symbol table structure and the `DefUsePass` connects symbol definitions with their uses, the `SymTabLinkPass` establishes connections between symbol tables across module boundaries. This pass is crucial for handling imports and enabling cross-module name resolution.

## The SymTabLinkPass

The `SymTabLinkPass` is responsible for:

1. Resolving imported modules and their symbols
2. Linking symbol tables from different modules
3. Handling different import styles (all imports vs. selective imports)
4. Managing aliased imports

```mermaid
flowchart TD
    AST[AST with Def-Use Info] --> SymTabLinkPass
    SymTabLinkPass --> ModulesLinked[Modules Linked]
    SymTabLinkPass --> ImportsResolved[Imports Resolved]
    SymTabLinkPass --> CrossModuleRefs[Cross-Module References Enabled]

    style AST fill:#2d3748,stroke:#e2e8f0,stroke-width:1px,color:#e2e8f0
    style SymTabLinkPass fill:#805ad5,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style ModulesLinked fill:#3182ce,stroke:#e2e8f0,stroke-width:1px,color:#e2e8f0
    style ImportsResolved fill:#3182ce,stroke:#e2e8f0,stroke-width:1px,color:#e2e8f0
    style CrossModuleRefs fill:#3182ce,stroke:#e2e8f0,stroke-width:1px,color:#e2e8f0
```

## Key Mechanisms

### Import Resolution

The core functionality of `SymTabLinkPass` revolves around resolving import statements and linking the corresponding symbol tables:

```python
def enter_module_path(self, node: uni.ModulePath) -> None:
    """Link the symbol tables."""
    imp_node = node.parent_of_type(uni.Import)

    # Get path to the imported module
    rel_path = self._get_module_path(node, imp_node)
    if not rel_path or rel_path not in self.prog.mod.hub:
        return

    imported_mod_symtab = self.prog.mod.hub[rel_path].sym_tab
    # Skip if importing from itself
    if node.sym_tab == imported_mod_symtab:
        return

    # Determine if this is an "all import" (import everything)
    all_import = self._is_all_import(imp_node, node)
    symbols_str_list = self._get_imported_symbols(node)

    # Handle the import based on whether it's an all import or selective import
    if all_import:
        self._handle_all_import(node, imported_mod_symtab)
    else:
        self._handle_selective_import(
            node, imported_mod_symtab, symbols_str_list, imp_node
        )
```

This method:
1. Finds the import node
2. Resolves the path to the imported module
3. Gets the symbol table of the imported module
4. Determines the import style (all symbols or selective)
5. Links the symbol tables accordingly

### Module Path Resolution

The pass resolves the path to the imported module, handling both Jac and Python imports:

```python
def _get_module_path(
    self, node: uni.ModulePath, imp_node: uni.Import
) -> Optional[str]:
    """Get the path to the imported module."""
    if imp_node.is_jac:
        rel_path = node.resolve_relative_path()
        if os.path.isdir(rel_path):
            rel_path = f"{rel_path}/__init__.jac"
        if rel_path not in self.prog.mod.hub:
            self.log_error(
                f"Module {rel_path} not found in the program. Something went wrong.",
                node,
            )
            return None
        return rel_path
    else:
        # Python import
        if node.sym_name in self.prog.py_raise_map:
            return self.prog.py_raise_map[node.sym_name]

        full_path = f"{self.ir_out.get_href_path(node)}.{node.sym_name}"
        if full_path in self.prog.py_raise_map:
            return self.prog.py_raise_map[full_path]

        return None
```

This method handles:
- Resolving relative paths
- Handling directory imports
- Looking up module paths in the program's module hub
- Resolving Python import paths

### Import Style Detection

The pass distinguishes between different import styles:

```python
def _is_all_import(self, imp_node: uni.Import, node: uni.ModulePath) -> bool:
    """Determine if this is an all import (import everything from module)."""
    return (
        imp_node.is_jac and node.parent and isinstance(node.parent, uni.SubNodeList)
    ) or (imp_node.is_py and imp_node.from_loc is None and not imp_node.is_absorb)
```

This method detects whether:
- The import is a Jac "import all" statement (import module;)
- The import is a Python regular import (import module)

### Symbol List Extraction

For selective imports, the pass extracts the list of symbols to import:

```python
def _get_imported_symbols(self, node: uni.ModulePath) -> list[str]:
    """Get list of specific symbols being imported."""
    symbols = []
    if node.parent and isinstance(node.parent, uni.Import):
        for mod_items in node.parent.items:
            if isinstance(mod_items, uni.ModuleItem):
                symbols.append(mod_items.name.value)
    return symbols
```

This method builds a list of symbol names for selective imports, such as:
- from module import symbol1, symbol2; (Jac)
- from module import symbol1, symbol2 (Python)

### All Import Handling

For "all imports," the pass adds the imported module's symbol table as a child of the current module's symbol table:

```python
def _handle_all_import(
    self, node: uni.ModulePath, imported_mod_symtab: UniScopeNode
) -> None:
    """Handle an 'all import' by adding the imported symtable as a kid to the current sym table."""
    node.sym_tab.kid_scope.append(imported_mod_symtab)
```

This approach makes all symbols from the imported module accessible directly in the current module.

### Selective Import Handling

For selective imports, the pass creates an `InheritedSymbolTable` that references only the specified symbols:

```python
def _handle_selective_import(
    self,
    node: uni.ModulePath,
    imported_mod_symtab: UniScopeNode,
    symbols_str_list: list[str],
    imp_node: uni.Import,
) -> None:
    """Handle selective import of specific symbols."""
    # Check if we've already inherited from this symbol table
    for symtb in node.sym_tab.inherited_scope:
        if symtb.base_symbol_table == imported_mod_symtab:
            symtb.symbols.extend(symbols_str_list)
            return

    # If not inherited yet, add it to inherited scope
    node.sym_tab.inherited_scope.append(
        InheritedSymbolTable(
            base_symbol_table=imported_mod_symtab,
            # load_all_symbols needed for "from x import *" in Python imports
            load_all_symbols=imp_node.is_py and imp_node.is_absorb,
            symbols=symbols_str_list,
        )
    )
```

This method:
1. Checks if the current module already inherits from the imported module
2. If so, adds the new symbols to the existing inheritance
3. If not, creates a new `InheritedSymbolTable` with the specified symbols
4. Handles the special case of Python's "from x import *"

## Symbol Table Linking Flow

The overall flow of the symbol table linking process:

```mermaid
graph TD
    Start[AST with Def-Use Info] --> A[Begin SymTabLinkPass]
    A --> B{For each Import\nStatement}
    B --> C[Get Module Path]
    C --> D{Module Found?}
    D -->|No| B
    D -->|Yes| E{Is All Import?}
    E -->|Yes| F[Add Imported Symbol Table\nas Kid Scope]
    E -->|No| G[Get List of\nImported Symbols]
    G --> H[Create InheritedSymbolTable\nwith Specific Symbols]
    F --> B
    H --> B
    B -->|Done| I[Cross-Module\nSymbol Resolution\nEnabled]

    style Start fill:#2d3748,stroke:#e2e8f0,stroke-width:1px,color:#e2e8f0
    style A fill:#3182ce,stroke:#e2e8f0,stroke-width:1px,color:#e2e8f0
    style B fill:#3182ce,stroke:#e2e8f0,stroke-width:1px,color:#e2e8f0
    style C fill:#3182ce,stroke:#e2e8f0,stroke-width:1px,color:#e2e8f0
    style D fill:#805ad5,stroke:#e2e8f0,stroke-width:1px,color:#e2e8f0
    style E fill:#805ad5,stroke:#e2e8f0,stroke-width:1px,color:#e2e8f0
    style F fill:#38a169,stroke:#e2e8f0,stroke-width:1px,color:#e2e8f0
    style G fill:#38a169,stroke:#e2e8f0,stroke-width:1px,color:#e2e8f0
    style H fill:#38a169,stroke:#e2e8f0,stroke-width:1px,color:#e2e8f0
    style I fill:#3182ce,stroke:#e2e8f0,stroke-width:1px,color:#e2e8f0
```

## Cross-Module Symbol Lookup

Once the symbol tables are linked, cross-module symbol lookup works through the enhanced symbol table hierarchy:

```mermaid
flowchart TD
    Start([Start Lookup]) --> A{Symbol in\ncurrent scope?}
    A -->|Yes| ReturnSymbol([Return Symbol])
    A -->|No| B{Check inherited\nsymbol tables}
    B -->|Found| ReturnSymbol
    B -->|Not Found| C{Check kid\nsymbol tables}
    C -->|Found| ReturnSymbol
    C -->|Not Found| D{parent_scope\nexists and deep=true?}
    D -->|Yes| E[Move to parent scope]
    E --> A
    D -->|No| ReturnNone([Return None])

    style Start fill:#2d3748,stroke:#e2e8f0,stroke-width:1px,color:#e2e8f0
    style A fill:#805ad5,stroke:#e2e8f0,stroke-width:1px,color:#e2e8f0
    style B fill:#805ad5,stroke:#e2e8f0,stroke-width:1px,color:#e2e8f0
    style C fill:#805ad5,stroke:#e2e8f0,stroke-width:1px,color:#e2e8f0
    style D fill:#805ad5,stroke:#e2e8f0,stroke-width:1px,color:#e2e8f0
    style E fill:#3182ce,stroke:#e2e8f0,stroke-width:1px,color:#e2e8f0
    style ReturnSymbol fill:#38a169,stroke:#e2e8f0,stroke-width:1px,color:#e2e8f0
    style ReturnNone fill:#6b7280,stroke:#e2e8f0,stroke-width:1px,color:#e2e8f0
```

This lookup process now includes checking:
1. The current scope's `names_in_scope`
2. All inherited symbol tables through `inherited_scope`
3. All child symbol tables through `kid_scope` (for entire module imports)
4. Parent scopes recursively if `deep=True`

## The InheritedSymbolTable

The `InheritedSymbolTable` class is central to selective imports:

```python
class InheritedSymbolTable:
    """Inherited symbol table."""

    def __init__(
        self,
        base_symbol_table: UniScopeNode,
        load_all_symbols: bool = False,  # This is needed for python imports
        symbols: Optional[list[str]] = None,
    ) -> None:
        """Initialize."""
        self.base_symbol_table: UniScopeNode = base_symbol_table
        self.load_all_symbols: bool = load_all_symbols
        self.symbols: list[str] = symbols if symbols else []

    def lookup(self, name: str, deep: bool = False) -> Optional[Symbol]:
        """Lookup a variable in the symbol table."""
        if self.load_all_symbols:
            return self.base_symbol_table.lookup(name, deep)
        else:
            if name in self.symbols:
                return self.base_symbol_table.lookup(name, deep)
            else:
                return None
```

This class:
1. References the base symbol table of the imported module
2. Maintains a list of specific symbols to import
3. Provides a filtered lookup method that only returns symbols in the list
4. Supports "import all" mode through the `load_all_symbols` flag

## Example: Module Linking

Consider two Jac modules:

**math_utils.jac**:
```jac
can add(a: int, b: int) -> int {
    return a + b;
}

can subtract(a: int, b: int) -> int {
    return a - b;
}

can multiply(a: int, b: int) -> int {
    return a * b;
}
```

**main.jac**:
```jac
import math_utils with add, multiply;

can calculate(x: int, y: int) -> int {
    result = add(x, y) * multiply(x, y);
    return result;
}
```

Here's how `SymTabLinkPass` processes these modules:

1. Parse both modules and build their initial symbol tables
2. In `main.jac`, encounter `import math_utils with add, multiply;`
3. Resolve the path to `math_utils.jac`
4. Get the symbol table of `math_utils.jac`
5. Extract the imported symbols: `["add", "multiply"]`
6. Create an `InheritedSymbolTable` with:
   - `base_symbol_table` = `math_utils.jac`'s symbol table
   - `symbols` = `["add", "multiply"]`
7. Add this `InheritedSymbolTable` to `main.jac`'s `inherited_scope`

The resulting symbol table structure:

```mermaid
flowchart TD
    MathUtils["math_utils.jac SymTable
    - add: Symbol(ABILITY)
    - subtract: Symbol(ABILITY)
    - multiply: Symbol(ABILITY)"]

    MainModule["main.jac SymTable
    - calculate: Symbol(ABILITY)"]

    Calculate["calculate SymTable
    - x: Symbol(PARAM)
    - y: Symbol(PARAM)
    - result: Symbol(VAR)"]

    InheritedTable["InheritedSymbolTable
    - base_symbol_table: math_utils.jac
    - symbols: ['add', 'multiply']"]

    MainModule --> Calculate
    MainModule -.-> InheritedTable
    InheritedTable -.-> MathUtils

    style InheritedTable fill:#ffe0b2,stroke:#e65100,stroke-width:1px
```

Now when `calculate` uses `add` and `multiply`:
1. The symbols are not found in `main.jac`'s `names_in_scope`
2. They are looked up in the `InheritedSymbolTable`
3. Since they are in the `symbols` list, they are found in `math_utils.jac`'s symbol table
4. The symbols are successfully resolved, allowing cross-module usage

## Conclusion

The `SymTabLinkPass` is essential for enabling modular Jac programs by connecting symbol tables across module boundaries. This pass:

- Enables imports between modules
- Supports selective imports to control symbol visibility
- Handles different import styles in both Jac and Python
- Creates a connected symbol table structure for cross-module name resolution

Once this pass is complete, the compiler has a complete view of the program's symbol structure, enabling accurate name resolution, type checking, and code generation across module boundaries.



================================================================================
FILE: docs/internals/symbol_tables/resolution.md
================================================================================


# Symbol Resolution in Practice

After the symbol tables are built, populated with definitions, and linked across modules, the compiler uses them to resolve symbol references throughout the code. This document provides practical examples of how symbol resolution works in various scenarios.

## The Symbol Resolution Process

Symbol resolution in Jaclang involves several key steps:

```mermaid
flowchart TD
    A[Symbol Reference] --> B[Current Scope Lookup]
    B -->|Found| H[Return Symbol]
    B -->|Not Found| C[Inherited Symbol Tables Lookup]
    C -->|Found| H
    C -->|Not Found| D[Kid Scopes Lookup]
    D -->|Found| H
    D -->|Not Found| E{Deep Lookup?}
    E -->|Yes| F[Parent Scope Lookup]
    F --> B
    E -->|No| G[Symbol Not Found]

    style A fill:#2d3748,stroke:#e2e8f0,stroke-width:1px,color:#e2e8f0
    style B fill:#805ad5,stroke:#e2e8f0,stroke-width:1px,color:#e2e8f0
    style C fill:#805ad5,stroke:#e2e8f0,stroke-width:1px,color:#e2e8f0
    style D fill:#805ad5,stroke:#e2e8f0,stroke-width:1px,color:#e2e8f0
    style E fill:#805ad5,stroke:#e2e8f0,stroke-width:1px,color:#e2e8f0
    style F fill:#3182ce,stroke:#e2e8f0,stroke-width:1px,color:#e2e8f0
    style G fill:#6b7280,stroke:#e2e8f0,stroke-width:1px,color:#e2e8f0
    style H fill:#38a169,stroke:#e2e8f0,stroke-width:1px,color:#e2e8f0
```

The lookup algorithm tries to find symbols in this order:
1. In the current scope's `names_in_scope`
2. In the `inherited_scope` (from imports or inheritance)
3. In the `kid_scope` (for entire module imports)
4. In parent scopes (if `deep=True`)

## Common Resolution Scenarios

Let's examine how symbol resolution works in various common scenarios.

### Local Variable Resolution

```jac
can greeting(name: str) {
    message = "Hello, " + name + "!";
    print(message);
}
```

Resolution steps for `message` in `print(message)`:
1. Look up `message` in the `greeting` function's scope
2. Find it in `names_in_scope` as a local variable
3. Record this use of `message`

Resolution steps for `name` in `"Hello, " + name + "!"`:
1. Look up `name` in the `greeting` function's scope
2. Find it in `names_in_scope` as a parameter
3. Record this use of `name`

### Member Access Resolution

```jac
node Person {
    has name: str;

    can greet {
        print("Hello, my name is " + self.name);
    }
}
```

Resolution steps for `self.name`:
1. Look up `self` in the `greet` method's scope
2. Find it in `names_in_scope` as an implicit parameter
3. Get the symbol table associated with `self` (the `Person` archetype's symbol table)
4. Look up `name` in the `Person` symbol table
5. Find it in `names_in_scope` as a "has" variable
6. Record this use of `name`

### Cross-Module Resolution

Given these files:

**utils.jac**:
```jac
can format_name(first: str, last: str) -> str {
    return first + " " + last;
}
```

**main.jac**:
```jac
import utils;

can main {
    full_name = utils.format_name("John", "Doe");
    print(full_name);
}
```

Resolution steps for `utils.format_name`:
1. Look up `utils` in the `main` module's scope
2. Find it in `kid_scope` as an imported module (added by `SymTabLinkPass`)
3. Look up `format_name` in the `utils` module's symbol table
4. Find it in `names_in_scope` as a function
5. Record this use of `format_name`

### Selective Import Resolution

Given these files:

**math.jac**:
```jac
can add(a: int, b: int) -> int {
    return a + b;
}

can subtract(a: int, b: int) -> int {
    return a - b;
}
```

**calculator.jac**:
```jac
import math with add;

can calculate(x: int, y: int) -> int {
    return add(x, y);  // Works
    // return subtract(x, y);  // Would fail - not imported
}
```

Resolution steps for `add`:
1. Look up `add` in the `calculate` function's scope
2. Not found, continue to module scope
3. Look up `add` in the `calculator` module's scope
4. Not found in `names_in_scope`
5. Check `inherited_scope` (set up by `SymTabLinkPass`)
6. Find `add` in the `InheritedSymbolTable` that references `math`
7. Record this use of `add`

If `subtract` were uncommented, resolution would fail at step 6 since it's not in the list of imported symbols.

### Nested Scopes Resolution

```jac
can outer() {
    x = 10;

    can inner() {
        y = x + 5;  // Accessing outer scope
        return y;
    }

    return inner();
}
```

Resolution steps for `x` in `y = x + 5`:
1. Look up `x` in the `inner` function's scope
2. Not found in `names_in_scope`
3. Check parent scope (`outer` function)
4. Find `x` in `outer`'s `names_in_scope`
5. Record this use of `x`

### Object-Oriented Method Resolution

```jac
node Vehicle {
    has wheels: int = 4;

    can drive {
        print("Driving a vehicle with " + self.wheels + " wheels");
    }
}

node Car:Vehicle {
    has brand: str;

    can drive {
        super.drive();
        print("It's a " + self.brand);
    }
}
```

Resolution steps for `super.drive()` in `Car.drive`:
1. Look up `super` in the `Car.drive` method's scope
2. Find it in `names_in_scope` as an implicit variable
3. Get the symbol table associated with `super` (the `Vehicle` archetype's symbol table)
4. Look up `drive` in the `Vehicle` symbol table
5. Find it in `names_in_scope` as a method
6. Record this use of `drive`

Resolution steps for `self.brand` in `Car.drive`:
1. Look up `self` in the `Car.drive` method's scope
2. Find it in `names_in_scope` as an implicit parameter
3. Get the symbol table associated with `self` (the `Car` archetype's symbol table)
4. Look up `brand` in the `Car` symbol table
5. Find it in `names_in_scope` as a "has" variable
6. Record this use of `brand`

### Import with Alias Resolution

```jac
import utils as u;

can demo() {
    result = u.helper();
}
```

Resolution steps for `u.helper()`:
1. Look up `u` in the module scope
2. Find it in `names_in_scope` as an alias (defined through import)
3. Get the symbol table associated with `u` (the `utils` module's symbol table)
4. Look up `helper` in the `utils` symbol table
5. Find it in `names_in_scope` as a function
6. Record this use of `helper`

## Complex Resolution Scenarios

### Multi-Level Member Access

```jac
node Address {
    has city: str;
}

node Person {
    has name: str;
    has addr: Address;

    can print_city {
        print(self.addr.city);
    }
}
```

Resolution steps for `self.addr.city`:
1. Look up `self` in the `print_city` method's scope
2. Find it in `names_in_scope` as an implicit parameter
3. Get the symbol table associated with `self` (the `Person` archetype's symbol table)
4. Look up `addr` in the `Person` symbol table
5. Find it in `names_in_scope` as a "has" variable
6. Determine the type of `addr` is `Address`
7. Get the symbol table associated with `Address`
8. Look up `city` in the `Address` symbol table
9. Find it in `names_in_scope` as a "has" variable
10. Record these uses of `addr` and `city`

### Inheritance and Shadow Variables

```jac
node Base {
    has x: int = 10;

    can method {
        print(self.x);
    }
}

node Derived:Base {
    has x: int = 20;  // Shadows Base.x

    can test {
        self.method();  // Prints 20, not 10
    }
}
```

Resolution steps for `self.method()` in `test`:
1. Look up `self` in the `test` method's scope
2. Find it in `names_in_scope` as an implicit parameter
3. Get the symbol table associated with `self` (the `Derived` archetype's symbol table)
4. Look up `method` in the `Derived` symbol table
5. Not found in `names_in_scope`
6. Inherited from `Base`, find it in base class
7. Record this use of `method`

Resolution steps for `self.x` in `method` when called from `Derived`:
1. Look up `self` in the `method` method's scope
2. Find it in `names_in_scope` as an implicit parameter
3. The actual object is a `Derived` instance
4. Get the symbol table associated with `Derived`
5. Look up `x` in the `Derived` symbol table
6. Find it in `names_in_scope` as a "has" variable
7. Record this use of `x`

### Import Conflicts Resolution

**math.jac**:
```jac
can calculate(x: int) -> int {
    return x * 2;
}
```

**stats.jac**:
```jac
can calculate(x: int) -> float {
    return x / 2.0;
}
```

**main.jac**:
```jac
import math with calculate as math_calc;
import stats with calculate as stats_calc;

can test(x: int) {
    a = math_calc(x);
    b = stats_calc(x);
    return a + b;
}
```

Resolution steps for `math_calc`:
1. Look up `math_calc` in the `test` function's scope
2. Not found, continue to module scope
3. Look up `math_calc` in the `main` module's scope
4. Found in `names_in_scope` as an alias for `math.calculate`
5. The symbol points to `calculate` in the `math` module
6. Record this use of `math_calc`

Similarly for `stats_calc`, but the alias points to `calculate` in the `stats` module.

## Visualization of Symbol Resolution in a Complete Program

Let's visualize the symbol resolution for a complete program:

```jac
import utils with format_string;

node Person {
    has name: str;
    has age: int;

    can describe {
        return format_string("Name: {}, Age: {}", [self.name, self.age]);
    }
}

can create_person(name: str, age: int) -> Person {
    p = Person();
    p.name = name;
    p.age = age;
    return p;
}

can main {
    alice = create_person("Alice", 30);
    desc = alice.describe();
    print(desc);
}
```

Symbol resolution visualization:

```mermaid
flowchart TD
    Main[main.jac Module]
    Utils[utils.jac Module]

    Main --> Person[Person Archetype]
    Main --> CreatePerson[create_person Function]
    Main --> MainFunc[main Function]

    Utils --> FormatString[format_string Function]

    Person --> Name[name Has Variable]
    Person --> Age[age Has Variable]
    Person --> Describe[describe Method]

    Describe --> Self[self Parameter]
    Self -.-> Person
    Describe --> FSRef[format_string Call]
    FSRef -.-> FormatString

    CreatePerson --> NameParam[name Parameter]
    CreatePerson --> AgeParam[age Parameter]
    CreatePerson --> P[p Local Variable]
    P -.-> Person
    P --> PName[p.name Assignment]
    PName -.-> Name
    P --> PAge[p.age Assignment]
    PAge -.-> Age

    MainFunc --> Alice[alice Local Variable]
    Alice -.-> Person
    MainFunc --> CPRef[create_person Call]
    CPRef -.-> CreatePerson
    MainFunc --> Desc[desc Local Variable]
    Alice --> AliceDescribe[alice.describe Call]
    AliceDescribe -.-> Describe

    Main -.->|Imports| FormatString

    style Main fill:#e1f5fe,stroke:#0288d1,stroke-width:2px
    style Utils fill:#e1f5fe,stroke:#0288d1,stroke-width:2px
    style Person fill:#ffe0b2,stroke:#e65100,stroke-width:2px
    style CreatePerson fill:#c8e6c9,stroke:#388e3c,stroke-width:2px
    style MainFunc fill:#c8e6c9,stroke:#388e3c,stroke-width:2px
    style FormatString fill:#c8e6c9,stroke:#388e3c,stroke-width:2px
    style Describe fill:#c8e6c9,stroke:#388e3c,stroke-width:2px
```

Dotted lines represent symbol resolution links, showing how each reference is resolved to its definition.

## Conclusion

Symbol resolution is a complex but essential part of the compilation process in Jaclang. Understanding how it works in different contexts helps when:

- Debugging name resolution issues
- Implementing new language features
- Understanding how imports and inheritance interact
- Optimizing compiler performance

The combination of well-structured symbol tables and a thorough lookup algorithm ensures that symbols are correctly resolved throughout the program, enabling accurate type checking and code generation.



================================================================================
FILE: docs/internals/symbol_tables/structure.md
================================================================================


# Symbol Table Structure

Symbol tables in Jaclang are hierarchical data structures designed to track symbols (identifiers) and their relationships throughout the compilation process. This document explains the core components of the symbol table system and how they interact.

## Core Components

Jaclang's symbol table system consists of the following key classes:

```mermaid
classDiagram
    class UniScopeNode {
        +str nix_name
        +UniNode nix_owner
        +UniScopeNode parent_scope
        +list[UniScopeNode] kid_scope
        +dict[str, Symbol] names_in_scope
        +list[InheritedSymbolTable] inherited_scope
        +lookup(name, deep)
        +insert(node, access_spec, single, force_overwrite)
        +find_scope(name)
        +link_kid_scope(key_node)
        +def_insert(node, access_spec, single_decl, force_overwrite)
        +chain_def_insert(node_list)
        +use_lookup(node, sym_table)
        +chain_use_lookup(node_list)
    }

    class Symbol {
        +list[NameAtom] defn
        +list[NameAtom] uses
        +SymbolAccess access
        +UniScopeNode parent_tab
        +decl
        +sym_name
        +sym_type
        +sym_dotted_name
        +symbol_table
        +add_defn(node)
        +add_use(node)
    }

    class InheritedSymbolTable {
        +UniScopeNode base_symbol_table
        +bool load_all_symbols
        +list[str] symbols
        +lookup(name, deep)
    }

    class NameAtom {
        +str value
        +Symbol sym
        +UniNode name_of
        +sym_name
        +sym_category
    }

    UniScopeNode --> Symbol : names_in_scope
    UniScopeNode --> InheritedSymbolTable : inherited_scope
    UniScopeNode --> UniScopeNode : parent_scope/kid_scope
    Symbol --> NameAtom : defn/uses
    Symbol --> UniScopeNode : parent_tab
    InheritedSymbolTable --> UniScopeNode : base_symbol_table
    NameAtom --> Symbol : sym
```

### UniScopeNode

`UniScopeNode` represents a scope in the program, such as a module, function, class, or block. Each scope has its own symbol table containing the symbols defined within it.

Key attributes:
- `nix_name`: Name of the scope
- `nix_owner`: The AST node this scope belongs to
- `parent_scope`: Reference to the parent scope
- `kid_scope`: List of child scopes
- `names_in_scope`: Dictionary mapping symbol names to their `Symbol` objects
- `inherited_scope`: List of inherited symbol tables

Key methods:
- `lookup(name, deep)`: Looks up a symbol by name, optionally searching parent scopes
- `insert(node, access_spec, single, force_overwrite)`: Inserts a symbol into the scope
- `find_scope(name)`: Finds a child scope by name
- `link_kid_scope(key_node)`: Links a child scope to this scope
- `def_insert(node, access_spec, single_decl, force_overwrite)`: Inserts a symbol definition
- `chain_def_insert(node_list)`: Inserts a chain of symbols (e.g., for member access)
- `use_lookup(node, sym_table)`: Looks up a symbol use
- `chain_use_lookup(node_list)`: Looks up a chain of symbol uses

### Symbol

`Symbol` represents a symbol definition in the program, keeping track of all definitions and uses of the symbol.

Key attributes:
- `defn`: List of definition name atoms
- `uses`: List of use name atoms
- `access`: Access level of the symbol (public, private, etc.)
- `parent_tab`: The symbol table this symbol belongs to

Key properties:
- `decl`: The first definition of the symbol
- `sym_name`: The name of the symbol
- `sym_type`: The type of the symbol (var, function, class, etc.)
- `sym_dotted_name`: The fully qualified name of the symbol (including module path)
- `symbol_table`: The symbol table associated with this symbol (if applicable)

### InheritedSymbolTable

`InheritedSymbolTable` represents a symbol table that is inherited from another scope, such as when importing symbols from a module.

Key attributes:
- `base_symbol_table`: The base symbol table being inherited from
- `load_all_symbols`: Whether all symbols should be loaded (e.g., for "import *")
- `symbols`: List of specific symbols to inherit

Key methods:
- `lookup(name, deep)`: Looks up a symbol by name, respecting symbol filtering

### NameAtom

`NameAtom` represents a named reference in the code, which can be either a definition or a use of a symbol.

Key attributes:
- `value`: The actual name string
- `sym`: Reference to the associated Symbol object
- `name_of`: The AST node this name belongs to
- `sym_name`: The name of the symbol
- `sym_category`: The category of the symbol (variable, function, class, etc.)

## Symbol Table Hierarchy

Symbol tables are organized hierarchically to reflect the scope structure of the program:

```mermaid
graph TD
    Module["Module SymTable"] --> GlobalScope["Global Scope"]
    Module --> Archetype1["Archetype SymTable"]
    Module --> Archetype2["Archetype SymTable"]
    Module --> Function["Function SymTable"]
    Archetype1 --> Method1["Method SymTable"]
    Archetype1 --> Method2["Method SymTable"]
    Function --> Block["Block SymTable"]
    Block --> IfBlock["If Block SymTable"]
    Block --> ForLoop["For Loop SymTable"]

    style Module fill:#3182ce,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style GlobalScope fill:#4fd1c5,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style Archetype1 fill:#805ad5,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style Archetype2 fill:#805ad5,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style Function fill:#38a169,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style Method1 fill:#4fd1c5,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style Method2 fill:#4fd1c5,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style Block fill:#4fd1c5,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style IfBlock fill:#6b7280,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style ForLoop fill:#6b7280,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
```

- The module symbol table is at the top level
- Each archetype (object, node, edge, walker) has its own symbol table
- Functions, methods, and blocks have their own nested symbol tables
- Control structures like if statements and loops have their own symbol tables

## Symbol Lookup Process

When looking up a symbol by name, the process follows these steps:

```mermaid
flowchart TD
    Start([Start Lookup]) --> A{Symbol in\ncurrent scope?}
    A -->|Yes| ReturnSymbol([Return Symbol])
    A -->|No| B{Check inherited\nsymbol tables}
    B -->|Found| ReturnSymbol
    B -->|Not Found| C{parent_scope\nexists and deep=true?}
    C -->|Yes| D[Move to parent scope]
    D --> A
    C -->|No| ReturnNone([Return None])

    style Start fill:#2d3748,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style A fill:#805ad5,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style B fill:#805ad5,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style C fill:#805ad5,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style D fill:#3182ce,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style ReturnSymbol fill:#38a169,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style ReturnNone fill:#f56565,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
```

1. Check if the symbol exists in the current scope's `names_in_scope`
2. If not, check all inherited symbol tables through `inherited_scope`
3. If still not found and `deep=True`, recursively check the parent scope
4. If no symbol is found, return `None`

## Symbol Access Levels

Jaclang supports different access levels for symbols:

```python
class SymbolAccess(IntEnum):
    """Symbol access."""

    EXTERNAL = -1  # Used for builtins
    PUBLIC = 0
    PRIVATE = 1
    PROTECTED = 2
```

Access levels determine visibility of symbols across scopes and are used for enforcing access control in the language.

## Symbol Types

Symbols are categorized into different types using the `SymbolType` enum:

```python
class SymbolType(IntEnum):
    """Symbol type."""

    VAR = 0
    GLOBAL = 1
    HAS = 2
    PARAM = 3
    Archetype = 4
    ABILITY = 5
    ENUM = 6
    ENUM_VAL = 7
    MODULE = 8
    IMPORT = 9
```

This categorization helps the compiler understand the role and behavior of different symbols during compilation.

## Practical Example

Consider the following Jac code:

```jac
node Person {
    has name: str, age: int;

    can greet {
        print("Hello, my name is " + self.name);
    }
}

walker PersonVisitor {
    can visit_person(p: Person) {
        p.greet();
    }
}
```

The symbol table structure would look like:

```mermaid
flowchart TD
    ModuleTable["Module SymTable
    - Person: Symbol(Archetype)
    - PersonVisitor: Symbol(Archetype)"]

    ModuleTable --> PersonTable["Person SymTable
    - name: Symbol(HAS)
    - age: Symbol(HAS)
    - greet: Symbol(ABILITY)"]

    ModuleTable --> VisitorTable["PersonVisitor SymTable
    - visit_person: Symbol(ABILITY)"]

    PersonTable --> GreetTable["greet SymTable
    - self: Symbol(PARAM)"]

    VisitorTable --> VisitTable["visit_person SymTable
    - p: Symbol(PARAM)"]

    style ModuleTable fill:#3182ce,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style PersonTable fill:#805ad5,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style VisitorTable fill:#805ad5,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style GreetTable fill:#4fd1c5,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
    style VisitTable fill:#4fd1c5,stroke:#e2e8f0,stroke-width:2px,color:#e2e8f0
```

Each symbol in the tables would contain:
- References to its definitions
- References to all uses throughout the code
- Information about its type and access level
- Links to its parent symbol table

This hierarchical structure enables efficient name resolution, type checking, and code generation during compilation.



================================================================================
FILE: docs/jac_book/chapter_1.md
================================================================================


# **1. Introduction to Jac**
---
This chapter gets you started with the Jac programming language. We will begin by explaining what Jac is and how it works, then walk you through how to model relationships in your code. Along the way, you'll learn about Jac's core concepts through practical examples.


> Jac introduces Object-Spatial Programming (OSP), a new way of thinking about software where computation can move to your data. This allows you to build applications that can be easily scaled and distributed.

## **What is Jac and Why It Exists**
---
Jac was created to better handle the interconnected, graph-like data structures found in many modern applications, such as social networks, knowledge graphs, and AI workflows. While traditional programming languages treat relationships as secondary concerns, Jac makes them first-class citizens.

<br/>
### **Traditional Approach to Modelling Relationships**

In many programming languages, you can model relationships using structures like functions, classes, or pointers.

Let's look at how you might build a simple social network in Python. First, you would define a `Person` class. This class might include a list of other `Person` objects to represent friendships.


```python
class Person:
    def __init__(self, name):
        self.name = name
        self.friends = []

    def add_friend(self, friend):
        self.friends.append(friend)
        friend.friends.append(self)
```
<br/>

Since a friendship is a two-way connection, you need to make sure that when one person adds a friend, the new friend is also updated. This requires extra logic in your code.

```python
# Create people and relationships
alice = Person("Alice")
bob = Person("Bob")
charlie = Person("Charlie")

# Establish relationships
alice.add_friend(bob)
bob.add_friend(alice)  # This is redundant but necessary in Python
bob.add_friend(charlie)
charlie.add_friend(bob)  # Again, redundant but necessary
```
<br/>

### **Modelling Relationships Naturally**

Now, let's see how you can define the same relationships in Jac.

First, we will define a `Person` node and a `FriendsWith` edge. In Jac, nodes are like objects that hold data. The edge defines the type of relationship between two nodes.


```jac
node Person {
    has name: str;
}

edge FriendsWith;
```
<br/>

In the code above, we define a `Person` node with a `name` attribute and a `FriendsWith` edge. Now, you can create people and establish friendships between them in a much more natural way.


```jac
# Create people
alice = root ++> Person(name="Alice");
bob = root ++> Person(name="Bob");
charlie = root ++> Person(name="Charlie");

# Create relationships naturally
alice <+:FriendsWith:+> bob;
bob <+:FriendsWith:+> charlie;
```
<br/>

The line alice `<+:FriendsWith:+> bob;` creates a `FriendsWith` relationship, which is a typed connection between the two nodes. This is one of Jac's core features.


## **Object-Spatial Programming Paradigm Overview**
---
Object-Spatial Programming (OSP) is built on three fundamental concepts:

- **Nodes**: Stateful entities that hold data
- **Edges**: Typed relationships between nodes
- **Walkers**: Mobile computation that traverses the graph

### **Nodes: Data with Location**

Nodes are like objects that have a specific location within a graph structure.

```jac
node User {
    has username: str;
    has email: str;
    has created_at: str;
}

node Post {
    has title: str;
    has content: str;
    has likes: int = 0;
}

with entry {
    # This is where your program starts.
    # We will create the nodes in the graph here.
    user = root ++> User(
        username="alice",
        email="alice@example.com",
        created_at="2024-01-01"
    );

    post = user ++> Post(
        title="Hello Jac!",
        content="My first post in Jac"
    );

    print(f"User {user[0].username} created post: {post[0].title}");
}
```
<br/>

### **Edges: First-Class Relationships**

In Jac, edges are used to create typed connections between your nodes. Think of them as the lines that connect the dots in your data's structure.

```jac
node Person {
    has name: str;
    has age: int;
}

edge FamilyRelation {
    # Edges can also have properties
    has relationship_type: str;
}

with entry {
    # First, let's create our family members as nodes
    parent = root ++> Person(name="John", age=45);
    child1 = root ++> Person(name="Alice", age=20);
    child2 = root ++> Person(name="Bob", age=18);

    # Now, let's create the relationships between them
    parent +>:FamilyRelation(relationship_type="parent"):+> child1;
    parent +>:FamilyRelation(relationship_type="parent"):+> child2;
    child1 +>:FamilyRelation(relationship_type="sibling"):+> child2;

     # You can now ask questions about these relationships
    children = [parent[0]->:FamilyRelation:relationship_type=="parent":->(`?Person)];

    print(f"{parent[0].name} has {len(children)} children:");
    for child in children {
        print(f"  - {child.name} (age {child.age})");
    }
}
```
<br/>


### **Walkers: Mobile Computation**

Walkers are one of Jac's most interesting features. They are like little workers that you can program to travel through your graph of nodes and edges to perform tasks.
Next, we'll create a `walker` that can travel through our friend network and greet each person. Add the following `walker` definition to your code.

```jac
node Person {
    has name: str;
    has visited: bool = False;  # To keep track of who we've greeted
}

edge FriendsWith;

# This walker will greet every person it meets
walker GreetFriends {
    can greet with Person entry {
        if not here.visited {
            here.visited = True;
            print(f"Hello, {here.name}!");

            # Now, tell the walker to go to all connected friends
            visit [->:FriendsWith:->];
        }
    }
}

with entry {
    # Create friend network
    alice = root ++> Person(name="Alice");
    bob = root ++> Person(name="Bob");
    charlie = root ++> Person(name="Charlie");

    # Connect friends
    alice +>:FriendsWith:+> bob +>:FriendsWith:+> charlie;
    alice +>:FriendsWith:+> charlie;  # Alice also friends with Charlie

    # Start the walker on the 'alice' node to greet everyone
    alice[0] spawn GreetFriends();
}
```
<br/>

To make the walker visit a person's friends, we use the `visit` statement. It tells the walker to travel across any outgoing FriendsWith edges.

## Scale-Agnostic Programming Concept
---
One of the key benefits of Jac is that you can write your code once and have it work for a single user or for millions of users. Your code can run on a single computer or on a large, distributed system without any changes.


> The same Jac code works whether you have 1 user or 1 million users, running on a single machine or distributed across the globe.

### **Automatic Persistence**
Jac automatically saves any data that is connected to the graph's root node. This means you don't have to worry about setting up or managing a database. You can focus on what your application does, not on how it stores data.

Here is an example of a simple counter. When you run this on a Jac server, the count will be saved automatically.

```jac
node Counter {
    has count: int = 0;

    def increment() -> None;
}

impl Counter.increment {
    self.count += 1;
    print(f"Counter is now: {self.count}");
}

with entry {
    # Get or create counter
    counters = [root-->(`?Counter)];
    if not counters {
        counter = root ++> Counter();
        print("Created new counter");
    }

    # Increment and save automatically
    counter[0].increment();
}
```
<br/>

To see the automatic persistence for yourself, you can run the counter code on a Jac server. The server turns your Jac program into an API, and it handles saving the data in your graph between runs.
First, save the counter code into a file named "counter.jac". Then, run the following command in your terminal:

```jac
jac serve counter.jac
```

### **Multi-User Isolation**

When your Jac application is running on a server, Jac automatically gives each user their own isolated graph. This means you don't have to write any special code to keep one user's data separate from another's; it's handled for you. The root node in your code always refers to the graph of the current user.

```jac
node UserProfile {
    has username: str;
    has bio: str = "";
}

walker GetProfile {
    can get_user_info with entry {
         # 'root' automatically points to the current user's graph
        profiles = [root-->(`?UserProfile)];
        if profiles {
            profile = profiles[0];
            print(f"Profile: {profile.username}");
            print(f"Bio: {profile.bio}");
        } else {
            print("No profile found");
        }
    }
}

walker CreateProfile {
    has username: str;
    has bio: str;

    can create with entry {
        # It looks for the profile connected to the current user's root
        profile = root ++> UserProfile(
            username=self.username,
            bio=self.bio
        );
        print(f"Created profile for {profile[0].username}");
    }
}

with entry {
    # This code works for any user automatically
    CreateProfile(username="alice", bio="Jac developer") spawn root;
    GetProfile() spawn root;
}
```
<br/>

In a live application, one user might call `CreateProfile` to set up their information. When another user calls `GetProfile`, they will only see their own profile, not anyone else's.

## Comparison with Python and Traditional Languages
---

If you have experience with Python, you'll find Jac's syntax easy to learn. Core programming concepts like variables, functions, and control flow work in a very similar way.

### **Syntax Familiarity**

For example, take a look at how you define and use functions and if/else statements in Jac.

```jac
# Variables and functions work similarly
def calculate_average(numbers: list[float]) -> float {
    if len(numbers) == 0 {
        return 0.0;
    }
    return sum(numbers) / len(numbers);
}

with entry {
    scores = [85.5, 92.0, 78.5, 96.0, 88.5];
    avg = calculate_average(scores);
    print(f"Average score: {avg}");

    # Control flow is familiar
    if avg >= 90.0 {
        print("Excellent performance!");
    } elif avg >= 80.0 {
        print("Good performance!");
    } else {
        print("Needs improvement.");
    }
}
```
This familiar foundation makes it easier for you to get started and begin building with Jac's unique features like nodes, edges, and walkers.
<br/>


### Key Differences

| Aspect | Python | Jac |
|--------|--------|-----|
| **Relationships** | Manual references | First-class edges |
| **Persistence** | External database | Automatic |
| **Multi-user** | Manual session management | Built-in isolation |
| **Distribution** | Complex setup | Transparent |
| **Graph Operations** | Manual traversal | Spatial queries |
| **Type System** | Optional hints | Mandatory annotations |

## Simple Friend Network Example
---

Let's walk through building a complete friend network from scratch. This will show you how Jac's core conceptsâ€”nodes, edges, and walkersâ€”work together in a practical example.

### Step 1: Define Your Nodes and Edges
First, we need to define the structure of our data. We'll create a `Person` node to hold information about each individual and a `FriendsWith` edge to represent their relationships.

```jac
node Person {
    has name: str;
    has age: int;
    has interests: list[str] = [];
}

edge FriendsWith {
    has since: str;
    has closeness: int;  # 1-10 scale
}
```
<br/>

### Step 2: Create the People and Their Connections

Now that we have our blueprints, let's create a few people and connect them as friends. Notice how we can add data directly to the `FriendsWith` edge when we create it.

```jac
# Create friend network
alice = root ++> Person(
    name="Alice",
    age=25,
    interests=["coding", "music", "hiking"]
);

bob = root ++> Person(
    name="Bob",
    age=27,
    interests=["music", "sports", "cooking"]
);

charlie = root ++> Person(
    name="Charlie",
    age=24,
    interests=["coding", "gaming", "music"]
);

# Create friendships with metadata
alice +>:FriendsWith(since="2020-01-15", closeness=8):+> bob;
alice +>:FriendsWith(since="2021-06-10", closeness=9):+> charlie;
bob +>:FriendsWith(since="2020-12-03", closeness=7):+> charlie;
```
<br/>

### Step 3: Create a Walker to Find Common Interests

Next, we need a way to analyze our network. Let's create a `walker` that can travel between friends and find out what interests they have in common.

```jac
walker FindCommonInterests {
    # The walker needs to know who we're comparing against.
    has target_person: Person;
    # It will store the results of its search here.
    has common_interests: list[str] = [];

    # This ability runs automatically whenever the walker lands on a Person node.
    can find_common with Person entry {
        # We don't want to compare the person with themselves.
        if here == self.target_person {
            return;  # Skip self
        }

        # Find any interests this person shares with our target_person
        shared = [];
        for interest in here.interests {
            if interest in self.target_person.interests {
                shared.append(interest);
            }
        }

        # If we found any, print them and add them to our list.
        if shared {
            self.common_interests.extend(shared);
            print(f"{here.name} and {self.target_person.name} both like: {', '.join(shared)}");
        }
    }
}
```
<br/>

To use this walker, we'll give it a `target_person` (like Alice) and then "spawn" it on her friends' nodes. As the walker visits each friend, its `find_common ability` will trigger, comparing interests and printing the results.


### Step 4: Bring It All Together
Finally, let's update our `with entry` block to use the walker and analyze the network we created. We'll start by finding all of Alice's friends and then send our walker to visit them.

<div class="code-block">
```jac
node Person {
    has name: str;
    has age: int;
    has interests: list[str] = [];
}

edge FriendsWith {
    has since: str;
    has closeness: int;  # 1-10 scale
}

walker FindCommonInterests {
    has target_person: Person;
    has common_interests: list[str] = [];

    can find_common with Person entry {
        if here == self.target_person {
            return;  # Skip self
        }

        # Find shared interests
        shared = [];
        for interest in here.interests {
            if interest in self.target_person.interests {
                shared.append(interest);
            }
        }

        if shared {
            self.common_interests.extend(shared);
            print(f"{here.name} and {self.target_person.name} both like: {', '.join(shared)}");
        }
    }
}

with entry {
    # Create friend network
    alice = root ++> Person(
        name="Alice",
        age=25,
        interests=["coding", "music", "hiking"]
    );

    bob = root ++> Person(
        name="Bob",
        age=27,
        interests=["music", "sports", "cooking"]
    );

    charlie = root ++> Person(
        name="Charlie",
        age=24,
        interests=["coding", "gaming", "music"]
    );

    # Create friendships with metadata
    alice +>:FriendsWith(since="2020-01-15", closeness=8):+> bob;
    alice +>:FriendsWith(since="2021-06-10", closeness=9):+> charlie;
    bob +>:FriendsWith(since="2020-12-03", closeness=7):+> charlie;

    print("=== Friend Network Analysis ===");

    # 1. Find all nodes connected to Alice by a FriendsWith edge
    alice_friends = [alice[0]->:FriendsWith:->(`?Person)];
    print(f"Alice's friends: {[f.name for f in alice_friends]}");

    # 2. Create an instance of our walker, telling it to compare against Alice
    finder = FindCommonInterests(target_person=alice[0]);

    # 3. Send the walker to visit each of Alice's friends
    for friend in alice_friends {
        friend spawn finder;
    }

    # Find close friendships (closeness >= 8)
    close_friendships = [root-->->:FriendsWith:closeness >= 8:->];
    print(f"Close friendships ({len(close_friendships)} found):");
}
```
</div>

<br/>

This example shows how you can model complex relationships and then create walkers to navigate and analyze them using Jac's Object-Spatial Programming model. The walker moves through the graph, performing actions based on the data it finds, all in a way that is clear and easy to understand.


## Key Takeaways

Hereâ€™s a quick summary of what youâ€™ve learned in this chapter.

---
**Core Concepts:**

- **Object-Spatial Programming (OSP)**: This is the core idea behind Jac. It means you can move your code (computation) to your data using a combination of nodes, edges, and walkers.
- **Nodes**: These are the primary objects in your program that hold your data.
- **Edges**: These are the connections that define the relationships between your nodes.
- **Walkers**: These are small, mobile programs you create to travel through your network of nodes and edges to perform tasks.

**Key Advantages:**

- **Write Code That Scales**: Your Jac code works automatically for a single user or for millions, running on one machine or a distributed system, without needing changes.
- **No Database Headaches**: Jac automatically saves the data in your graph, so you don't have to set up or manage a database yourself.
- **Model Relationships Naturally: Working with connected data feels intuitive and straightforward because of the graph-based approach.
- **Built-in User Separation**: Jac automatically keeps each user's data separate, so you don't have to build complex logic to manage user sessions.
- **Familiar Python-like Syntax**: Jac is easy to learn for Python developers, letting you focus on its powerful new features right away.


Start thinking about problems that involve connected data, as these are the areas where Jac truly excels:
- Social networks and user connections
- Knowledge graphs and information relationships
- Workflow systems and process connections
- Data pipelines and transformation chains

!!! Note
    Remember: Jac shines when your problem naturally involves connected data!

---

*Ready to start your Object-Spatial Programming journey? Let's get to know Variables, Types, and Basic Syntax next!*




================================================================================
FILE: docs/jac_book/chapter_10.md
================================================================================


# Chapter 10: Walkers and Abilities

In the previous chapters, you learned how to build the static structure of your application using nodes and edges. Now, you will learn how to put that structure into motion. The primary way you interact with and process your graph is by using walkers.

!!! topic "Mobile Computation Philosophy"
    Walkers introduce a fundamental shift from traditional programming. This is the core philosophy of Object-Spatial Programming.
    - In traditional programming, you write a function and then bring data to your code to be processed.
    - In Jac, you create a walker and send your code to your data.
    This model of "mobile computation" is incredibly effective for working with the complex, interconnected data found in AI and other modern systems.

## Walker Creation

!!! topic "What are Walkers?"
    Walkers are special objects that can move through your graph, carrying state and executing abilities when they encounter different types of nodes and edges.

### Basic Walker Declaration

A walker is defined with the walker archetype. Like an obj, it can have has attributes to store data and def methods for internal logic. At this stage, a walker is just an object; it doesn't move or interact with the graph until it is "spawned."

!!! example "Simple Walker"
    === "Jac"
        <div class="code-block">
        ```jac
        # Simple walker for visiting nodes
        walker MessageDelivery {
            has message: str;
            has delivery_count: int = 0;
            has visited_locations: list[str] = [];

            # Regular methods work like normal
            def get_status() -> str {
                return f"Delivered {self.delivery_count} messages to {len(self.visited_locations)} locations";
            }
        }

        with entry {
            # Create walker instance (but don't activate it yet)
            messenger = MessageDelivery(message="Hello from the principal!");

            # Check initial state
            print(f"Initial status: {messenger.get_status()}");
        }
        ```
        </div>
    === "Python"
        ```python
        class MessageDelivery:
            def __init__(self, message: str):
                self.message = message
                self.delivery_count = 0
                self.visited_locations = []

            def get_status(self) -> str:
                return f"Delivered {self.delivery_count} messages to {len(self.visited_locations)} locations"

        class Student:
            def __init__(self, name: str):
                self.name = name
                self.messages = []

        class Teacher:
            def __init__(self, name: str, subject: str):
                self.name = name
                self.subject = subject

        if __name__ == "__main__":
            # Create messenger instance
            messenger = MessageDelivery(message="Hello from the principal!")

            # Check initial state
            print(f"Initial status: {messenger.get_status()}")
        ```

## Ability Definitions and Triggers

!!! topic "Event-Driven Execution"
    Abilities are methods that execute automatically when certain events occur during graph traversal. They create reactive, context-aware behavior.

### Entry and Exit Abilities

The most common abilities are entry and exit abilities.
- An `entry` ability triggers when a walker arrives at a node or edge.
- An `exit` ability triggers when a walker leaves a node or edge.

You can create specialized entry abilities that only trigger for specific node or edge types.

!!! example "Basic Abilities"
    === "Jac"
        <div class="code-block">
        ```jac
        # Basic classroom nodes
        node Student {
            has name: str;
            has messages: list[str] = [];
        }

        node Teacher {
            has name: str;
            has subject: str;
        }

        walker MessageDelivery {
            has message: str;
            has delivery_count: int = 0;
            has visited_locations: list[str] = [];

            # Entry ability - triggered when entering any Student
            can deliver_to_student with Student entry {
                print(f"Delivering message to student {here.name}");
                here.messages.append(self.message);
                self.delivery_count += 1;
                self.visited_locations.append(here.name);
            }

            # Entry ability - triggered when entering any Teacher
            can deliver_to_teacher with Teacher entry {
                print(f"Delivering message to teacher {here.name} ({here.subject})");
                # Teachers just acknowledge the message
                print(f"  {here.name} says: 'Message received!'");
                self.delivery_count += 1;
                self.visited_locations.append(here.name);
            }

            # Exit ability - triggered when leaving any node
            can log_visit with entry {
                node_type = type(here).__name__;
                print(f"  Visited {node_type}");
            }
        }

        with entry {
            # Create simple classroom
            alice = root ++> Student(name="Alice");
            bob = root ++> Student(name="Bob");
            ms_smith = root ++> Teacher(name="Ms. Smith", subject="Math");

            # Create and activate messenger
            messenger = MessageDelivery(message="School assembly at 2 PM");

            # Spawn walker on Alice - this activates it
            alice[0] spawn messenger;

            # Check Alice's messages
            print(f"Alice's messages: {alice[0].messages}");
        }
        ```
        </div>
    === "Python"
        ```python
        class MessageDelivery:
            def __init__(self, message: str):
                self.message = message
                self.delivery_count = 0
                self.visited_locations = []

            def deliver_to_student(self, student):
                print(f"Delivering message to student {student.name}")
                student.messages.append(self.message)
                self.delivery_count += 1
                self.visited_locations.append(student.name)

            def deliver_to_teacher(self, teacher):
                print(f"Delivering message to teacher {teacher.name} ({teacher.subject})")
                print(f"  {teacher.name} says: 'Message received!'")
                self.delivery_count += 1
                self.visited_locations.append(teacher.name)

            def visit_node(self, node):
                node_type = type(node).__name__
                print(f"  Visited {node_type}")

                # Manually check type and call appropriate method
                if isinstance(node, Student):
                    self.deliver_to_student(node)
                elif isinstance(node, Teacher):
                    self.deliver_to_teacher(node)

        if __name__ == "__main__":
            # Create simple classroom
            alice = Student("Alice")
            bob = Student("Bob")
            ms_smith = Teacher("Ms. Smith", "Math")

            # Create and use messenger manually
            messenger = MessageDelivery("School assembly at 2 PM")

            # Manually visit nodes (simulating walker spawn)
            messenger.visit_node(alice)

            # Check Alice's messages
            print(f"Alice's messages: {alice.messages}")
        ```

## Walker Spawn and Visit

!!! topic "Graph Traversal"
    Walkers move through graphs using `spawn` (to start) and `visit` (to continue to connected nodes). This enables complex traversal patterns with simple syntax.

### Basic Traversal Patterns

!!! example "Classroom Message Delivery"
    === "Jac"
        <div class="code-block">
        ```jac
        # Basic classroom nodes
        node Student {
            has name: str;
            has messages: list[str] = [];
        }

        node Teacher {
            has name: str;
            has subject: str;
        }

        walker MessageDelivery {
            has message: str;
            has delivery_count: int = 0;
            has visited_locations: list[str] = [];

            # Entry ability - triggered when entering any Student
            can deliver_to_student with Student entry {
                print(f"Delivering message to student {here.name}");
                here.messages.append(self.message);
                self.delivery_count += 1;
                self.visited_locations.append(here.name);
            }

            # Entry ability - triggered when entering any Teacher
            can deliver_to_teacher with Teacher entry {
                print(f"Delivering message to teacher {here.name} ({here.subject})");
                # Teachers just acknowledge the message
                print(f"  {here.name} says: 'Message received!'");
                self.delivery_count += 1;
                self.visited_locations.append(here.name);
            }

            # Exit ability - triggered when leaving any node
            can log_visit with entry {
                node_type = type(here).__name__;
                print(f"  Visited {node_type}");
            }
        }

        edge InClass {
            has room: str;
        }

        walker ClassroomMessenger {
            has announcement: str;
            has rooms_visited: set[str] = {};
            has people_reached: int = 0;

            can deliver_student with Student entry {
                print(f" Student {here.name}: {self.announcement}");
                self.people_reached += 1;

                # Continue to connected nodes
                visit [-->];
            }

            can deliver_teacher with Teacher entry {
                print(f" Teacher {here.name}: {self.announcement}");
                self.people_reached += 1;

                # Continue to connected nodes
                visit [-->];
            }

            can track_room with InClass entry {
                room = here.room;
                if room not in self.rooms_visited {
                    self.rooms_visited.add(room);
                    print(f" Now in {room}");
                }
            }

            can summarize with Student exit {
                # Only report once at the end
                if len([-->]) == 0 {  # At a node with no outgoing connections
                    print(f" Delivery complete!");
                    print(f"   People reached: {self.people_reached}");
                    print(f"   Rooms visited: {list(self.rooms_visited)}");
                }
            }
        }

        with entry {
            # Create classroom structure
            alice = root ++> Student(name="Alice");
            bob = root ++> Student(name="Bob");
            charlie = root ++> Student(name="Charlie");
            ms_jones = root ++> Teacher(name="Ms. Jones", subject="Science");

            # Connect them in the same classroom
            alice +>:InClass(room="Room 101"):+> bob;
            bob +>:InClass(room="Room 101"):+> charlie;
            charlie +>:InClass(room="Room 101"):+> ms_jones;

            # Send a message through the classroom
            messenger = ClassroomMessenger(announcement="Fire drill in 5 minutes");
            alice[0] spawn messenger;
        }
        ```
        </div>
    === "Python"
        ```python
        class InClass:
            def __init__(self, from_node, to_node, room: str):
                self.from_node = from_node
                self.to_node = to_node
                self.room = room

        class ClassroomMessenger:
            def __init__(self, announcement: str):
                self.announcement = announcement
                self.rooms_visited = set()
                self.people_reached = 0
                self.visited_nodes = set()

            def deliver_to_student(self, student):
                print(f" Student {student.name}: {self.announcement}")
                self.people_reached += 1

            def deliver_to_teacher(self, teacher):
                print(f" Teacher {teacher.name}: {self.announcement}")
                self.people_reached += 1

            def track_room(self, edge):
                if edge.room not in self.rooms_visited:
                    self.rooms_visited.add(edge.room)
                    print(f"   Now in {edge.room}")

            def visit_network(self, node, connections):
                # Avoid infinite loops
                if node in self.visited_nodes:
                    return

                self.visited_nodes.add(node)

                # Process current node
                if isinstance(node, Student):
                    self.deliver_to_student(node)
                elif isinstance(node, Teacher):
                    self.deliver_to_teacher(node)

                # Visit connected nodes
                for edge in connections.get(node, []):
                    self.track_room(edge)
                    self.visit_network(edge.to_node, connections)

                # Check if we're at the end
                if not connections.get(node, []):
                    print(f" Delivery complete!")
                    print(f"   People reached: {self.people_reached}")
                    print(f"   Rooms visited: {list(self.rooms_visited)}")

        if __name__ == "__main__":
            # Create classroom structure
            alice = Student("Alice")
            bob = Student("Bob")
            charlie = Student("Charlie")
            ms_jones = Teacher("Ms. Jones", "Science")

            # Create connections manually
            connections = {
                alice: [InClass(alice, bob, "Room 101")],
                bob: [InClass(bob, charlie, "Room 101")],
                charlie: [InClass(charlie, ms_jones, "Room 101")],
                ms_jones: []
            }

            # Send message through classroom
            messenger = ClassroomMessenger("Fire drill in 5 minutes")
            messenger.visit_network(alice, connections)
        ```

### Advanced Traversal Control

!!! example "Selective Message Delivery"
    === "Jac"
        <div class="code-block">
        ```jac
        import random;

        node Student {
            has name: str;
            has grade_level: int;
            has messages: list[str] = [];
        }

        edge StudyGroup {
            has subject: str;
        }

        walker AttendanceChecker {
            has present_students: list[str] = [];
            has absent_students: list[str] = [];
            has max_checks: int = 5;
            has checks_done: int = 0;

            can check_attendance with Student entry {
                self.checks_done += 1;

                # Simulate checking if student is present (random for demo)
                is_present = random.choice([True, False]);

                if is_present {
                    print(f"{here.name} is present");
                    self.present_students.append(here.name);
                } else {
                    print(f"{here.name} is absent");
                    self.absent_students.append(here.name);
                }

                # Control flow based on conditions
                if self.checks_done >= self.max_checks {
                    print(f"Reached maximum checks ({self.max_checks})");
                    self.report_final();
                    disengage;  # Stop the walker
                }

                # Skip if no more connections
                connections = [-->];
                if not connections {
                    print("No more students to check");
                    self.report_final();
                    disengage;
                }

                # Continue to next student
                visit [-->];
            }

            def report_final() -> None {
                print(f" Attendance Report:");
                print(f"   Present: {self.present_students}");
                print(f"   Absent: {self.absent_students}");
                print(f"   Total checked: {self.checks_done}");
            }
        }

        with entry {
            # Create a chain of students
            alice = root ++> Student(name="Alice", grade_level=9);
            bob = alice ++> Student(name="Bob", grade_level=9);
            charlie = bob ++> Student(name="Charlie", grade_level=9);
            diana = charlie ++> Student(name="Diana", grade_level=9);
            eve = diana ++> Student(name="Eve", grade_level=9);

            # Start attendance check
            checker = AttendanceChecker(max_checks=3);
            alice[0] spawn checker;
        }
        ```
        </div>
    === "Python"
        ```python
        class StudyGroup:
            def __init__(self, from_node, to_node, subject: str):
                self.from_node = from_node
                self.to_node = to_node
                self.subject = subject

        class Student:
            def __init__(self, name: str, grade_level: int):
                self.name = name
                self.grade_level = grade_level
                self.messages = []

        class GradeSpecificMessenger:
            def __init__(self, message: str, target_grade: int):
                self.message = message
                self.target_grade = target_grade
                self.delivered_to = []
                self.visited = set()

            def visit_student(self, student, connections):
                if student in self.visited:
                    return

                self.visited.add(student)

                if student.grade_level == self.target_grade:
                    print(f"Delivering to {student.name} (Grade {student.grade_level}): {self.message}")
                    student.messages.append(self.message)
                    self.delivered_to.append(student.name)
                else:
                    print(f"Skipping {student.name} (Grade {student.grade_level}) - not target grade")

                # Visit connected students
                for edge in connections.get(student, []):
                    print(f"  Moving through {edge.subject} study group")
                    self.visit_student(edge.to_node, connections)

                # Report if at end
                if not connections.get(student, []):
                    print(f" Delivery Summary:")
                    print(f"   Target: Grade {self.target_grade} students")
                    print(f"   Message: '{self.message}'")
                    print(f"   Delivered to: {self.delivered_to}")

        if __name__ == "__main__":
            # Create multi-grade study network
            alice = Student("Alice", 9)
            bob = Student("Bob", 10)
            charlie = Student("Charlie", 9)
            diana = Student("Diana", 11)

            # Create connections
            connections = {
                alice: [StudyGroup(alice, bob, "Math")],
                bob: [StudyGroup(bob, charlie, "Science")],
                charlie: [StudyGroup(charlie, diana, "History")],
                diana: []
            }

            # Send grade-specific message
            messenger = GradeSpecificMessenger(
                "Grade 9 field trip permission slips due Friday!",
                9
            )

            messenger.visit_student(alice, connections)

            # Check who got the message
            print(f"Alice's messages: {alice.messages}")
            print(f"Bob's messages: {bob.messages}")
            print(f"Charlie's messages: {charlie.messages}")
        ```

## Walker Control Flow

!!! topic "Traversal Control"
    Walkers can control their movement through the graph using special statements like `visit` and `disengage`.

### Controlling Walker Behavior

!!! example "Smart Walker Control"
    === "Jac"
        <div class="code-block">
        ```jac
        node Student {
            has name: str;
            has grade_level: int;
        }

        walker AttendanceChecker {
            has present_students: list[str] = [];
            has absent_students: list[str] = [];
            has max_checks: int = 5;
            has checks_done: int = 0;

            can check_attendance with Student entry {
                self.checks_done += 1;

                # Simulate checking if student is present (random for demo)
                import random;
                is_present = random.choice([True, False]);

                if is_present {
                    print(f"{here.name} is present");
                    self.present_students.append(here.name);
                } else {
                    print(f"{here.name} is absent");
                    self.absent_students.append(here.name);
                }

                # Control flow based on conditions
                if self.checks_done >= self.max_checks {
                    print(f"Reached maximum checks ({self.max_checks})");
                    self.report_final();
                    disengage;  # Stop the walker
                }

                # Skip if no more connections
                connections = [-->];
                if not connections {
                    print("No more students to check");
                    self.report_final();
                    disengage;
                }

                # Continue to next student
                visit [-->];
            }

            def report_final() -> None {
                print(f" Attendance Report:");
                print(f"   Present: {self.present_students}");
                print(f"   Absent: {self.absent_students}");
                print(f"   Total checked: {self.checks_done}");
            }
        }

        with entry {
            # Create a chain of students
            alice = root ++> Student(name="Alice", grade_level=9);
            bob = alice ++> Student(name="Bob", grade_level=9);
            charlie = bob ++> Student(name="Charlie", grade_level=9);
            diana = charlie ++> Student(name="Diana", grade_level=9);
            eve = diana ++> Student(name="Eve", grade_level=9);

            # Start attendance check
            checker = AttendanceChecker(max_checks=3);
            alice[0] spawn checker;
        }
        ```
        </div>
    === "Python"
        ```python
        import random

        class AttendanceChecker:
            def __init__(self, max_checks: int = 5):
                self.present_students = []
                self.absent_students = []
                self.max_checks = max_checks
                self.checks_done = 0
                self.should_stop = False

            def check_student(self, student, connections):
                if self.should_stop:
                    return

                self.checks_done += 1

                # Simulate checking if student is present
                is_present = random.choice([True, False])

                if is_present:
                    print(f" {student.name} is present")
                    self.present_students.append(student.name)
                else:
                    print(f" {student.name} is absent")
                    self.absent_students.append(student.name)

                # Control flow based on conditions
                if self.checks_done >= self.max_checks:
                    print(f" Reached maximum checks ({self.max_checks})")
                    self.report_final()
                    return  # Stop checking

                # Continue to next student if available
                next_students = connections.get(student, [])
                if not next_students:
                    print(" No more students to check")
                    self.report_final()
                    return

                # Visit next student
                for next_student in next_students:
                    self.check_student(next_student, connections)

            def report_final(self):
                print(f" Attendance Report:")
                print(f"   Present: {self.present_students}")
                print(f"   Absent: {self.absent_students}")
                print(f"   Total checked: {self.checks_done}")

        if __name__ == "__main__":
            # Create a chain of students
            alice = Student("Alice", 9)
            bob = Student("Bob", 9)
            charlie = Student("Charlie", 9)
            diana = Student("Diana", 9)
            eve = Student("Eve", 9)

            # Create connections (linear chain)
            connections = {
                alice: [bob],
                bob: [charlie],
                charlie: [diana],
                diana: [eve],
                eve: []
            }

            # Start attendance check
            checker = AttendanceChecker(max_checks=3)
            checker.check_student(alice, connections)
        ```

## Key Concepts Summary

!!! summary "Walker and Ability Fundamentals"
    - **Walkers** are mobile computational entities that traverse graphs
    - **Abilities** are event-driven methods that execute automatically during traversal
    - **Entry abilities** trigger when a walker arrives at a node
    - **Exit abilities** trigger when a walker leaves a node
    - **Spawn** activates a walker at a specific starting location
    - **Visit** moves a walker to connected nodes
    - **Disengage** stops a walker's execution

## Best Practices

!!! summary "Walker Design Guidelines"
    - **Keep abilities focused**: Each ability should have a single, clear purpose
    - **Use descriptive names**: Make it clear what each walker and ability does
    - **Handle edge cases**: Check for empty connections before visiting
    - **Control traversal flow**: Use conditions to avoid infinite loops
    - **Report results**: Use exit abilities to summarize walker activities
    - **Manage state**: Use walker properties to track progress and results

## Key Takeaways

!!! summary "What We've Learned"
    **Walker System:**

    - **Mobile computation**: Walkers bring processing directly to data locations
    - **State management**: Walkers carry their own state as they traverse
    - **Traversal control**: Fine-grained control over movement patterns
    - **Spawning mechanism**: Activate walkers at specific graph locations

    **Ability System:**

    - **Event-driven execution**: Abilities trigger automatically based on walker location
    - **Entry/exit patterns**: React to walker arrival and departure events
    - **Context awareness**: Abilities have access to current node (`here`) and walker state
    - **Conditional execution**: Abilities can include logic to control when they execute

    **Traversal Patterns:**

    - **Visit statements**: Direct walker movement to connected nodes
    - **Filtering support**: Visit only nodes that match specific criteria
    - **Flow control**: Use `disengage` to stop walker execution
    - **Recursive traversal**: Walkers can spawn other walkers for complex patterns

    **Practical Applications:**

    - **Data processing**: Process distributed data where it lives
    - **Graph analysis**: Analyze relationships and connections
    - **Message delivery**: Distribute information through networks
    - **State propagation**: Update related nodes based on changes

!!! tip "Try It Yourself"
    Master walkers and abilities by building:
    - A message delivery system that traverses social networks
    - An attendance checker that visits classrooms
    - A family tree explorer that analyzes relationships
    - A network analyzer that processes organizational structures

    Remember: Walkers bring computation to data - think about how your processing can move through your graph!

---

*Walkers and abilities are now part of your toolkit. Let's master advanced graph operations and sophisticated traversal patterns!*




================================================================================
FILE: docs/jac_book/chapter_12.md
================================================================================


# Chapter 12: Walkers as API Endpoints

In this chapter, we'll explore how Jac automatically transforms walkers into RESTful API endpoints with our **Jac Cloud** Plugin. Jac Cloud, is a revolutionary cloud platform that transforms your Jac programs into scalable web services without code changes. This means you can focus on building your application logic while Jac handles the HTTP details for you.


We'll build a simple shared notebook system that demonstrates automatic API generation, request handling, and parameter validation through a practical example.

!!! info "What You'll Learn"
    - Understanding Jac Cloud's scale-agnostic architecture
    - Converting walkers into API endpoints automatically
    - Deploying applications with zero configuration
    - Managing persistence and state in the cloud

---

## What is Jac Cloud?

Jac Cloud is a cloud-native execution environment designed specifically for Jac programs. It enables developers to write code once and run it anywhere - from local development to production-scale deployments - without any modifications.

!!! success "Key Benefits"
    - **Zero Code Changes**: Same code runs locally and in the cloud
    - **Automatic APIs**: Walkers become REST endpoints automatically
    - **Built-in Persistence**: Data storage handled transparently
    - **Instant Scaling**: Scale by increasing service replicas
    - **Developer Focus**: No infrastructure management needed


## Quick Setup and Deployment
Let's start with a minimal weather API example and gradually enhance it throughout this chapter.

First, ensure you have the Jac Cloud plugin installed:

```bash
pip install jac-cloud
```

Next, crate a simple Jac program that contains a single walker that produces weather information based on a city name. This program creates a REST API endpoint that accepts a city name and returns the weather information. The walker has a property `city` which is automatically mapped to an expected request parameter in the request body.


!!! example "Basic Weather API"
    === "Jac Cloud"
        ```jac
        # weather.jac - No manual API setup needed
        walker get_weather {
            has city: str;

            obj __specs__ {
                static has auth: bool = False;
            }

            can get_weather_data with `root entry {
                # Your weather logic here
                weather_info = f"Weather in {self.city}: Sunny, 25Â°C";
                report {"city": self.city, "weather": weather_info};
            }
        }
        ```

    === "Traditional Approach"
        ```python
        # app.py - Manual API setup required
        from flask import Flask, jsonify

        app = Flask(__name__)

        @app.route('/weather/<city>', methods=['GET'])
        def get_weather(city):
            weather_info = f"Weather in {city}: Sunny, 25Â°C"
            return jsonify({"city": city, "weather": weather_info})

        if __name__ == '__main__':
            app.run(debug=True)
        ```


### Deploying to Cloud
To deploy your Jac program as a cloud service, use the `jac serve` command:

```bash
jac serve weather_service.jac
```

!!! success "Instant Deployment"
    ```
    INFO:     Started server process [26286]
    INFO:     Waiting for application startup.
    INFO:     Application startup complete.
    INFO:     Uvicorn running on http://0.0.0.0:8000 (Press CTRL+C to quit)
    ```

Your walker is now automatically available as a REST API endpoint!

To test the API, you can use `curl` or any HTTP client:

```bash
curl -X POST http://localhost:8000/walker/get_weather \
  -H "Content-Type: application/json" \
  -d '{"city": "New York"}'
```

In this example the endpoint is defined as `/walker/get_weather`, however, the endpoint also expects a JSON request body with a `city` field.

The response will be a JSON object containing the weather information.

!!! success "API Response"
    ```json
    {
        "returns": [
            {
                "city": "New York",
                "weather": "Weather in New York: Sunny, 25Â°C"
            }
        ]
    }
    ```


!!! note "Authentication"
    - Jac Cloud provides built-in support for authentication and authorization.
    - You can define authentication requirements using the `auth` property in the `__specs__` object.
    - By default, all walkers are private, but you can make them public by setting `auth: False`.
    - To learn more about authentication, see the [Jac Cloud Section of the Documentation](../learn/jac-cloud/introduction.md).

---

## Going Beyond: Building a Shared Notebook API
Now that we have a basic understanding of Jac Cloud and how it automatically generates APIs from walkers, let's build a more complex application: a shared notebook system.

First lets develop a walker that allows users to create and retrieve notes in a notebook. This will demonstrate how Jac handles request/response mapping, parameter validation, and persistence automatically.

!!! example "API Development Comparison"
    === "Jac Automatic APIs"
        ```jac
        import uuid;

        # notebook.jac - No manual API setup needed
        node Note {
            has title: str;
            has content: str;
            has author: str;
            has created_at: str = "2024-01-15";
            has id: str = "note_" + str(uuid.uuid4());
        }



        walker create_note {
            has title: str;
            has content: str;
            has author: str;

            obj __specs__ {
                static has auth: bool = False;
            }

            can create_new_note with `root entry {
                new_note = Note(
                    title=self.title,
                    content=self.content,
                    author=self.author
                );

                here ++> new_note;
                report {"message": "Note created", "id": new_note.id};
            }
        }

        walker get_notes {
            obj __specs__ {
                static has auth: bool = False;
            }

            can fetch_all_notes with `root entry {
                all_notes = [-->(`?Note)];
                notes_data = [
                    {"id": n.id, "title": n.title, "author": n.author}
                    for n in all_notes
                ];
                report {"notes": notes_data, "total": len(notes_data)};
            }
        }
        ```
    === "Traditional Approach"
        ```python
        # app.py - Manual API setup required
        from flask import Flask, request, jsonify
        from typing import Dict, List

        app = Flask(__name__)

        # Global storage (in production, use a database)
        notebooks = {}

        @app.route('/create_note', methods=['POST'])
        def create_note():
            try:
                data = request.get_json()
                title = data.get('title')
                content = data.get('content')
                author = data.get('author')

                # Manual validation
                if not title or not content or not author:
                    return jsonify({"error": "Missing required fields"}), 400

                note_id = len(notebooks) + 1
                notebooks[note_id] = {
                    "id": note_id,
                    "title": title,
                    "content": content,
                    "author": author
                }

                return jsonify({"message": "Note created", "id": note_id})
            except Exception as e:
                return jsonify({"error": str(e)}), 500

        @app.route('/get_notes', methods=['GET'])
        def get_notes():
            return jsonify(list(notebooks.values()))

        if __name__ == '__main__':
            app.run(debug=True)
        ```


Deploy your notebook API:

```bash
jac serve simple_notebook.jac
```

We can now test the API using `curl` or any HTTP client via the POST method. The `create_note` walker will accept a JSON request body with `title`, `content`, and `author` fields, and return a response indicating the note was created.

```bash
curl -X POST http://localhost:8000/walker/create_note \
  -H "Content-Type: application/json" \
  -d '{
    "title": "My First Note",
    "content": "This is a test note",
    "author": "Alice"
  }'
```

!!! success "API Response"
    ```json
    {
        "returns": [
            {
                "status": "created",
                "note": {
                    "title": "My First Note",
                    "author": "Alice"
                }
            }
        ]
    }
    ```

To retrieve all notes, we can use the `get_notes` walker:

```bash
curl -X POST http://localhost:8000/walker/get_notes \
  -H "Content-Type: application/json" \
  -d '{}'
```

### Convert to GET request
To convert the `get_notes` walker to a GET request, we can simply change the walker `___specs__` to indicate that it can be accessed via a GET request. This is done by setting the `methods` attribute in the `__specs__` object.

```jac
walker get_notes {
    obj __specs__ {
        static has auth: bool = False;
        static has methods: list = ["get"];
    }

    can fetch_all_notes with `root entry {
        all_notes = [-->(`?Note)];
        notes_data = [
            {"id": n.id, "title": n.title, "author": n.author}
            for n in all_notes
        ];
        report {"notes": notes_data, "total": len(notes_data)};
    }
}
```

The `get_notes` walker can now be accessed via a GET request at the endpoint `/walker/get_notes`.

```bash
curl -X GET http://localhost:8000/walker/get_notes \
  -H "Content-Type: application/json" \
  -d '{}'
```

---

## Parameter Validation

Jac automatically validates request parameters based on walker attribute types. This eliminates manual validation code and ensures type safety.

### Enhanced Notebook with Validation

!!! example "Notebook with Type Validation"

    ```jac
    # validated_notebook.jac
    node Note {
        has title: str;
        has content: str;
        has author: str;
        has priority: int = 1;  # 1-5 priority level
        has tags: list[str] = [];
    }

    walker create_note {
        has title: str;
        has content: str;
        has author: str;
        has priority: int = 1;
        has tags: list[str] = [];

        obj __specs__ {
            static has auth: bool = False;
        }

        can validate_and_create with `root entry {
            # Jac automatically validates types before this runs

            # Additional business logic validation
            if len(self.title) < 3 {
                report {"error": "Title must be at least 3 characters"};
                return;
            }

            if self.priority < 1 or self.priority > 5 {
                report {"error": "Priority must be between 1 and 5"};
                return;
            }

            # Create note with validated data
            new_note = Note(
                title=self.title,
                content=self.content,
                author=self.author,
                priority=self.priority,
                tags=self.tags
            );
            here ++> new_note;

            report {
                "message": "Note created successfully",
                "note_title": new_note.title,
                "priority": new_note.priority
            };
        }
    }
    ```

### Testing Validation

```bash
# Valid request
curl -X POST http://localhost:8000/walker/create_note \
  -H "Content-Type: application/json" \
  -d '{
    "title": "Important Meeting",
    "content": "Discuss project timeline",
    "author": "Bob",
    "priority": 3,
    "tags": ["work", "meeting"]
  }'

# Invalid request - priority out of range
curl -X POST http://localhost:8000/walker/create_note \
  -H "Content-Type: application/json" \
  -d '{
    "title": "Test",
    "content": "Test content",
    "author": "Bob",
    "priority": 10
  }'
```

!!! tip "Automatic Type Validation"
    Jac validates types before your walker code runs. Invalid types return HTTP 400 automatically.

---

## REST Patterns with Walkers

Walkers naturally map to REST operations, creating intuitive API patterns for common CRUD operations.

### Complete Notebook API

!!! example "Full CRUD Notebook System"

    ```jac
    import from uuid { uuid4 }

    # complete_notebook.jac
    node Note {
        has title: str;
        has content: str;
        has author: str;
        has priority: int = 1;
        has created_at: str = "2024-01-15";
        has id: str;
    }

    # CREATE - Add new note
    walker create_note {
        has title: str;
        has content: str;
        has author: str;
        has priority: int = 1;

        can add_note with `root entry {
            new_note = Note(
                title=self.title, content=self.content,
                author=self.author, priority=self.priority,
                id="note_" + str(uuid4())
            );
            here ++> new_note;
            report {"message": "Note created", "id": new_note.id};
        }
    }

    # READ - Get all notes
    walker list_notes {
        can get_all_notes with `root entry {
            all_notes = [-->(`?Note)];
            report {
                "notes": [
                    {
                        "id": n.id,
                        "title": n.title,
                        "author": n.author,
                        "priority": n.priority
                    }
                    for n in all_notes
                ],
                "total": len(all_notes)
            };
        }
    }

    # READ - Get specific note
    walker get_note {
        has note_id: str;

        can fetch_note with `root entry {
            target_note = [-->(`?Note)](?id == self.note_id);

            if target_note {
                note = target_note[0];
                report {
                    "note": {
                        "id": note.id,
                        "title": note.title,
                        "content": note.content,
                        "author": note.author,
                        "priority": note.priority
                    }
                };
            } else {
                report {"error": "Note not found"};
            }
        }
    }

    # UPDATE - Modify note
    walker update_note {
        has note_id: str;
        has title: str = "";
        has content: str = "";
        has priority: int = 0;

        can modify_note with `root entry {
            target_note = [-->(`?Note)](?id == self.note_id);

            if target_note {
                note = target_note[0];

                # Update only provided fields
                if self.title {
                    note.title = self.title;
                }
                if self.content {
                    note.content = self.content;
                }
                if self.priority > 0 {
                    note.priority = self.priority;
                }

                report {"message": "Note updated", "id": note.id};
            } else {
                report {"error": "Note not found"};
            }
        }
    }

    # DELETE - Remove note
    walker delete_note {
        has note_id: str;

        can remove_note with `root entry {
            target_note = [-->(`?Note)](?id == self.note_id);

            if target_note {
                note = target_note[0];
                # Delete the node and its connections
                del note;
                report {"message": "Note deleted", "id": self.note_id};
            } else {
                report {"error": "Note not found"};
            }
        }
    }
    ```

### API Usage Examples

```bash
# Create a note
curl -X POST http://localhost:8000/walker/create_note \
  -H "Content-Type: application/json" \
  -d '{"title": "Shopping List", "content": "Milk, Bread, Eggs", "author": "Alice"}'

# List all notes
curl -X POST http://localhost:8000/walker/list_notes \
  -H "Content-Type: application/json" \
  -d '{}'

# Get specific note (replace with actual ID)
curl -X POST http://localhost:8000/walker/get_note \
  -H "Content-Type: application/json" \
  -d '{"note_id": "note_123"}'

# Update a note
curl -X POST http://localhost:8000/walker/update_note \
  -H "Content-Type: application/json" \
  -d '{"note_id": "note_123", "priority": 5}'

# Delete a note
curl -X POST http://localhost:8000/walker/delete_note \
  -H "Content-Type: application/json" \
  -d '{"note_id": "note_123"}'
```

---

## Shared Notebook with Permissions

Let's add basic permission checking to demonstrate multi-user patterns:

!!! example "Notebook with User Permissions"
    ```jac
    import from uuid { uuid4 }

    # shared_notebook.jac
    node Note {
        has title: str;
        has content: str;
        has author: str;
        has shared_with: list[str] = [];
        has is_public: bool = false;
        has id: str;
    }

    walker create_shared_note {
        has title: str;
        has content: str;
        has author: str;
        has shared_with: list[str] = [];
        has is_public: bool = false;

        can create_note with `root entry {
            new_note = Note(
                title=self.title,
                content=self.content,
                author=self.author,
                shared_with=self.shared_with,
                is_public=self.is_public,
                id="note_" + str(uuid4())
            );
            here ++> new_note;

            report {
                "message": "Shared note created",
                "id": new_note.id,
                "shared_with": len(self.shared_with),
                "is_public": self.is_public
            };
        }
    }

    walker get_user_notes {
        has user: str;

        can fetch_accessible_notes with `root entry {
            all_notes = [-->(`?Note)];
            accessible_notes = [];

            for note in all_notes {
                # User can access if they're the author, note is public,
                # or they're in the shared_with list
                if (note.author == self.user or
                    note.is_public or
                    self.user in note.shared_with) {
                    accessible_notes.append({
                        "id": note.id,
                        "title": note.title,
                        "author": note.author,
                        "is_mine": note.author == self.user
                    });
                }
            }

            report {
                "user": self.user,
                "notes": accessible_notes,
                "count": len(accessible_notes)
            };
        }
    }

    walker share_note {
        has note_id: str;
        has user: str;
        has share_with: str;

        can add_share_permission with `root entry {
            target_note = [-->(`?Note)](?id == self.note_id);

            if target_note {
                note = target_note[0];

                # Only author can share
                if note.author == self.user {
                    if self.share_with not in note.shared_with {
                        note.shared_with.append(self.share_with);
                    }

                    report {
                        "message": f"Note shared with {self.share_with}",
                        "shared_with": note.shared_with
                    };
                } else {
                    report {"error": "Only author can share notes"};
                }
            } else {
                report {"error": "Note not found"};
            }
        }
    }
    ```

### Testing Shared Notebook

```bash
# Create a shared note
curl -X POST http://localhost:8000/walker/create_shared_note \
  -H "Content-Type: application/json" \
  -d '{
    "title": "Team Meeting Notes",
    "content": "Discussed project milestones",
    "author": "Alice",
    "shared_with": ["Bob", "Charlie"],
    "is_public": false
  }'

# Get notes for a user
curl -X POST http://localhost:8000/walker/get_user_notes \
  -H "Content-Type: application/json" \
  -d '{"user": "Bob"}'

# Share note with another user
curl -X POST http://localhost:8000/walker/share_note \
  -H "Content-Type: application/json" \
  -d '{
    "note_id": "note_123",
    "user": "Alice",
    "share_with": "David"
  }'
```

---

## Best Practices

!!! summary "API Development Guidelines"
    - **Use descriptive walker names**: Names become part of your API surface
    - **Validate input early**: Check parameters before processing
    - **Provide clear error messages**: Help API consumers understand failures
    - **Keep walkers focused**: Each walker should have a single responsibility
    - **Use consistent response formats**: Standardize success and error responses
    - **Document with types**: Type annotations serve as API documentation

## Key Takeaways

!!! summary "What We've Learned"
    **Automatic API Generation:**

    - **Zero configuration**: Walkers become REST endpoints without setup
    - **Type-safe parameters**: Request validation handled automatically
    - **Natural REST patterns**: CRUD operations map intuitively to walker semantics
    - **Instant deployment**: Deploy APIs with a single command

    **Request/Response Handling:**

    - **JSON mapping**: Request bodies automatically map to walker attributes
    - **Response formatting**: Walker reports become structured JSON responses
    - **Parameter validation**: Type system validates requests before execution
    - **Error handling**: Built-in patterns for graceful error responses

    **Shared Data Applications:**

    - **Persistent nodes**: Data survives between API requests
    - **Graph operations**: Complex data relationships handled naturally
    - **User permissions**: Implement access control with business logic
    - **Multi-user patterns**: Support shared and private data seamlessly

    **Development Benefits:**

    - **Focus on logic**: No HTTP handling, routing, or serialization code
    - **Type safety**: Compile-time validation for API contracts
    - **Rapid iteration**: Changes take effect immediately
    - **Scale-ready**: Same code works from development to production

!!! tip "Try It Yourself"
    Build sophisticated APIs by adding:
    - Authentication and user sessions
    - File upload and processing capabilities
    - Real-time notifications and webhooks
    - Integration with external services

    Remember: Every walker you create automatically becomes an API endpoint when deployed!

---

*Ready to learn about persistent data? Continue to [Chapter 13: Persistence and the Root Node](chapter_13.md)!*




================================================================================
FILE: docs/jac_book/chapter_17.md
================================================================================


# Chapter 18: Testing and Debugging

In this chapter, we'll explore Jac's built-in testing framework and debugging strategies for spatial applications. We'll build a comprehensive test suite for a social media system that demonstrates testing nodes, edges, walkers, and complex graph operations.

!!! info "What You'll Learn"
    - Jac's built-in testing framework with `.test.jac` files
    - Testing spatial applications with nodes, edges, and walkers
    - Debugging techniques for graph traversal and walker behavior
    - Performance testing and optimization strategies
    - Test-driven development patterns for OSP

---

## Jac's Built-in Testing Framework

Jac provides a powerful testing framework that automatically discovers and runs tests. When you run `jac test myfile.jac`, it automatically looks for `myfile.test.jac` and executes all test blocks within it.

!!! success "Testing Framework Benefits"
    - **Automatic Discovery**: `.test.jac` files are automatically found and executed
    - **Graph-Aware Testing**: Native support for testing spatial relationships
    - **Walker Testing**: Test mobile computation patterns naturally
    - **Type-Safe Assertions**: Leverage Jac's type system in test validation
    - **Zero Configuration**: No external testing frameworks required

### Traditional vs Jac Testing

!!! example "Testing Comparison"
    === "Traditional Approach"
        ```python
        # test_social_media.py - External framework required
        import unittest
        from social_media import Profile, Tweet, Comment

        class TestSocialMedia(unittest.TestCase):
            def setUp(self):
                self.profile = Profile("test_user")
                self.tweet = Tweet("Hello world!")

            def test_create_profile(self):
                self.assertEqual(self.profile.username, "test_user")
                self.assertIsInstance(self.profile, Profile)

            def test_create_tweet(self):
                self.profile.add_tweet(self.tweet)
                self.assertEqual(len(self.profile.tweets), 1)
                self.assertEqual(self.profile.tweets[0].content, "Hello world!")

            def test_follow_user(self):
                other_user = Profile("other_user")
                self.profile.follow(other_user)
                self.assertIn(other_user, self.profile.following)

        if __name__ == '__main__':
            unittest.main()
        ```

    === "Jac Testing"
        ```jac
        # social_media.test.jac - Built-in testing

        test create_profile {
            root spawn visit_profile();
            profile = [root --> Profile][0];
            check isinstance(profile, Profile);
            check profile.username == "";  # Default value
        }

        test update_profile {
            root spawn update_profile(new_username="test_user");
            profile = [root --> Profile][0];
            check profile.username == "test_user";
        }

        test create_tweet {
            root spawn create_tweet(content="Hello world!");
            tweet = [root --> Profile --> Tweet][0];
            check tweet.content == "Hello world!";
            check isinstance(tweet, Tweet);
        }

        test follow_user {
            # Create another profile to follow
            other_profile = Profile(username="other_user");
            other_profile spawn follow_request();

            # Check follow relationship exists
            followed = [root --> Profile ->:Follow:-> Profile][0];
            check followed.username == "other_user";
        }
        ```

---

## Testing Graph Structures

Testing spatial applications requires verifying both node properties and relationship integrity. Let's build a comprehensive social media system and test it thoroughly.

### Basic Social Media System

!!! example "Social Media Implementation"
    === "social_media.jac"
        ```jac
        # social_media.jac
        import from datetime { datetime }

        node Profile {
            has username: str = "";
            has bio: str = "";
            has follower_count: int = 0;

            can update with update_profile entry;
            can follow with follow_request entry;
            can unfollow with unfollow_request entry;
        }

        node Tweet {
            has content: str;
            has created_at: str = datetime.now().strftime("%Y-%m-%d %H:%M:%S");
            has like_count: int = 0;

            can update with update_tweet exit;
            can delete with remove_tweet exit;
            can like with like_tweet entry;
            can unlike with unlike_tweet entry;
        }

        node Comment {
            has content: str;
            has created_at: str = datetime.now().strftime("%Y-%m-%d %H:%M:%S");

            can update with update_comment entry;
            can delete with remove_comment entry;
        }

        edge Follow {
            has followed_at: str = datetime.now().strftime("%Y-%m-%d %H:%M:%S");
        }

        edge Post {
            has posted_at: str = datetime.now().strftime("%Y-%m-%d %H:%M:%S");
        }

        edge Like {
            has liked_at: str = datetime.now().strftime("%Y-%m-%d %H:%M:%S");
        }

        edge CommentOn {}

        walker visit_profile {
            can visit_profile with `root entry {
                visit [-->Profile] else {
                    new_profile = here ++> Profile();
                    visit new_profile;
                }
            }
        }

        walker update_profile(visit_profile) {
            has new_username: str;
            has new_bio: str = "";
        }

        walker follow_request {
            can follow_user with Profile entry {
                current_profile = [root --> Profile][0];
                if current_profile != here {
                    current_profile +>:Follow:+> here;
                    here.follower_count += 1;
                    report {"message": f"Now following {here.username}"};
                } else {
                    report {"error": "Cannot follow yourself"};
                }
            }
        }

        walker unfollow_request {
            can unfollow_user with Profile entry {
                current_profile = [root --> Profile][0];
                follow_edges = [edge current_profile ->:Follow:-> here];
                if follow_edges {
                    del follow_edges[0];
                    here.follower_count -= 1;
                    report {"message": f"Unfollowed {here.username}"};
                } else {
                    report {"error": "Not following this user"};
                }
            }
        }

        walker create_tweet(visit_profile) {
            has content: str;

            can post_tweet with Profile entry {
                tweet = here +>:Post:+> Tweet(content=self.content);
                report {"message": "Tweet created", "tweet_id": tweet[0].id};
            }
        }

        walker update_tweet {
            has updated_content: str;
        }

        walker remove_tweet {}

        walker like_tweet {
            can like_post with Tweet entry {
                current_profile = [root --> Profile][0];
                existing_likes = [edge current_profile ->:Like:-> here];

                if not existing_likes {
                    current_profile +>:Like:+> here;
                    here.like_count += 1;
                    report {"message": "Tweet liked"};
                } else {
                    report {"error": "Already liked this tweet"};
                }
            }
        }

        walker unlike_tweet {
            can unlike_post with Tweet entry {
                current_profile = [root --> Profile][0];
                like_edges = [edge current_profile ->:Like:-> here];

                if like_edges {
                    del like_edges[0];
                    here.like_count -= 1;
                    report {"message": "Tweet unliked"};
                } else {
                    report {"error": "Haven't liked this tweet"};
                }
            }
        }

        walker comment_on_tweet {
            has content: str;

            can add_comment with Tweet entry {
                current_profile = [root --> Profile][0];
                comment = current_profile ++> Comment(content=self.content);
                here +>:CommentOn:+> comment[0];
                report {"message": "Comment added", "comment_id": comment[0].id};
            }
        }
        ```

    === "Python Equivalent"
        ```python
        # social_media.py - Manual implementation
        from datetime import datetime
        from typing import List, Optional

        class Profile:
            def __init__(self, username: str = "", bio: str = ""):
                self.username = username
                self.bio = bio
                self.follower_count = 0
                self.following = []
                self.followers = []
                self.tweets = []

            def follow(self, other_profile):
                if other_profile not in self.following and other_profile != self:
                    self.following.append(other_profile)
                    other_profile.followers.append(self)
                    other_profile.follower_count += 1
                    return True
                return False

            def unfollow(self, other_profile):
                if other_profile in self.following:
                    self.following.remove(other_profile)
                    other_profile.followers.remove(self)
                    other_profile.follower_count -= 1
                    return True
                return False

        class Tweet:
            def __init__(self, content: str, author: Profile):
                self.content = content
                self.author = author
                self.created_at = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                self.like_count = 0
                self.liked_by = []
                self.comments = []

            def like(self, user: Profile):
                if user not in self.liked_by:
                    self.liked_by.append(user)
                    self.like_count += 1
                    return True
                return False

            def unlike(self, user: Profile):
                if user in self.liked_by:
                    self.liked_by.remove(user)
                    self.like_count -= 1
                    return True
                return False

        class Comment:
            def __init__(self, content: str, author: Profile, tweet: Tweet):
                self.content = content
                self.author = author
                self.tweet = tweet
                self.created_at = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        ```

### Comprehensive Test Suite

!!! example "Complete Test Coverage"
    === "social_media.test.jac"
        ```jac
        # social_media.test.jac

        # Test basic profile creation and updates
        test create_and_update_profile {
            # Test profile creation
            root spawn visit_profile();
            profile = [root --> Profile][0];
            check isinstance(profile, Profile);
            check profile.username == "";
            check profile.follower_count == 0;

            # Test profile update
            root spawn update_profile(
                new_username="alice",
                new_bio="Software developer"
            );
            updated_profile = [root --> Profile][0];
            check updated_profile.username == "alice";
            check updated_profile.bio == "Software developer";
        }

        # Test following functionality
        test follow_and_unfollow_users {
            # Create main user profile
            root spawn visit_profile();
            root spawn update_profile(new_username="alice");

            # Create another user to follow
            bob_profile = Profile(username="bob");

            # Test following
            bob_profile spawn follow_request();
            follow_edge = [root --> Profile ->:Follow:-> Profile][0];
            check follow_edge.username == "bob";
            check bob_profile.follower_count == 1;

            # Test follow edge properties
            follow_edges = [edge [root --> Profile] ->:Follow:-> bob_profile];
            check len(follow_edges) == 1;
            check hasattr(follow_edges[0], "followed_at");

            # Test unfollowing
            bob_profile spawn unfollow_request();
            remaining_follows = [root --> Profile ->:Follow:-> Profile];
            check len(remaining_follows) == 0;
            check bob_profile.follower_count == 0;
        }

        # Test tweet creation and management
        test tweet_lifecycle {
            # Ensure we have a profile
            root spawn visit_profile();
            root spawn update_profile(new_username="alice");

            # Test tweet creation
            root spawn create_tweet(content="Hello world!");
            tweet = [root --> Profile ->:Post:-> Tweet][0];
            check tweet.content == "Hello world!";
            check isinstance(tweet, Tweet);
            check hasattr(tweet, "created_at");

            # Test tweet update
            tweet spawn update_tweet(updated_content="Hello updated world!");
            check tweet.content == "Hello updated world!";

            # Test multiple tweets
            root spawn create_tweet(content="Second tweet");
            all_tweets = [root --> Profile ->:Post:-> Tweet];
            check len(all_tweets) == 2;

            # Test tweet deletion
            tweet spawn remove_tweet();
            remaining_tweets = [root --> Profile ->:Post:-> Tweet];
            check len(remaining_tweets) == 1;
            check remaining_tweets[0].content == "Second tweet";
        }

        # Test liking functionality
        test like_and_unlike_tweets {
            # Setup: Create profile and tweet
            root spawn visit_profile();
            root spawn update_profile(new_username="alice");
            root spawn create_tweet(content="Likeable tweet");

            tweet = [root --> Profile ->:Post:-> Tweet][0];
            check tweet.like_count == 0;

            # Test liking
            tweet spawn like_tweet();
            check tweet.like_count == 1;

            # Verify like relationship exists
            like_edges = [edge [root --> Profile] ->:Like:-> tweet];
            check len(like_edges) == 1;

            # Test double-liking (should fail)
            result = tweet spawn like_tweet();
            check tweet.like_count == 1;  # Should remain 1

            # Test unliking
            tweet spawn unlike_tweet();
            check tweet.like_count == 0;

            # Verify like relationship removed
            remaining_likes = [edge [root --> Profile] ->:Like:-> tweet];
            check len(remaining_likes) == 0;
        }

        # Test commenting functionality
        test comment_system {
            # Setup: Create profile and tweet
            root spawn visit_profile();
            root spawn update_profile(new_username="alice");
            root spawn create_tweet(content="Tweet for comments");

            tweet = [root --> Profile ->:Post:-> Tweet][0];

            # Test commenting
            tweet spawn comment_on_tweet(content="Great tweet!");
            comments = [tweet ->:CommentOn:-> Comment];
            check len(comments) == 1;
            check comments[0].content == "Great tweet!";

            # Test multiple comments
            tweet spawn comment_on_tweet(content="I agree!");
            all_comments = [tweet ->:CommentOn:-> Comment];
            check len(all_comments) == 2;

            # Test comment update
            first_comment = all_comments[0];
            first_comment spawn update_comment(updated_content="Updated comment");
            check first_comment.content == "Updated comment";

            # Test comment deletion
            first_comment spawn remove_comment();
            remaining_comments = [tweet ->:CommentOn:-> Comment];
            check len(remaining_comments) == 1;
        }

        # Test complex graph relationships
        test complex_social_graph {
            # Create multiple users
            root spawn visit_profile();
            root spawn update_profile(new_username="alice");

            bob = Profile(username="bob");
            charlie = Profile(username="charlie");

            # Create follow relationships: alice -> bob -> charlie
            bob spawn follow_request();
            charlie spawn follow_request();  # alice follows charlie too

            # Alice creates a tweet
            root spawn create_tweet(content="Alice's tweet");
            alice_tweet = [root --> Profile ->:Post:-> Tweet][0];

            # Bob likes Alice's tweet
            # (Note: In a real system, you'd switch user context)
            alice_tweet spawn like_tweet();

            # Verify complex relationships
            alice_profile = [root --> Profile][0];
            alice_following = [alice_profile ->:Follow:-> Profile];
            check len(alice_following) == 2;  # follows bob and charlie

            alice_tweets = [alice_profile ->:Post:-> Tweet];
            check len(alice_tweets) == 1;

            tweet_likes = [alice_tweets[0] <-:Like:<- Profile];
            check len(tweet_likes) == 1;  # liked by alice (herself)
        }

        # Test error conditions and edge cases
        test error_conditions {
            # Test operations without profile
            try {
                root spawn create_tweet(content="No profile tweet");
                check False;  # Should not reach here
            } except Exception {
                check True;  # Expected behavior
            }

            # Create profile for other tests
            root spawn visit_profile();
            root spawn update_profile(new_username="test_user");

            # Test self-follow prevention
            alice_profile = [root --> Profile][0];
            result = alice_profile spawn follow_request();

            # Should not create self-follow
            self_follows = [alice_profile ->:Follow:-> alice_profile];
            check len(self_follows) == 0;
        }

        # Performance and stress testing
        test performance_operations {
            # Setup
            root spawn visit_profile();
            root spawn update_profile(new_username="performance_user");

            # Create multiple tweets quickly
            for i in range(10) {
                root spawn create_tweet(content=f"Tweet number {i}");
            }

            all_tweets = [root --> Profile ->:Post:-> Tweet];
            check len(all_tweets) == 10;

            # Like all tweets
            for tweet in all_tweets {
                tweet spawn like_tweet();
            }

            # Verify all likes
            for tweet in all_tweets {
                check tweet.like_count == 1;
            }

            # Test batch operations work correctly
            total_likes = sum([tweet.like_count for tweet in all_tweets]);
            check total_likes == 10;
        }
        ```

    === "Python Test Equivalent"
        ```python
        # test_social_media.py
        import unittest
        from social_media import Profile, Tweet, Comment

        class TestSocialMedia(unittest.TestCase):
            def setUp(self):
                self.alice = Profile("alice", "Software developer")
                self.bob = Profile("bob", "Designer")

            def test_create_and_update_profile(self):
                profile = Profile()
                self.assertEqual(profile.username, "")
                self.assertEqual(profile.follower_count, 0)

                profile.username = "alice"
                profile.bio = "Software developer"
                self.assertEqual(profile.username, "alice")

            def test_follow_and_unfollow_users(self):
                # Test following
                success = self.alice.follow(self.bob)
                self.assertTrue(success)
                self.assertIn(self.bob, self.alice.following)
                self.assertEqual(self.bob.follower_count, 1)

                # Test unfollowing
                success = self.alice.unfollow(self.bob)
                self.assertTrue(success)
                self.assertNotIn(self.bob, self.alice.following)
                self.assertEqual(self.bob.follower_count, 0)

            def test_tweet_lifecycle(self):
                tweet = Tweet("Hello world!", self.alice)
                self.alice.tweets.append(tweet)

                self.assertEqual(tweet.content, "Hello world!")
                self.assertEqual(len(self.alice.tweets), 1)

                # Update tweet
                tweet.content = "Hello updated world!"
                self.assertEqual(tweet.content, "Hello updated world!")

            def test_like_and_unlike_tweets(self):
                tweet = Tweet("Likeable tweet", self.alice)

                # Test liking
                success = tweet.like(self.bob)
                self.assertTrue(success)
                self.assertEqual(tweet.like_count, 1)

                # Test double-liking
                success = tweet.like(self.bob)
                self.assertFalse(success)
                self.assertEqual(tweet.like_count, 1)

                # Test unliking
                success = tweet.unlike(self.bob)
                self.assertTrue(success)
                self.assertEqual(tweet.like_count, 0)

        if __name__ == '__main__':
            unittest.main()
        ```

---

## Debugging Spatial Applications

Debugging spatial applications requires understanding graph state and walker movement patterns.

### Debug Output and Tracing

!!! example "Debug Walker for Graph Inspection"
    ```jac
    # debug_walker.jac
    walker debug_graph {
        has visited_nodes: list[str] = [];
        has visited_edges: list[str] = [];
        has max_depth: int = 3;
        has current_depth: int = 0;

        can debug_node with Profile entry {
            if self.current_depth >= self.max_depth {
                print(f"Max depth {self.max_depth} reached at {here.username}");
                return;
            }

            node_info = f"Profile: {here.username} (followers: {here.follower_count})";
            self.visited_nodes.append(node_info);
            print(f"Depth {self.current_depth}: {node_info}");

            # Debug outgoing relationships
            following = [->:Follow:->];
            tweets = [->:Post:->];

            print(f"  Following: {len(following)} users");
            print(f"  Posted: {len(tweets)} tweets");

            # Visit connected nodes
            self.current_depth += 1;
            visit following;
            visit tweets;
            self.current_depth -= 1;
        }

        can debug_tweet with Tweet entry {
            tweet_info = f"Tweet: '{here.content[:30]}...' (likes: {here.like_count})";
            self.visited_nodes.append(tweet_info);
            print(f"Depth {self.current_depth}: {tweet_info}");

            # Debug tweet relationships
            likes = [<-:Like:<-];
            comments = [->:CommentOn:->];

            print(f"  Liked by: {len(likes)} users");
            print(f"  Comments: {len(comments)}");
        }

        can debug_comment with Comment entry {
            comment_info = f"Comment: '{here.content[:20]}...'";
            self.visited_nodes.append(comment_info);
            print(f"Depth {self.current_depth}: {comment_info}");
        }
    }

    # Usage in tests
    test debug_graph_structure {
        # Setup complex graph
        root spawn visit_profile();
        root spawn update_profile(new_username="alice");
        root spawn create_tweet(content="Alice's first tweet");

        bob = Profile(username="bob");
        bob spawn follow_request();

        # Debug the graph
        debugger = debug_graph(max_depth=2);
        root spawn debugger;

        print("=== Debug Summary ===");
        print(f"Visited {len(debugger.visited_nodes)} nodes");
        for node in debugger.visited_nodes {
            print(f"  {node}");
        }
    }
    ```

### Walker State Inspection

!!! example "Walker State Testing"
    ```jac
    # walker_testing.jac
    walker feed_loader {
        has user_id: str;
        has loaded_tweets: list[dict] = [];
        has users_visited: set[str] = set();
        has errors: list[str] = [];

        can load_user_feed with Profile entry {
            if here.username in self.users_visited {
                self.errors.append(f"Duplicate visit to {here.username}");
                return;
            }

            self.users_visited.add(here.username);

            # Load user's tweets
            user_tweets = [->:Post:-> Tweet];
            for tweet in user_tweets {
                tweet_data = {
                    "author": here.username,
                    "content": tweet.content,
                    "likes": tweet.like_count,
                    "created_at": tweet.created_at
                };
                self.loaded_tweets.append(tweet_data);
            }

            # Visit followed users
            following = [->:Follow:-> Profile];
            visit following;
        }
    }

    test walker_state_management {
        # Setup test data
        root spawn visit_profile();
        root spawn update_profile(new_username="alice");
        root spawn create_tweet(content="Alice tweet 1");
        root spawn create_tweet(content="Alice tweet 2");

        bob = Profile(username="bob");
        bob spawn follow_request();
        bob spawn create_tweet(content="Bob's tweet");

        # Test walker state
        loader = feed_loader(user_id="alice");
        root spawn loader;

        # Verify walker state
        check len(loader.loaded_tweets) >= 2;  # At least Alice's tweets
        check "alice" in loader.users_visited;
        check "bob" in loader.users_visited;
        check len(loader.errors) == 0;

        # Verify tweet data structure
        alice_tweets = [t for t in loader.loaded_tweets if t["author"] == "alice"];
        check len(alice_tweets) == 2;

        for tweet in alice_tweets {
            check "content" in tweet;
            check "likes" in tweet;
            check "created_at" in tweet;
        }
    }
    ```

---

## Performance Testing and Optimization

Performance testing ensures your spatial applications scale effectively.

### Benchmark Testing

!!! example "Performance Benchmarks"
    ```jac
    # performance_tests.jac
    import time;

    test large_graph_performance {
        start_time = time.time();

        # Create large social network
        root spawn visit_profile();
        root spawn update_profile(new_username="central_user");

        # Create many users and connections
        num_users = 100;
        users = [];

        for i in range(num_users) {
            user = Profile(username=f"user_{i}");
            users.append(user);

            # Every 10th user follows central user
            if i % 10 == 0 {
                user spawn follow_request();
            }
        }

        creation_time = time.time() - start_time;
        print(f"Created {num_users} users in {creation_time:.2f} seconds");

        # Test graph traversal performance
        start_time = time.time();

        # Count all followers
        central_user = [root --> Profile][0];
        followers = [central_user <-:Follow:<- Profile];

        traversal_time = time.time() - start_time;
        print(f"Traversed {len(followers)} followers in {traversal_time:.4f} seconds");

        # Performance assertions
        check creation_time < 5.0;  # Should create 100 users in under 5 seconds
        check traversal_time < 0.1;  # Should traverse quickly
        check len(followers) == 10;  # Every 10th user = 10 followers
    }

    test memory_efficiency {
        # Test memory usage with large datasets
        initial_profiles = len([root --> Profile]);

        # Create and delete many objects
        for batch in range(5) {
            # Create batch of tweets
            for i in range(20) {
                root spawn create_tweet(content=f"Batch {batch} tweet {i}");
            }

            # Delete half of them
            tweets = [root --> Profile ->:Post:-> Tweet];
            for i in range(10) {
                if len(tweets) > i {
                    tweets[i] spawn remove_tweet();
                }
            }
        }

        # Check memory cleanup
        final_tweets = [root --> Profile ->:Post:-> Tweet];
        check len(final_tweets) <= 50;  # Should not accumulate indefinitely

        final_profiles = len([root --> Profile]);
        check final_profiles == initial_profiles + 1;  # Only the test profile added
    }

    test concurrent_operations {
        # Simulate concurrent-like operations
        root spawn visit_profile();
        root spawn update_profile(new_username="concurrent_user");

        # Create multiple walkers that operate simultaneously
        walkers = [];
        for i in range(10) {
            walker = create_tweet(content=f"Concurrent tweet {i}");
            walkers.append(walker);
        }

        # Execute all walkers
        start_time = time.time();
        for walker in walkers {
            root spawn walker;
        }
        execution_time = time.time() - start_time;

        # Verify all operations completed
        all_tweets = [root --> Profile ->:Post:-> Tweet];
        check len(all_tweets) == 10;

        # Performance check
        check execution_time < 1.0;  # Should complete quickly

        print(f"Executed {len(walkers)} operations in {execution_time:.4f} seconds");
    }
    ```

### Memory and Resource Testing

!!! example "Resource Usage Tests"
    ```jac
    # resource_tests.jac
    import gc;
    import psutil;
    import os;

    test memory_usage_monitoring {
        # Get initial memory usage
        process = psutil.Process(os.getpid());
        initial_memory = process.memory_info().rss;

        # Create large graph structure
        root spawn visit_profile();
        root spawn update_profile(new_username="memory_test_user");

        # Create many interconnected objects
        for i in range(1000) {
            root spawn create_tweet(content=f"Memory test tweet {i}");
        }

        # Force garbage collection
        gc.collect();

        # Check memory after creation
        after_creation_memory = process.memory_info().rss;
        memory_increase = after_creation_memory - initial_memory;

        print(f"Memory increase: {memory_increase / 1024 / 1024:.2f} MB");

        # Clean up
        tweets = [root --> Profile ->:Post:-> Tweet];
        for tweet in tweets {
            tweet spawn remove_tweet();
        }

        # Force garbage collection again
        gc.collect();

        # Check memory after cleanup
        final_memory = process.memory_info().rss;
        memory_recovered = after_creation_memory - final_memory;

        print(f"Memory recovered: {memory_recovered / 1024 / 1024:.2f} MB");

        # Memory should not grow indefinitely
        check memory_increase < 100 * 1024 * 1024;  # Less than 100MB increase
        check memory_recovered > memory_increase * 0.5;  # At least 50% recovered
    }
    ```

---

## Test-Driven Development with OSP

TDD works naturally with Jac's spatial programming model.

### TDD Example: Building a Recommendation System

!!! example "TDD Recommendation System"
    ```jac
    # recommendation_system.test.jac

    # Test 1: Basic recommendation structure
    test recommendation_system_structure {
        # Red: This will fail initially
        root spawn visit_profile();
        root spawn update_profile(new_username="test_user");

        # Should be able to get recommendations
        recommendations = root spawn get_recommendations(limit=5);
        check isinstance(recommendations, list);
        check len(recommendations) <= 5;
    }

    # Test 2: Friend-based recommendations
    test friend_based_recommendations {
        # Setup: Create network
        root spawn visit_profile();
        root spawn update_profile(new_username="alice");

        bob = Profile(username="bob");
        charlie = Profile(username="charlie");

        # Alice follows Bob, Bob follows Charlie
        bob spawn follow_request();
        # Switch context to Bob and follow Charlie
        # (In real system, would handle user context switching)

        # Alice should get Charlie recommended (friend of friend)
        recommendations = root spawn get_recommendations(limit=5);
        recommended_usernames = [rec["username"] for rec in recommendations];

        # Charlie should be recommended as friend of friend
        check "charlie" in recommended_usernames;
    }

    # Test 3: Interest-based recommendations
    test interest_based_recommendations {
        # Setup users with similar interests (tweets)
        root spawn visit_profile();
        root spawn update_profile(new_username="alice");
        root spawn create_tweet(content="I love programming");

        bob = Profile(username="bob");
        bob spawn create_tweet(content="Programming is awesome");

        charlie = Profile(username="charlie");
        charlie spawn create_tweet(content="I hate programming");

        # Get recommendations
        recommendations = root spawn get_recommendations(
            limit=5,
            algorithm="interest_based"
        );

        # Bob should rank higher than Charlie due to similar interests
        bob_score = 0;
        charlie_score = 0;

        for rec in recommendations {
            if rec["username"] == "bob" {
                bob_score = rec["score"];
            }
            if rec["username"] == "charlie" {
                charlie_score = rec["score"];
            }
        }

        check bob_score > charlie_score;
    }

    # Test 4: Recommendation filtering
    test recommendation_filtering {
        # Setup
        root spawn visit_profile();
        root spawn update_profile(new_username="alice");

        # Create users alice already follows
        bob = Profile(username="bob");
        bob spawn follow_request();

        # Create users alice doesn't follow
        charlie = Profile(username="charlie");
        diana = Profile(username="diana");

        # Get recommendations
        recommendations = root spawn get_recommendations(limit=10);
        recommended_usernames = [rec["username"] for rec in recommendations];

        # Should not recommend users already followed
        check "bob" not in recommended_usernames;

        # Should recommend unfollowed users
        check "charlie" in recommended_usernames or "diana" in recommended_usernames;
    }
    ```

    Now implement the actual recommendation system to make tests pass:

    ```jac
    # recommendation_system.jac
    walker get_recommendations(visit_profile) {
        has limit: int = 5;
        has algorithm: str = "hybrid";
        has recommendations: list[dict] = [];

        can generate_recommendations with Profile entry {
            current_user = here;
            followed_users = [->:Follow:-> Profile];
            followed_usernames = set([user.username for user in followed_users]);

            # Get all users except current and already followed
            all_users = [root --> Profile](?username != current_user.username);
            candidate_users = [user for user in all_users
                             if user.username not in followed_usernames];

            # Score each candidate
            for candidate in candidate_users {
                score = self.calculate_recommendation_score(
                    current_user, candidate, followed_users
                );

                if score > 0 {
                    self.recommendations.append({
                        "username": candidate.username,
                        "score": score,
                        "reason": self.get_recommendation_reason(
                            current_user, candidate, followed_users
                        )
                    });
                }
            }

            # Sort by score and limit results
            self.recommendations.sort(key=lambda x: x["score"], reverse=True);
            self.recommendations = self.recommendations[:self.limit];

            report self.recommendations;
        }

        def calculate_recommendation_score(
            current_user: Profile,
            candidate: Profile,
            followed_users: list[Profile]
        ) -> float {
            score = 0.0;

            if self.algorithm in ["friend_based", "hybrid"] {
                # Friend of friend scoring
                candidate_followers = [candidate <-:Follow:<- Profile];
                mutual_connections = set([u.username for u in followed_users]) &
                                   set([u.username for u in candidate_followers]);
                score += len(mutual_connections) * 2.0;
            }

            if self.algorithm in ["interest_based", "hybrid"] {
                # Interest-based scoring using tweet content
                current_tweets = [current_user ->:Post:-> Tweet];
                candidate_tweets = [candidate ->:Post:-> Tweet];

                # Simple keyword matching (in real system, use embeddings)
                current_words = set();
                for tweet in current_tweets {
                    current_words.update(tweet.content.lower().split());
                }

                candidate_words = set();
                for tweet in candidate_tweets {
                    candidate_words.update(tweet.content.lower().split());
                }

                common_words = current_words & candidate_words;
                score += len(common_words) * 0.5;
            }

            return score;
        }

        def get_recommendation_reason(
            current_user: Profile,
            candidate: Profile,
            followed_users: list[Profile]
        ) -> str {
            # Determine primary reason for recommendation
            candidate_followers = [candidate <-:Follow:<- Profile];
            mutual_connections = set([u.username for u in followed_users]) &
                               set([u.username for u in candidate_followers]);

            if mutual_connections {
                return f"Friends with {list(mutual_connections)[0]}";
            }

            return "Similar interests";
        }
    }
    ```

---

## Best Practices

!!! summary "Testing Best Practices"
    - **Write tests first**: Use test-driven development for complex walker logic
    - **Test graph structures**: Verify node and edge relationships are correct
    - **Use descriptive names**: Make test intentions clear from the test name
    - **Test edge cases**: Include boundary conditions and error scenarios
    - **Isolate test data**: Ensure tests don't interfere with each other
    - **Mock external dependencies**: Test walker logic independently of external services

## Key Takeaways

!!! summary "What We've Learned"
    **Testing Framework:**

    - **Built-in testing**: Native test blocks eliminate external framework dependencies
    - **Graph testing**: Specialized patterns for testing spatial relationships
    - **Walker testing**: Comprehensive testing of mobile computation patterns
    - **Type-safe assertions**: Leverage Jac's type system in test validation

    **Debugging Techniques:**

    - **Debug output**: Strategic print statements and debug flags
    - **Walker tracing**: Track walker movement through graph structures
    - **State inspection**: Examine node and edge states during execution
    - **Error handling**: Graceful handling of edge cases and failures

    **Test Organization:**

    - **Modular testing**: Organize tests by functionality and complexity
    - **Helper functions**: Reusable setup code for consistent test environments
    - **Performance testing**: Monitor execution time and resource usage
    - **Integration testing**: Test interactions between multiple walkers

    **Quality Assurance:**

    - **Comprehensive coverage**: Test all code paths and error conditions
    - **Regression prevention**: Automated tests prevent breaking changes
    - **Documentation value**: Tests serve as executable specifications
    - **Continuous validation**: Automated testing in CI/CD pipelines

!!! tip "Try It Yourself"
    Enhance your testing skills by:
    - Writing comprehensive test suites for existing walker logic
    - Implementing performance benchmarks for graph operations
    - Creating integration tests for multi-walker scenarios
    - Adding debug instrumentation to complex graph traversals

    Remember: Good tests make development faster and more reliable!

---

*Ready to learn about deployment strategies? Continue to [Chapter 19: Deployment Strategies](chapter_18.md)!*




================================================================================
FILE: docs/jac_book/chapter_18.md
================================================================================


# Chapter 19: Deployment Strategies

In this chapter, we'll explore how to deploy Jac applications to production environments. We'll take our weather API from development to production using various deployment strategies including Docker, Kubernetes, and Jac Cloud.

!!! info "What You'll Learn"
    - Local vs cloud deployment comparison
    - Docker containerization for Jac applications
    - Kubernetes orchestration and scaling
    - Jac Cloud deployment with real examples
    - Production monitoring and maintenance

---

## Local to Cloud Deployment

One of Jac's most powerful features is its scale-agnostic nature - the same code that runs locally can be deployed to production without changes.

!!! success "Deployment Benefits"
    - **Zero Code Changes**: Same application runs locally and in production
    - **Automatic Scaling**: Built-in support for horizontal scaling
    - **Container Ready**: Applications naturally containerize
    - **Kubernetes Native**: Seamless Kubernetes integration
    - **Production Features**: Built-in monitoring, logging, and health checks

### Development to Production Pipeline

Let's start with our weather API and show how it progresses from development to production:

!!! example "Weather API Deployment Journey"
    === "Development (Local)"
        ```jac
        # weather_api.jac - Same code at every stage
        import from os { getenv }

        glob config = {
            "api_key": getenv("WEATHER_API_KEY", "dev-key"),
            "cache_timeout": int(getenv("CACHE_TIMEOUT", "300")),
            "debug": getenv("DEBUG", "true").lower() == "true"
        };

        node WeatherData {
            has city: str;
            has temperature: float;
            has description: str;
            has last_updated: str;
        }

        walker get_weather {
            has city: str;

            can fetch_weather with `root entry {
                # Check cache first
                cached = [-->(`?WeatherData)](?city == self.city);

                if cached {
                    weather = cached[0];
                    report {
                        "city": weather.city,
                        "temperature": weather.temperature,
                        "description": weather.description,
                        "cached": True
                    };
                } else {
                    # Simulate API call
                    new_weather = WeatherData(
                        city=self.city,
                        temperature=22.5,
                        description="Sunny",
                        last_updated="2024-01-15T10:00:00Z"
                    );
                    here ++> new_weather;

                    report {
                        "city": self.city,
                        "temperature": 22.5,
                        "description": "Sunny",
                        "cached": False
                    };
                }
            }
        }

        walker health_check {
            can check_health with `root entry {
                weather_count = len([-->(`?WeatherData)]);
                report {
                    "status": "healthy",
                    "cached_cities": weather_count,
                    "debug_mode": config["debug"]
                };
            }
        }
        ```

    === "Local Development"
        ```bash
        # Development workflow
        export DEBUG=true
        export WEATHER_API_KEY=dev-key

        # Run locally for development
        jac run weather_api.jac

        # Test as service locally
        jac serve weather_api.jac --port 8000

        # Test the endpoints
        curl -X POST http://localhost:8000/walker/get_weather \
          -H "Content-Type: application/json" \
          -d '{"city": "New York"}'
        ```

---

## Docker Containerization

Docker packaging makes your Jac applications portable and consistent across environments.

### Basic Dockerfile for Jac Applications

!!! example "Jac Application Dockerfile"
    === "Dockerfile"
        ```dockerfile
        # Dockerfile
        FROM python:3.11-slim

        # Set working directory
        WORKDIR /app

        # Install system dependencies
        RUN apt-get update && apt-get install -y \
            curl \
            && rm -rf /var/lib/apt/lists/*

        # Install Jac
        RUN pip install jaclang

        # Copy application files
        COPY weather_api.jac .
        COPY requirements.txt .

        # Install Python dependencies if any
        RUN pip install -r requirements.txt

        # Expose port
        EXPOSE 8000

        # Set environment variables
        ENV JAC_FILE=weather_api.jac
        ENV PORT=8000
        ENV DEBUG=false

        # Health check
        HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
            CMD curl -f http://localhost:$PORT/walker/health_check -X POST -H "Content-Type: application/json" -d '{}' || exit 1

        # Run the application
        CMD jac serve $JAC_FILE --port $PORT
        ```

    === "requirements.txt"
        ```txt
        # requirements.txt
        jaclang
        requests
        python-dotenv
        ```

    === "docker-compose.yml"
        ```yaml
        # docker-compose.yml
        version: '3.8'

        services:
          weather-api:
            build: .
            ports:
              - "8000:8000"
            environment:
              - DEBUG=false
              - WEATHER_API_KEY=${WEATHER_API_KEY}
              - CACHE_TIMEOUT=600
            volumes:
              - weather_data:/app/data
            restart: unless-stopped
            healthcheck:
              test: ["CMD", "curl", "-f", "http://localhost:8000/walker/health_check", "-X", "POST", "-H", "Content-Type: application/json", "-d", "{}"]
              interval: 30s
              timeout: 10s
              retries: 3

        volumes:
          weather_data:
        ```

### Building and Testing Docker Images

```bash
# Build the image
docker build -t weather-api:latest .

# Test locally
docker run -p 8000:8000 \
  -e WEATHER_API_KEY=your-key \
  -e DEBUG=true \
  weather-api:latest

# Test with docker-compose
echo "WEATHER_API_KEY=your-key" > .env
docker-compose up -d

# View logs
docker-compose logs -f weather-api

# Test the containerized API
curl -X POST http://localhost:8000/walker/get_weather \
  -H "Content-Type: application/json" \
  -d '{"city": "London"}'

# Check health
curl -X POST http://localhost:8000/walker/health_check \
  -H "Content-Type: application/json" \
  -d '{}'
```

---

## Kubernetes Deployment

Kubernetes provides orchestration, scaling, and reliability for production deployments.

### Kubernetes Manifests

!!! example "Complete Kubernetes Deployment"
    === "namespace.yaml"
        ```yaml
        # k8s/namespace.yaml
        apiVersion: v1
        kind: Namespace
        metadata:
          name: weather-app
          labels:
            app: weather-api
        ```

    === "configmap.yaml"
        ```yaml
        # k8s/configmap.yaml
        apiVersion: v1
        kind: ConfigMap
        metadata:
          name: weather-config
          namespace: weather-app
        data:
          DEBUG: "false"
          CACHE_TIMEOUT: "600"
          PORT: "8000"
        ```

    === "secret.yaml"
        ```yaml
        # k8s/secret.yaml
        apiVersion: v1
        kind: Secret
        metadata:
          name: weather-secrets
          namespace: weather-app
        type: Opaque
        data:
          weather-api-key: eW91ci1iYXNlNjQtZW5jb2RlZC1hcGkta2V5  # Base64 encoded
        ```

    === "deployment.yaml"
        ```yaml
        # k8s/deployment.yaml
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: weather-api
          namespace: weather-app
          labels:
            app: weather-api
        spec:
          replicas: 3
          selector:
            matchLabels:
              app: weather-api
          template:
            metadata:
              labels:
                app: weather-api
            spec:
              containers:
              - name: weather-api
                image: weather-api:latest
                ports:
                - containerPort: 8000
                env:
                - name: WEATHER_API_KEY
                  valueFrom:
                    secretKeyRef:
                      name: weather-secrets
                      key: weather-api-key
                envFrom:
                - configMapRef:
                    name: weather-config
                resources:
                  limits:
                    cpu: "1"
                    memory: "1Gi"
                  requests:
                    cpu: "500m"
                    memory: "512Mi"
                livenessProbe:
                  httpPost:
                    path: /walker/health_check
                    port: 8000
                    httpHeaders:
                    - name: Content-Type
                      value: application/json
                  initialDelaySeconds: 30
                  periodSeconds: 30
                readinessProbe:
                  httpPost:
                    path: /walker/health_check
                    port: 8000
                    httpHeaders:
                    - name: Content-Type
                      value: application/json
                  initialDelaySeconds: 5
                  periodSeconds: 10
        ```

    === "service.yaml"
        ```yaml
        # k8s/service.yaml
        apiVersion: v1
        kind: Service
        metadata:
          name: weather-api-service
          namespace: weather-app
        spec:
          selector:
            app: weather-api
          ports:
          - protocol: TCP
            port: 80
            targetPort: 8000
          type: ClusterIP
        ```

    === "ingress.yaml"
        ```yaml
        # k8s/ingress.yaml
        apiVersion: networking.k8s.io/v1
        kind: Ingress
        metadata:
          name: weather-api-ingress
          namespace: weather-app
          annotations:
            kubernetes.io/ingress.class: "nginx"
            nginx.ingress.kubernetes.io/rewrite-target: /
        spec:
          rules:
          - host: weather-api.yourdomain.com
            http:
              paths:
              - path: /
                pathType: Prefix
                backend:
                  service:
                    name: weather-api-service
                    port:
                      number: 80
        ```

### Deploying to Kubernetes

```bash
# Deploy everything in order
kubectl apply -f k8s/namespace.yaml
kubectl apply -f k8s/configmap.yaml

# Create secret with your actual API key
echo -n "your-actual-api-key" | base64
# Update secret.yaml with the base64 value
kubectl apply -f k8s/secret.yaml

kubectl apply -f k8s/deployment.yaml
kubectl apply -f k8s/service.yaml
kubectl apply -f k8s/ingress.yaml

# Check deployment status
kubectl get all -n weather-app

# Watch pods come online
kubectl get pods -n weather-app -w

# Check logs
kubectl logs -f deployment/weather-api -n weather-app

# Test the service
kubectl port-forward service/weather-api-service 8080:80 -n weather-app

# Test from another terminal
curl -X POST http://localhost:8080/walker/get_weather \
  -H "Content-Type: application/json" \
  -d '{"city": "Tokyo"}'
```

---

## Jac Cloud Deployment

Jac Cloud provides a Kubernetes-based deployment template to easily deploy your service into your cluster.

### Jac Cloud Setup

!!! example "Jac Cloud Deployment"
    === "Directory Structure"
        ```
        jac-cloud/
        â”œâ”€â”€ scripts/
        â”‚   â”œâ”€â”€ Dockerfile
        â”‚   â”œâ”€â”€ init_jac_cloud.sh
        â”‚   â””â”€â”€ jac-cloud.yml
        â””â”€â”€ weather_api.jac
        ```

    === "Prerequisites"
        ```bash
        # Prerequisites for Jac Cloud deployment
        # 1. Kubernetes cluster access
        kubectl cluster-info

        # 2. Docker for building images
        docker --version

        # 3. kubectl configured
        kubectl config current-context

        # 4. Target namespace should be created before deployment
        kubectl create namespace littlex

        # 5. Optional: OpenAI API key
        echo "OPENAI_API_KEY=your-key-here" > .env
        ```

    === "Build and Deploy"
        ```bash
        # 1. Build and push Docker image
        docker build -t your-dockerhub-username/jac-cloud:latest -f jac-cloud/scripts/Dockerfile .
        docker push your-dockerhub-username/jac-cloud:latest

        # 2. Update image reference in jac-cloud.yml
        sed -i 's|image: .*|image: your-dockerhub-username/jac-cloud:latest|' jac-cloud/scripts/jac-cloud.yml


        # 4. Deploy Jac Cloud application
        kubectl apply -f jac-cloud/scripts/jac-cloud.yml

        # 5. Verify deployment
        kubectl get all -n littlex
        ```

### Jac Cloud Configuration Files

!!! example "Complete Jac Cloud Configuration"
    === "jac-cloud.yml"
        ```yaml
        # jac-cloud/scripts/jac-cloud.yml
        apiVersion: v1
        kind: Namespace
        metadata:
          name: littlex
        ---
        apiVersion: v1
        kind: ServiceAccount
        metadata:
          name: jac-cloud-sa
          namespace: littlex
        ---
        apiVersion: rbac.authorization.k8s.io/v1
        kind: ClusterRole
        metadata:
          name: jac-cloud-role
        rules:
        - apiGroups: [""]
          resources: ["pods", "services", "configmaps"]
          verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]
        - apiGroups: ["apps"]
          resources: ["deployments"]
          verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]
        ---
        apiVersion: rbac.authorization.k8s.io/v1
        kind: ClusterRoleBinding
        metadata:
          name: jac-cloud-binding
        roleRef:
          apiGroup: rbac.authorization.k8s.io
          kind: ClusterRole
          name: jac-cloud-role
        subjects:
        - kind: ServiceAccount
          name: jac-cloud-sa
          namespace: littlex
        ---
        apiVersion: v1
        kind: Secret
        metadata:
          name: openai-secret
          namespace: littlex
        type: Opaque
        data:
          openai-key: eW91ci1iYXNlNjQtZW5jb2RlZC1rZXk=  # Replace with your base64 encoded key
        ---
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: jac-cloud
          namespace: littlex
        spec:
          replicas: 1
          selector:
            matchLabels:
              app: jac-cloud
          template:
            metadata:
              labels:
                app: jac-cloud
            spec:
              serviceAccountName: jac-cloud-sa
              containers:
              - name: jac-cloud
                image: your-dockerhub-username/jac-cloud:latest
                ports:
                - containerPort: 8000
                env:
                - name: NAMESPACE
                  value: "littlex"
                - name: FILE_NAME
                  value: "weather_api.jac"
                - name: OPENAI_API_KEY
                  valueFrom:
                    secretKeyRef:
                      name: openai-secret
                      key: openai-key
                volumeMounts:
                - name: config-volume
                  mountPath: /app/config
                resources:
                  limits:
                    cpu: "1"
                    memory: "2Gi"
                  requests:
                    cpu: "500m"
                    memory: "1Gi"
        ---
        apiVersion: v1
        kind: Service
        metadata:
          name: jac-cloud-service
          namespace: littlex
        spec:
          selector:
            app: jac-cloud
          ports:
          - protocol: TCP
            port: 80
            targetPort: 8000
          type: LoadBalancer
        ```

    === "Dockerfile"
        ```dockerfile
        # jac-cloud/scripts/Dockerfile
        FROM python:3.11-slim

        # Set working directory
        WORKDIR /app

        # Install system dependencies
        RUN apt-get update && apt-get install -y \
            curl \
            git \
            && rm -rf /var/lib/apt/lists/*

        # Install Jac and required packages
        RUN [Installation section removed - see Getting Started]
## Production Monitoring and Maintenance

### Enhanced Health Checks and Metrics

!!! example "Production-Ready Weather API"
    ```jac
    # production_weather.jac
    import from datetime { datetime }
    import from time { time }

    glob metrics = {
        "requests_total": 0,
        "requests_per_city": {},
        "cache_hits": 0,
        "cache_misses": 0,
        "start_time": time()
    };

    node WeatherData {
        has city: str;
        has temperature: float;
        has description: str;
        has last_updated: str;
    }

    walker get_weather {
        has city: str;

        can fetch_weather with `root entry {
            # Update metrics
            metrics["requests_total"] += 1;
            metrics["requests_per_city"][self.city] = metrics["requests_per_city"].get(self.city, 0) + 1;

            # Check cache first
            cached = [-->(`?WeatherData)](?city == self.city);

            if cached {
                metrics["cache_hits"] += 1;
                weather = cached[0];
                report {
                    "city": weather.city,
                    "temperature": weather.temperature,
                    "description": weather.description,
                    "cached": True
                };
            } else {
                metrics["cache_misses"] += 1;
                # Simulate external API call
                new_weather = WeatherData(
                    city=self.city,
                    temperature=22.5,
                    description="Sunny",
                    last_updated=datetime.now().isoformat()
                );
                here ++> new_weather;

                report {
                    "city": self.city,
                    "temperature": 22.5,
                    "description": "Sunny",
                    "cached": False
                };
            }
        }
    }

    walker health_check {
        can check_health with `root entry {
            uptime = time() - metrics["start_time"];
            cache_hit_rate = metrics["cache_hits"] / max(metrics["requests_total"], 1) * 100;

            report {
                "status": "healthy",
                "uptime_seconds": uptime,
                "total_requests": metrics["requests_total"],
                "cache_hit_rate_percent": round(cache_hit_rate, 2),
                "cached_cities": len([-->(`?WeatherData)]),
                "timestamp": datetime.now().isoformat()
            };
        }
    }

    walker metrics_endpoint {
        can get_metrics with `root entry {
            uptime = time() - metrics["start_time"];
            cache_hit_rate = metrics["cache_hits"] / max(metrics["requests_total"], 1) * 100;

            report {
                "uptime_seconds": uptime,
                "total_requests": metrics["requests_total"],
                "cache_hit_rate_percent": round(cache_hit_rate, 2),
                "requests_by_city": metrics["requests_per_city"],
                "timestamp": datetime.now().isoformat()
            };
        }
    }

    walker detailed_health_check {
        can comprehensive_health with `root entry {
            cached_cities = len([-->(`?WeatherData)]);
            memory_usage = "healthy";  # Simplified for demo

            # Check if service is responding normally
            status = "healthy";
            if metrics["requests_total"] == 0 and time() - metrics["start_time"] > 300 {
                status = "warning";  # No requests in 5 minutes
            }

            report {
                "status": status,
                "cached_cities": cached_cities,
                "total_requests": metrics["requests_total"],
                "memory_status": memory_usage,
                "uptime_seconds": time() - metrics["start_time"],
                "version": "1.0.0"
            };
        }
    }
    ```

### Scaling and Performance

```bash
# Manual scaling
kubectl scale deployment jac-cloud --replicas=3 -n littlex

# Horizontal Pod Autoscaler
kubectl apply -f - <<EOF
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: jac-cloud-hpa
  namespace: littlex
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: jac-cloud
  minReplicas: 1
  maxReplicas: 5
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
EOF

# Monitor scaling
kubectl get hpa -n littlex -w

# Load testing (using hey or similar)
hey -n 1000 -c 10 -m POST \
  -H "Content-Type: application/json" \
  -d '{"city":"London"}' \
  http://your-service-url/walker/get_weather

# Check resource usage during load test
kubectl top pods -n littlex
```

---

## Best Practices

!!! summary "Deployment Guidelines"
    - **Create namespaces beforehand**: Ensure target namespaces exist before deployment
    - **Monitor resource usage**: Track CPU and memory consumption for optimal scaling
    - **Secure API keys**: Use Kubernetes secrets for sensitive configuration
    - **Plan for module dependencies**: Configure dependencies correctly in the module configuration
    - **Test locally first**: Verify your JAC application works before deploying to the cloud
    - **Version your deployments**: Tag Docker images with specific versions for reproducible deployments
    - **Clean up resources**: Always clean up test deployments to avoid unnecessary costs

## Key Takeaways

!!! summary "What We've Learned"
    **Deployment Strategies:**

    - **Local development**: Same code runs everywhere without modifications
    - **Docker containerization**: Package applications for consistent deployment
    - **Kubernetes orchestration**: Production-grade scaling and reliability
    - **Jac Cloud integration**: Kubernetes-based deployment with built-in module management

    **Production Features:**

    - **Module management**: Dynamic loading of Python modules with resource control
    - **RBAC security**: Proper service accounts and role-based access control
    - **Health checks**: Monitor application health and readiness
    - **Resource management**: Control CPU and memory usage effectively
    - **Scaling strategies**: Manual and automatic scaling based on demand
    - **Configuration management**: Secure and flexible environment configuration

    **Monitoring and Maintenance:**

    - **Metrics collection**: Track application performance and usage
    - **Log aggregation**: Centralized logging for debugging and analysis
    - **Resource monitoring**: Track module resource usage and optimization
    - **Performance optimization**: Identify and resolve bottlenecks
    - **Troubleshooting tools**: Use kubectl commands for debugging deployments

    **Best Practices:**

    - **Infrastructure as Code**: Version control your deployment configurations
    - **Module optimization**: Configure appropriate resource limits for each module
    - **Security hardening**: Implement security best practices at every layer
    - **Namespace isolation**: Use dedicated namespaces for different environments
    - **Progressive deployment**: Test in staging before production rollout

!!! tip "Try It Yourself"
    Practice deployment by:
    - Setting up the Jac Cloud deployment with your own Docker registry
    - Experimenting with different module configurations and resource limits
    - Implementing comprehensive monitoring and alerting systems
    - Testing scaling behavior under different load conditions
    - Creating CI/CD pipelines for automated deployment workflows

    Remember: Jac Cloud provides a production-ready platform with built-in best practices for JAC applications!

---

*Ready to optimize performance? Continue to [Chapter 20: Performance Optimization](chapter_19.md)!*




================================================================================
FILE: docs/jac_book/chapter_4.md
================================================================================


# Chapter 4: A Deeper Look at Functions
---

In this chapter, we will explore the more advanced capabilities of functions in Jac. You will learn how Jac supports functional programming patterns, how to use functions as first-class citizens, and how to integrate AI directly into your function definitions. We will build a small math library to demonstrate these features in a practical context.

> In Jac, functions are treated as first-class citizens, meaning they can be stored in variables, passed as arguments to other functions, and returned from them, just like any other data type such as an integer or a string.

## Functional Programming in Jac
---
Functional programming is a style of writing software that treats computation as the evaluation of mathematical functions. While Jac is not a strict functional programming language, it provides strong support for functional programming concepts, enabling you to write more modular and expressive code.


### Function as First-Class Citizens
The core principle of functional programming is treating functions as first-class citizens. This means you can handle functions with the same flexibility as any other variable.

Let's revisit the calculator we built in Chapter 3. This time, we will redesign it using functional programming principles to make it more flexible and easier to extend.

First, we will create a single, generic `calculator` function. Instead of performing a specific operation like addition, this function will take an operation as one of its arguments.

```jac
# This function takes two numbers and another function as input.
# The `callable` type annotation indicates that `operation` is expected to be a function.
def calculator(a: float, b: float, operation: callable) -> float {
    return operation(a, b);
}
```
<br />

Next, we can define our basic arithmetic operations as standalone functions.

```jac
# These are the individual operations we can pass to our main calculator function.
def add(a: float, b: float) -> float {
    return a + b;
}

def subtract(a: float, b: float) -> float {
    return a - b;
}

def multiply(a: float, b: float) -> float {
    return a * b;
}
def divide(a: float, b: float) -> float {
    if b == 0 {
        raise ValueError("Cannot divide by zero");
    }
    return a / b;
}
```

Now, we can create a dictionary using `dict` keyword that maps a string (like "add") to the actual function object (like add). This allows us to select an operation dynamically using its name.


```jac
# A global dictionary to map operation names to their corresponding functions.
glob operations: dict[str, callable] = {
    "add": add,
    "subtract": subtract,
    "multiply": multiply,
    "divide": divide
};
```
<br />

Finally, let's put it all together. Our main execution block can now use the calculator function and the operations dictionary to perform calculations dynamically.

``` jac

# Main entry point for the program
with entry {
    a: float = 10.0;
    b: float = 5.0;

    # To test other operations, simply change this string.
    operation_name: str = "add";

    # Check if the requested operation exists in our dictionary.
    if operation_name in operations {
        # Look up the function in the dictionary and pass it to the calculator.
        selected_operation_func = operations[operation_name];
        result: float = calculator(a, b, selected_operation_func);
        print(f"Result of {operation_name}({a}, {b}) = {result}");
    } else {
        print(f"Operation '{operation_name}' is not supported.");
    }
}

```
This design is highly flexible. To add a new operation, like exponentiation, you would simply define a new `power` function and add it to the operations dictionary. You wouldn't need to change the core calculator logic at all. This demonstrates the power of treating functions as first-class data.

<br />


### Lambda Functions
In Jac, a lambda function is a concise, single-line, anonymous function. These are useful for short, specific operations where defining a full function with def would be unnecessarily verbose.

Lambda functions use the syntax lambda `lambda parameters: return_type: expression`. They can be assigned to a variable or used directly as an argument to another function.They are also useful for functional programming patterns like map, filter, and reduce.

For example, a simple add function can be defined as a lambda:

```jac
# This lambda takes two `float` parameters, `a` and `b`, and returns their sum as a `float`. It can be called just like a regular function.
add = lambda x: float, y: float: x + y;
```
<br />


```jac
with entry {
    add = lambda x: float, y: float: x + y;

    a: float = 10.0;
    b: float = 5.0;

    # Using the lambda function
    result: float = add(a, b);
    print(f"Result of add({a}, {b}) = {result}");
}
```
<br />

### Higher-Order Functions
A higher-order function is a function that either takes another function as an argument, returns a function, or both. This is a powerful concept that enables functional programming patterns, promoting code that is abstract, reusable, and composable.

The `callable` type hint is used to specify that a parameter or return value is expected to be a function.

```jac
# Higher-order function that applies operation to list
def apply_operation(numbers: list[float], operation: callable) -> list[float] {
    return [operation(num) for num in numbers];
}

# Function that creates specialized functions
def create_multiplier(factor: float) -> callable[[float], float] {
    return lambda x: float: x * factor;
}

# Function composition
def compose(f: callable, g: callable) -> callable {
    return lambda x: any: f(g(x));
}

with entry {
    print("=== Higher-Order Functions Demo ===");

    numbers = [1.0, 2.0, 3.0, 4.0, 5.0];

    # Create specialized multiplier functions
    triple = create_multiplier(3.0);
    quadruple = create_multiplier(4.0);

    # Apply operations
    tripled = apply_operation(numbers, triple);
    quadrupled = apply_operation(numbers, quadruple);

    print(f"Original: {numbers}");
    print(f"Tripled: {tripled}");
    print(f"Quadrupled: {quadrupled}");
}
```
<br />

### Built-in Higher-Order Functions `map`, `filter`, and `sorted`
Jac supports Python's essential built-in higher-order functions, which are powerful tools for working with lists and other collections without writing explicit loops.

### *filter*

The `filter` function constructs a new iterable from elements of an existing one for which a given function returns True.

Its signature is `filter(function, iterable)`.

Let's revisit our grade-filtering example from Chapter 3. Instead of a list comprehension, we can use filter with a lambda function to define our condition.


```jac
with entry {
    # Raw test scores
    test_scores: list = [78, 85, 92, 69, 88, 95, 72];

    # Get passing grades (70 and above)
    passing_scores: list = [score for score in test_scores if score >= 70];
    print(f"Passing scores: {passing_scores}");
}
```
<br />

The same result can be achieved using the `filter` function along with a lambda function to define the filtering condition.

```jac
with entry {
    test_scores: list[int] = [78, 85, 92, 69, 88, 95, 72];

    # The lambda `lambda score: bool: score >= 70` returns True for passing scores.
    # 'filter' applies this lambda to each item in 'test_scores'.
    passing_scores_iterator = filter(lambda score: float: score >= 70, test_scores);

    # The result of 'filter' is an iterator, so we convert it to a list to see the results.
    passing_scores: list[int] = list(passing_scores_iterator);
    print(f"Passing scores: {passing_scores}");
}
```
<br />


### *map*
The `map` function applies a given function to every item of an iterable and returns an iterator of the results.
Its signature is `map(function, iterable)`. This is ideal for transforming data without writing explicit loops.

```jac
def classify_grade(score: int) -> str {
    if score >= 90 {
        return "A";
    } elif score >= 80 {
        return "B";
    } elif score >= 70 {
        return "C";
    } elif score >= 60 {
        return "D";
    } else {
        return "F";
    }
}

with entry {
    # Raw test scores
    test_scores = [78, 85, 92, 69, 88, 95, 72];

    # Get passing grades (70 and above) using filter
    passing_scores = list(filter(lambda x: float: x >= 70, test_scores));
    print(f"Passing scores: {passing_scores}");

    # Get the grade of passing scores using map
    grades = list(map(classify_grade, passing_scores));
    print(f"Grades: {grades}");
}
```
<br />

### *sorted*
The `sorted` function returns a new sorted list from the items in an iterable. You can customize the sorting logic by providing a function to the `key` parameter.

```jac
with entry {
    # A list of tuples: (student_name, final_score)
    student_records: list[tuple[str, int]] = [("Charlie", 88), ("Alice", 95), ("Bob", 72)];

    # Sort alphabetically by name (the first item in each tuple).
    sorted_by_name = sorted(student_records, key=lambda record: str: record[0]);
    print(f"Sorted by name: {sorted_by_name}");

    # Sort numerically by score (the second item), in descending order.
    sorted_by_score = sorted(student_records, key=lambda record: int: record[1], reverse=True);
    print(f"Sorted by score (desc): {sorted_by_score}");
}
```
<br />



## Decorators for Enhanced Functionality
---
As your programs grow, you'll often need to add cross-cutting functionalityâ€”like logging, timing, or cachingâ€”to multiple functions. Modifying each function directly would be repetitive and error-prone. Decorators solve this problem by providing a clean way to wrap a function with extra behavior.

A decorator is a function that takes another function as an argument, adds some functionality, and returns a new function.


Consider the following example of a simple decorator that adds pre- and post-processing logic to a function.

The decorator function call `decorator_name` takes a function `func` as an argument and wraps it in a new function `wrapper` that adds additional behavior before and after calling the original function. The decorator returns the `wrapper` function, which is then used to replace the original function when the decorator is applied.

```jac
def decorator_name(func: callable) -> callable {
    def wrapper(*args: any, **kwargs: any) -> any {
        # Pre-processing logic
        result = func(*args, **kwargs);
        # Post-processing logic
        return result;
    }
    return wrapper;
}
```

!!! note
    `*args` is a python contruct that allows a function to accept a variable number of positional arguments, while `**kwargs` allows it to accept a variable number of keyword arguments.


Decorators provide a clean way to add functionality to functions without modifying their core logic. The general syntax for using decorators in Jac is:

```jac
@decorator_name
def function_name(parameters) -> return_type {
    # function body
}
```
<br />


### Decorator Stacking Order
You can apply multiple decorators to a single function. They are applied from the bottom up the decorator closest to the function definition is applied first.

```jac
import time;

def decorator_a(func: callable) -> callable {
    def wrapper(*args: any, **kwargs: any) -> any {
        print("Decorator A Start");
        result = func(*args, **kwargs);
        print("Decorator A End");
        return result;
    }
    return wrapper;
}

def decorator_b(func: callable) -> callable {
    def wrapper(*args: any, **kwargs: any) -> any {
        print("Decorator B Start");
        result = func(*args, **kwargs);
        print("Decorator B End");
        return result;
    }
    return wrapper;
}

# Decorator 'b' is applied first, then 'a' wraps 'b'.
@decorator_a
@decorator_b
def greet(name: str) -> None {
    print(f"Hello, {name}!");
}

with entry {
    greet("Alice");
}
```
<br />

The output will show that decorator B's "start" and "end" messages are nested inside decorator A's messages.

### Parameterized Decorators
For more flexibility, decorators can accept their own parameters. This requires an extra layer of nesting in the decorator function.

```jac
# This outer function takes the decorator's parameter.
def repeat(times: int) -> callable {
    # The second layer is the actual decorator.
    def decorator(func: callable) -> callable {
        # The third layer is the wrapper.
        def wrapper(*args: any, **kwargs: any) -> any {
            result: any;
            for i in range(times) {
                print(f"Execution {i+1} of {times}");
                result = func(*args, **kwargs);
            }
            return result;
        }
        return wrapper;
        }
    return decorator;
}

@repeat(3)
def say_hello(name: str) -> None {
    print(f"Hello, {name}");
}

with entry {
    say_hello("Bob");
}
```
<br />

This will print "Hello, Bob!" three times, as specified by the `@repeat(times=3)` parameter.

### Error Handling in Decorators

Decorators in Jac can handle exceptions, retry operations, and log errors gracefully.

```jac
import time;

def retry_decorator(max_retries: int, delay: float) -> callable {
    def decorator(func: callable) -> callable {
        def wrapper(*args: any, **kwargs: any) -> any {
            attempts: int = 0;
            while attempts < max_retries {
                try {
                    return func(*args, **kwargs);
                } except Exception as e {
                    attempts += 1;
                    print(f"Attempt {attempts} failed: {e}");
                    time.sleep(delay);
                }
            }
            raise Exception("Maximum retries exceeded");
        }
        return wrapper;
    }
    return decorator;
}

@retry_decorator(max_retries=3, delay=1.0)
def risky_operation() -> None {
    import random;
    if random.random() < 0.7 {
        raise ValueError("Random failure");
    }
    print("Operation succeeded!");
}

with entry {
    risky_operation();
}
```
<br />

### Timing Decorator
A timing decorator is a simple way to measure the performance of your functions.

```jac
import time;

# Timing decorator to measure function performance
def timing_decorator(func: callable) -> callable {
    def wrapper(*args: any, **kwargs: any) -> any {
        start_time = time.time();
        result = func(*args, **kwargs);
        end_time = time.time();
        execution_time = end_time - start_time;
        print(f"{func.__name__} executed in {execution_time} seconds");
        return result;
    }
    return wrapper;
}

# Apply timing to our math functions
@timing_decorator
def slow_fibonacci(n: int) -> int {
    if n <= 1 {
        return n;
    }
    return slow_fibonacci(n - 1) + slow_fibonacci(n - 2);
}

@timing_decorator
def slow_factorial(n: int) -> int {
    if n <= 1 {
        return 1;
    }
    return n * slow_factorial(n - 1);
}

with entry {
    print("=== Timing Decorator Demo ===");
    result1 = slow_fibonacci(2);
    print(f"Fibonacci(2) = {result1}");

    result2 = slow_factorial(3);
    print(f"Factorial(3) = {result2}");
}
```
<br />

### Caching (Memoization) Decorator
For functions that perform expensive calculations, a caching decorator can store results and return them instantly on subsequent calls with the same arguments. This technique is known as memoization.

```jac
import time;

# Timing decorator to measure function performance
def timing_decorator(func: callable) -> callable {
    def wrapper(*args: any, **kwargs: any) -> any {
        start_time = time.time();
        result = func(*args, **kwargs);
        end_time = time.time();
        execution_time = end_time - start_time;
        print(f"{func.__name__} executed in {execution_time} seconds");
        return result;
    }
    return wrapper;
}

# Caching decorator for expensive computations
def cache_decorator(func: callable) -> callable {
    cache: dict[str, any] = {};

    def wrapper(*args: any) -> any {
        # Create a simple cache key from arguments
        cache_key = str(args);

        if cache_key in cache {
            print(f"Cache hit for {func.__name__}{args}");
            return cache[cache_key];
        }

        print(f"Computing {func.__name__}{args}");
        result = func(*args);
        cache[cache_key] = result;
        return result;
    }
    return wrapper;
}

# Combine timing and caching decorators
@timing_decorator
@cache_decorator
def optimized_fibonacci(n: int) -> int {
    if n <= 1 {
        return n;
    }
    return optimized_fibonacci(n - 1) + optimized_fibonacci(n - 2);
}

@timing_decorator
@cache_decorator
def expensive_calculation(n: int) -> int {
    # Simulate expensive computation
    result = 0;
    for i in range(n * 1000) {
        result += i;
    }
    return result;
}

with entry {
    print("=== Cached Functions Demo ===");

    # First call - computed and cached
    result1 = optimized_fibonacci(3);
    print(f"Fibonacci(3) = {result1}");

    # Second call - retrieved from cache
    result2 = optimized_fibonacci(3);
    print(f"Fibonacci(3) again = {result2}");

    # Expensive calculation test
    result3 = expensive_calculation(10);
    print(f"Expensive calculation result: {result3}");

    # Second call to expensive calculation
    result4 = expensive_calculation(10);
    print(f"Expensive calculation again: {result4}");
}
```
<br />


## Async Functions
---
Some tasks, like network requests or reading large files, are I/O-bound. This means your program spends most of its time waiting for an external resource. During this waiting time, a standard program sits idle.

Jac's support for async functions allows your program to perform other work while it waits, leading to significant performance improvements for I/O-bound applications. This is known as concurrency.

- `async def`: Marks a function as a "coroutine"â€”a special function that can be paused and resumed.
- `await`: Pauses the execution of the current coroutine, allowing the program to work on other tasks until the awaited operation (e.g., a network call) is complete.

### Basic Async Functions

```jac
import asyncio;
import time;

# Async function for simulated API calls
async def fetch_data(source: str, delay: float) -> dict[str, any] {
    print(f"Starting to fetch from {source}...");
    await asyncio.sleep(delay);  # Simulate network delay

    return {
        "source": source,
        "data": f"Data from {source}",
        "timestamp": time.time()
    };
}

# Async function that processes multiple sources
async def gather_all_data() -> list[dict[str, any]] {
    # Run multiple async operations concurrently
    tasks = [
        fetch_data("API-1", 1.0),
        fetch_data("API-2", 0.5),
        fetch_data("API-3", 1.5)
    ];

    results = await asyncio.gather(*tasks);
    return results;
}

# Regular function that uses async
def run_async_example() -> None {
    print("=== Async Functions Demo ===");

    # Run the async function
    results = asyncio.run(gather_all_data());

    print("All data fetched:");
    for result in results {
        print(f"  {result['source']}: {result['data']}");
    }
}

with entry {
    run_async_example();
}
```
<br />

## Best Practices
---
- **Use descriptive names**: Function names should clearly indicate their purpose
- **Keep functions focused**: Each function should have a single, well-defined responsibility
- **Handle errors gracefully**: Use appropriate return types and exception handling
- **Leverage decorators**: Use decorators for cross-cutting concerns like timing and caching
- **Document with types**: Let type annotations serve as documentation
- **Consider async**: Use async functions for I/O-bound operations

## Wrapping Up
---

In this chapter, we looked at higher order functions, decorators, and async functions in Jac. We explored how to use these features to create flexible, reusable code that can handle complex operations efficiently.


*Ready to explore advanced AI operations? Continue to [Chapter 5: Advanced AI Operations](chapter_5.md)!*





================================================================================
FILE: docs/jac_book/chapter_5.md
================================================================================


# Chapter 5: Advanced AI Operations
---
In this chapter, you will learn to integrate advanced AI capabilities directly into your Jac applications using the byLLM (Meaning-Typed LLM) framework. We will build a multi-modal image analysis tool to demonstrate how Jac simplifies complex AI operations, including model configuration, context enhancement, and multi-modal data handling.


## byLLM Overview
---
byLLM (Meaning Typed LLM) is Jac's native AI integration framework. It transforms the way developers interact with Large Language Models by shifting from manual prompt engineering and complex API calls to a streamlined, function-based approach that is fully integrated with Jac's type system.


!!! success "byLLM Benefits"
    - **Zero Prompt Engineering**: Define function signatures, let AI handle implementation
    - **Type Safety**: AI functions integrate with Jac's type system
    - **Model Flexibility**: Switch between different AI models easily
    - **Multimodal Support**: Handle text, images, and audio seamlessly
    - **Built-in Optimization**: Automatic prompt optimization and caching

## Functions as Prompts
---
Up until this point, we've used Jac's functions to define behavior. However, what if we wanted to incorperate AI capabilities directly into our Jac applications? For example, lets say we're writing a poetry application that can generate poems based on a user supplied topic.

Since Jac is a super set of Python, we can create a function `write_poetry` that takes a topic as input and then make a call to an OpenAI model using its python or langchain library to generate the poem.

First, install the OpenAI Python package:
```bash
pip install openai
```
<br />
then set your OpenAI API key as an environment variable:

```bash
export OPENAI_API_KEY="your-api-key"
```
<br />
Now we can write our Jac code to integrate with OpenAI's API:

```jac
import from openai { OpenAI }

glob client = OpenAI();

""" Write a poem about topic """
def write_poetry(topic: str) -> str {
    response = client.responses.create(
        model="gpt-4.1-mini",
        input=f"Write a poem about {topic}."
    );
    return response.output_text;
}

with entry {
    poem = write_poetry("A serene landscape with mountains.");
    print(poem);
}
```
<br />

Finally, lets generate our poetic masterpiece by running the Jac code:
```console
$ jac run poetry.jac
Amidst the quiet, mountains rise,
Their peaks adorned with endless skies.
A tranquil breeze, a gentle stream,
Within this landscape, like a dream.

Soft whispers of the morning light,
Embrace the earth in pure delight.
A serene world, where hearts find peace,
In nature's hold, all worries cease.
```
<br />

Very nice! However, this approach requires manual API management (what if we want to switch to a different AI provider?), and we still have to write the prompt ourselves. Wouldn't it be great if we could just define the function signature and let the AI handle the rest? *Imagine a world where the function was the prompt?* Where we could simply declare a function and the AI would understand what to do? That's the power of byLLM.

Let's see how this works.

First we'll need to install the byLLM package:
```bash
pip install byllm
```
<br />
Next we replace the OpenAI import with that of the byLLM package

```jac
import from byllm { Model }
glob llm = Model(model_name="gpt-4.1-mini");
```
<br />
Instead of writing the function ourselves, we simply declare the function signature and use the `by` keyword to indicate that this function should be handled by the AI model referenced by `llm()`. The byLLM framework will automatically generate the appropriate prompt based on the function signature.
```jac
def write_poetry(topic: str) -> str by llm();
```

Finally, lets put it all together and run the Jac code:
```jac
# mt_poem.jac - Simple AI integration
import from byllm { Model }

glob llm = Model(model_name="gpt-4.1-mini");

""" Write a poem about topic """
def write_poetry(topic: str) -> str by llm();

with entry {
    poem = write_poetry("A serene landscape with mountains.");
    print(poem);
}
```
<br />


```console
$ jac run mt_poem.jac
Beneath the sky so vast and grand,
Mountains rise like ancient bands,
Whispers soft in tranquil air,
A serene landscape, calm and fair.

Colors blend in gentle hues,
Nature's brush with peaceful views,
Rivers sing and breezes dance,
In this quiet, soulâ€™s expanse.
```
<br />

### Simple Image Captioning Tool
To further illustrate byLLM's capabilities, let's build a simple image captioning tool. This tool will analyze an image and generate a descriptive caption using an AI model.

First lets grab an image from upsplash to work with. You can use any image you like, but for this example, we'll use a photo of a french bulldog. Download the image and save it as `photo.jpg` in the same directory as your Jac code.

![Image Captioning Example](../assets/photo.jpg){ width=300px }
/// caption
Photo by <a href="https://unsplash.com/@karsten116?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash">Karsten Winegeart</a> on <a href="https://unsplash.com/photos/a-french-bulldog-in-a-hoodie-and-gold-chain-GkpLfCRooCA?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash">Unsplash</a>
///

Next we'll make use of MLTLLM's `Image` function to handle image inputs. This function allows us to pass images directly to the AI model for analysis. We'll use OpenAI's `gpt-4o-mini` model for this task.

```jac
# image_captioning.jac - Simple Image Captioning Tool
import from byllm { Model, Image }

glob llm = Model(model_name="gpt-4o-mini");

"""Generate a detailed caption for the given image."""
def caption_image(image: Image) -> str by llm();

with entry {
    caption = caption_image(Image("photo.jpg"));
    print(caption);
}
```
<br />
Now we can run our Jac code to generate a caption for the image:
```console
$ jac run image_captioning.jac

A stylish French Bulldog poses confidently against a vibrant yellow backdrop,
showcasing its trendy black and yellow hoodie emblazoned with "WOOF." The pup's
playful demeanor is accentuated by a shiny gold chain draped around its neck,
adding a touch of flair to its outfit. With its adorable large ears perked up
and tongue playfully sticking out, this fashion-forward canine is ready to steal
the spotlight and capture hearts with its charm and personality.
```
<br />

## Model Declaration and Configuration
---
byLLM supports various AI models through the unified `Model` interface. For example, you can load multiple models like OpenAI's GPT-4, Google's Gemini, or any other compatible model in the same way. This allows you to switch between models easily without changing your code structure.

```jac
# basic_setup.jac
import from byllm { Model, Image }

# Configure different models
glob text_model = Model(model_name="gpt-4o");
glob vision_model = Model(model_name="gpt-4-vision-preview");
glob gemini_model = Model(model_name="gemini-2.0-flash");
```
<br />

### Model Configuration Options
The `Model` class allows you to configure various parameters for your AI model, such as temperature, max tokens, and more. Here's an example of how to set up a model with custom parameters:

```jac
import from byllm { Model, Image }

# Configure model with custom parameters
glob creative_model = Model(
    model_name="gpt-4.1-mini",
    temperature=0.9,  # More creative
    max_tokens=500,
    verbose=True      # Show prompts for debugging
);
```
<br />
Below is a breakdown of the parameters you can configure when creating a `Model` instance:

| Parameter         | Purpose / Description                                                                                      | Default Value / Example                     |
|-------------------|-----------------------------------------------------------------------------------------------------------|---------------------------------------------|
| `model`           | Specifies the name of the language model to use (e.g., "gpt-3.5-turbo", "claude-3-sonnet-20240229").      | Required (set during initialization)        |
| `api_base`        | Sets the base URL for the API endpoint. Used to override the default endpoint for the model provider.      | Optional                                   |
| `messages`        | List of formatted message objects (system/user/assistant) for the LLM prompt.                             | Required (built from function call context) |
| `tools`           | List of tool definitions for function/tool calls the LLM can invoke.                                       | Optional                                   |
| `response_format` | Specifies the output schema or format expected from the model (e.g., JSON schema, plain text).             | Optional                                   |
| `temperature`     | Controls randomness/creativity of the model output (higher = more random).                                 | 0.7 (if not explicitly set)                 |
| `max_tokens`      | Maximum number of tokens in the generated response. (Commented out; can be enabled)                        | 100 (if enabled and not set)                |
| `top_k`           | Limits sampling to the top K probable tokens. (Commented out; can be enabled)                              | 50 (if enabled and not set)                 |
| `top_p`           | Controls token selection by probability sum (nucleus sampling). (Commented out; can be enabled)            | 0.9 (if enabled and not set)                |

Here we have a simple example of how to use the `Model` class to create a model instance with custom parameters:
```jac
# model_config.jac
import from byllm { Model, Image }

# Configure model with custom parameters
glob creative_model = Model(
    model_name="gpt-4.1-mini",
    temperature=0.9,  # More creative
    max_tokens=500,
    verbose=True      # Show prompts for debugging
);

glob precise_model = Model(
    model_name="gpt-4.1-mini",
    temperature=0.1,  # More deterministic
    max_tokens=200
);

"""Generate creative story from image."""
def create_story(image: Image) -> str by creative_model();

"""Extract factual information from image."""
def extract_facts(image: Image) -> str by precise_model();


with entry {
    # Example usage
    story = create_story(Image("photo.jpg"));
    print("Creative Story:", story);

    facts = extract_facts(Image("photo.jpg"));
    print("Extracted Facts:", facts);
}
```
<br />



## Updating the Image Captioning Tool
---
Let's progressively build an image captioning tool that demonstrates byLLM's capabilities.

```jac
# image_captioner.jac
import from byllm { Model, Image }

glob vision_llm = Model(model_name="gpt-4o-mini");

obj ImageCaptioner {
    has name: str;

    """Generate a brief, descriptive caption for the image."""
    def generate_caption(image: Image) -> str by vision_llm();

    """Extract specific objects visible in the image."""
    def identify_objects(image: Image) -> list[str] by vision_llm();

    """Determine the mood or atmosphere of the image."""
    def analyze_mood(image: Image) -> str by vision_llm();
}

with entry {
    captioner = ImageCaptioner(name="AI Photo Assistant");
    image = Image("photo.jpg");

    # Generate basic caption
    caption = captioner.generate_caption(image);
    print(f"Caption: {caption}");

    # Identify objects
    objects = captioner.identify_objects(image);
    print(f"Objects found: {objects}");

    # Analyze mood
    mood = captioner.analyze_mood(image);
    print(f"Mood: {mood}");
}
```
<br />

```console
$ jac run image_captioner.jac

Caption: A stylish French Bulldog poses confidently in a black and yellow "WOOF" sweatshirt,
accessorized with a chunky gold chain against a vibrant yellow backdrop.

Objects found: ['dog', 'sweater', 'chain', 'yellow background']

Mood: The mood of the image is playful and cheerful. The bright yellow background and
the stylish outfit of the dog contribute to a fun and lighthearted atmosphere.
```
<br />

## Semantic Strings and Context Enhancement
---
**Semantic strings** provide additional context to AI functions via the `sem` keyword, allowing for more nuanced understanding without cluttering your code. They're particularly useful for domain-specific applications.

```jac
# enhanced_captioner.jac
import from byllm { Model, Image }

glob vision_llm = Model(model_name="gpt-4.1-mini");

obj PhotoAnalyzer {
    has photographer_name: str;
    has style_preference: str;
    has image: Image;
}

# Add semantic context for better AI understanding
sem PhotoAnalyzer = "Professional photo analysis tool for photographers";
sem PhotoAnalyzer.photographer_name = "Name of the photographer for personalized analysis";
sem PhotoAnalyzer.style_preference = "Preferred photography style (artistic, documentary, commercial)";


"""Generate caption considering photographer's style preference."""
def generate_styled_caption(pa: PhotoAnalyzer) -> str by vision_llm();

"""Provide technical photography feedback."""
def analyze_composition(pa: PhotoAnalyzer) -> list[str] by vision_llm();

"""Suggest improvements for the photo."""
def suggest_improvements(pa: PhotoAnalyzer) -> list[str] by vision_llm();


with entry {
    analyzer = PhotoAnalyzer(
        photographer_name="Alice",
        style_preference="artistic",
        image=Image("photo.jpg")
    );

    # Generate styled caption
    caption = generate_styled_caption(analyzer);
    print(f"Styled caption: {caption}");

    # Analyze composition
    composition = analyze_composition(analyzer);
    print(f"Composition analysis: {composition}");

    # Get improvement suggestions
    suggestions = suggest_improvements(analyzer);
    print(f"Suggestions: {suggestions}");
}
```
<br />

## Testing and Error Handling
---
AI applications require robust error handling and testing strategies.

### Robust AI Integration

```jac
# robust_ai.jac
import from byllm { Model, Image }

glob reliable_llm = Model(model_name="gpt-4o", max_tries=3);

obj RobustCaptioner {
    has fallback_enabled: bool = True;

    """Generate caption with error handling."""
    def safe_caption(image_path: str) -> dict {
        try {
            caption = self.generate_caption_ai(image_path);
            return {
                "success": True,
                "caption": caption,
                "source": "ai"
            };
        } except Exception as e {
            if self.fallback_enabled {
                fallback_caption = f"Image analysis unavailable for {image_path}";
                return {
                    "success": False,
                    "caption": fallback_caption,
                    "source": "fallback",
                    "error": str(e)
                };
            } else {
                raise e;
            }
        }
    }

    """AI-powered caption generation."""
    def generate_caption_ai(image_path: str) -> str by reliable_llm();

    """Validate generated content."""
    def validate_caption(caption: str) -> bool {
        # Basic validation rules
        if len(caption) < 10 {
            return False;
        }
        if "error" in caption.lower() {
            return False;
        }
        return True;
    }
}

with entry {
    captioner = RobustCaptioner(fallback_enabled=True);

    # Test with different scenarios
    test_images = [
        Image("valid_photo.jpg"),
        Image("corrupted.jpg"),
        Image("missing.jpg")
    ];

    for image in test_images {
        result = captioner.safe_caption(image);

        if result["success"] {
            is_valid = captioner.validate_caption(result["caption"]);
            print(f"{image}: {result['caption']} (Valid: {is_valid})");
        } else {
            print(f"{image}: Failed - {result['error']}");
        }
    }
}
```
<br />

## Best Practices
---
!!! tip "AI Development Guidelines"
    - **Start Simple**: Begin with basic AI functions, add complexity gradually
    - **Use Semantic Strings**: Provide context without cluttering function signatures
    - **Handle Failures**: Always implement fallback strategies for AI functions
    - **Test Thoroughly**: AI outputs can be unpredictable, test with various inputs
    - **Optimize Models**: Choose appropriate models and parameters for your use case

## Key Takeaways

!!! summary "What We've Learned"
    **byLLM Integration:**

    - **Simple AI Functions**: Define AI capabilities with `by llm()` syntax
    - **Model Configuration**: Flexible model selection and parameter tuning
    - **Type Safety**: AI functions integrate seamlessly with Jac's type system
    - **Zero Prompt Engineering**: Function signatures become prompts automatically

    **Advanced Features:**

    - **Semantic Context**: Enhanced AI understanding through semantic strings
    - **Multimodal Support**: Seamless handling of images, text, and audio
    - **Error Handling**: Robust patterns for production AI applications
    - **Model Selection**: Easy switching between different AI providers and models

    **Practical Applications:**

    - **Content Generation**: Automated text and media analysis
    - **Data Processing**: Intelligent data transformation and extraction
    - **API Integration**: Direct AI integration without complex setup
    - **Scalable Architecture**: AI functions work in both local and cloud deployments

!!! tip "Try It Yourself"
    Enhance the image captioning tool by adding:
    - Batch processing for multiple images
    - Integration with cloud storage services
    - Custom model fine-tuning capabilities
    - Real-time image analysis from camera feeds

    Remember: AI functions in Jac are as easy to use as regular functions, but with the power of Large Language Models!

---

If you are interested in learning more about byLLM, check out [ Quickstart to byLLM ](../learn/jac-byllm/with_llm.md)

*Ready to learn about imports and modular programming? Continue to [Chapter 6: Imports System and File Operations](chapter_6.md)!*




================================================================================
FILE: docs/jac_book/chapter_7.md
================================================================================


# Chapter 7: Enhanced OOP - Objects and Classes
---

Jac fully supports the principles of Object-Oriented Programming (OOP) but enhances them to be more intuitive and efficient. This chapter will guide you through using Jac's obj archetype to create well-structured, maintainable, and powerful objects.

Jac simplifies the object creation process by providing features like **automatic constructors**, **implementation separation**, and **improved access control**, which reduce boilerplate code and allow you to focus more on the logic of your application.


## Jac `obj` Archetype
---

In Jac, you define a blueprint for an object using the `obj` archetype, which serves a similar purpose to the class keyword in Python. An `obj` bundles data (attributes) and behavior (methods) into a single, self-contained unit.

Let's define a `Pet` object to see how this works.

```jac
obj Pet {
    # 1. Define attributes with the 'has' keyword.
    has name: str;
    has species: str;
    has age: int;
    has is_adopted: bool = False;  # Automatic default

    # 2. Define methods with the 'def' keyword.
    # Methods use 'self' to access the object's own attributes.
    def adopt() -> None {
        self.is_adopted = True;
        print(f"{self.name} has been adopted!");
    }

    def get_info() -> str {
        status = "adopted" if self.is_adopted else "available";
        return f"{self.name} is a {self.age}-year-old {self.species} ({status})";
    }
}

with entry {
    # 3. Create an instance using the automatic constructor.
    pet = Pet(name="Buddy", species="dog", age=3);
    print(pet.get_info());
    pet.adopt();
}
```
<br />

Let's break down the key features demonstrated in this example.

1. Defining Attributes with `has`: The `has` keyword is used to declare the data fields (attributes) that each Pet object will hold. You must provide a type for each attribute, and you can optionally set a default value, like `is_adopted: bool = False`.
2. The Automatic Constructor: Notice that we did not have to write an __init__ method. Jac automatically generates a constructor for you based on the attributes you declare with has. This saves you from writing repetitive boilerplate code and allows you to create a new Pet instance with a clean and direct syntax: `Pet(name="Buddy", species="dog", age=3)`.


### Advanced Constructor Features

Sometimes, you need to run logic after an object's initial attributes have been set. For this, Jac provides the `postinit` method. This is useful for calculated properties or for validation that depends on multiple attributes.
To use it, you declare an attribute with the by `postinit` modifier. This signals that the attribute exists, but its value will be assigned within the `postinit` method.
Let's enhance our pet shop example. We'll create a PetShop object and use `postinit` to automatically set its is_open status based on whether it has reached its capacity.


```jac
obj PetShop {
    # Attributes set by the automatic constructor
    has name: str;
    has pets: list[Pet] = [];
    has capacity: int = 10;
    # This attribute's value will be calculated after initialization.
    has is_open: bool by postinit;

     # This method runs automatically after the object is created
    def postinit() -> None {
        # This logic determines the value of 'is_open'.
        self.is_open = len(self.pets) < self.capacity;
        print(f"{self.name} shop initialized with {len(self.pets)} pets");
    }
}
```
<br />

## Object Inheritance
---
Inheritance is a fundamental concept in OOP that allows you to create a new, specialized object based on an existing one. The new object, or subclass, inherits all the attributes and methods of the parent object, and can add its own unique features or override existing ones. This promotes code reuse and helps create a logical hierarchy.

### Simple Inheritance Example

```jac
obj Animal {
    has name: str;
    has species: str;
    has age: int;

    def make_sound() -> None {
        print(f"{self.name} makes a sound.");
    }
}
# A subclass that inherits from Animal
obj Dog(Animal) {
    has breed: str;

    def make_sound() -> None {
        print(f"{self.name} barks.");
    }
}

obj Cat(Animal) {
    has color: str;

    def make_sound() -> None {
        print(f"{self.name} meows.");
    }
}
```
<br />
In this example, both `Dog` and `Cat` automatically have the `name`, `species`, and `age` attributes from Animal. However, they each provide a specialized version of the `make_sound` method, demonstrating polymorphism.

## Access Control with `:pub`, `:priv`, `:protect`
---
To create robust and secure objects, it is important to control which of their attributes and methods can be accessed from outside the object's own code. This principle is called encapsulation. Unlike Python, Jac provides explicit keywords that are enforced by the runtime.

### Public Access
Public members are accessible from anywhere. This is the default behavior in Jac, so the `:pub` keyword is optional but can be used for clarity.

```jac
obj PublicExample {
    # This attribute is public by default.
    has :pub public_property: str;

    # Explicitly marking a method as public.
    def :pub public_method() -> str {
        return "This is a public method";
    }
}
with entry {
    example = PublicExample(public_property="Hello");
    # Both are accessible from outside the object.
    print(example.public_method());
    print(example.public_property);
}
```
<br />

### Private Access
Private members, marked with `:priv`, can only be accessed from within the object itself. Any attempt to access a private member from outside code will result in an error. This is essential for protecting an object's internal state.

```jac
obj PrivateExample {
    has :priv private_property: str;
    has :priv another_private_property: int = 42;

    def :priv private_method() -> str {
        return "This is a private method";
    }

    def :pub public_method() -> str {
        return self.private_method();
    }
}
with entry {
    example = PrivateExample(private_property="Secret");
    print(example.public_method());
    # print(example.private_property);  # This would raise an error
}
```
<br />

### Protected Access
Protected members, marked with `:protect`, create a middle ground between public and private. They are accessible within the object that defines them and within any of its subclasses. This is useful for creating internal logic that you want to share across a family of related objects but still keep hidden from the outside world.

```jac
obj ProtectedExample {

    has :protect protected_property: str = "Protected";
    has :protect protected_list: list[int] = [];
    has :protect protected_dict: dict[str, int] = {"key": 1};

    def :protect protected_method() -> str {
        return "This is a protected method";
    }
}
obj SubProtectedExample(ProtectedExample) {
    def :pub public_method() -> str {
        return self.protected_method();
    }
}
with entry {
    example = SubProtectedExample();
    print(example.public_method());
    print(example.protected_property);
    print(example.protected_list);
    print(example.protected_dict);
}
```
<br />


### Example: Pet Record System

Let's combine these access control concepts into a practical example. We will build a `PetRecord` object that securely manages a pet's information.

- Public information, like the pet's name, will be freely accessible.
- Protected information, like medical history, will be accessible only to specialized subclasses like a VetRecord.
- Private information, like the owner's contact details, will be strictly controlled by the object itself.


<div class="code-block">
```jac
obj PetRecord {
    # Public - anyone can access
    has :pub name: str;
    has :pub species: str;

    # Private - only this class
    has :priv owner_contact: str;
    has :priv microchip_id: str;

    # Protected - only this class and subclasses
    has :protect medical_history: list[str] = [];
    has :protect last_checkup: str = "";

    # Public method
    def :pub get_basic_info() -> str {
        return f"{self.name} is a {self.species}";
    }

    # Protected method - for vets and staff
    def :protect add_medical_record(record: str) -> None {
        self.medical_history.append(record);
        print(f"Medical record added for {self.name}");
    }

    # Private method - internal use only
    def :priv validate_contact(contact: str) -> bool {
        return "@" in contact and len(contact) > 5;
    }

    def :pub update_owner_contact(new_contact: str) -> bool {
        if self.validate_contact(new_contact) {
            self.owner_contact = new_contact;
            return True;
        }
        return False;
    }
}

obj VetRecord(PetRecord) {
    has :protect vet_notes: str = "";

    def :pub add_vet_note(note: str) -> None {
        # Can access protected members from parent
        self.add_medical_record(f"Vet note: {note}");
        self.vet_notes = note;
    }

    def :pub get_medical_summary() -> str {
        # Can access protected data
        record_count = len(self.medical_history);
        return f"{self.name} has {record_count} medical records";
    }
}

with entry {
    # Create a pet record
    pet = PetRecord(
        name="Fluffy",
        species="cat",
        owner_contact="owner@example.com",
        microchip_id="123456789"
    );

    # Public access works
    print(pet.get_basic_info());
    print(f"Pet name: {pet.name}");

    # Update contact through public method
    success = pet.update_owner_contact("new_owner@example.com");
    print(f"Contact updated: {success}");

    # Vet record with access to protected methods
    vet_record = VetRecord(
        name="Rex",
        species="dog",
        owner_contact="owner2@example.com",
        microchip_id="987654321"
    );

    vet_record.add_vet_note("Annual checkup - healthy");
    print(vet_record.get_medical_summary());
}
```
</div>
<br />



## Key Differences from Python OOP
- **Automatic Constructors**: No need to write `__init__` methods
- **Enforced Access Control**: `:pub`, `:priv`, `:protect` are actually enforced
- **Clean Inheritance**: Automatic constructor chaining in inheritance
- **Type Safety**: All method parameters and returns must be typed
- **Implementation Separation**: Can separate interface from implementation


## Wrapping Up
---

In this chapter, you've learned how Jac builds upon classic Object-Oriented Programming with features that promote cleaner, safer, and more maintainable code. You now have the tools to create robust, well-structured objects with automatic constructors, enforced access control, and clear inheritance.

These concepts form the foundation upon which Jac's most powerful paradigm is built. In the next chapter, we will make the leap from Object-Oriented to Object-Spatial Programming (OSP). We will see how these objects are extended into nodes that can exist in a graph, giving them a spatial context and unlocking a new way to handle complex, interconnected data.

---

*You now have powerful object-oriented tools at your disposal. Let's discover how OSP takes these concepts to the next level!*




================================================================================
FILE: docs/jac_book/chapter_8.md
================================================================================


# Chapter 8: OSP Introduction and Paradigm Shift
---
So far, we have explored Jac's enhancements to familiar programming concepts. Now, we will introduce the paradigm that makes Jac truly unique, Object-Spatial Programming (OSP). This represents a fundamental shift in how we structure and execute our programs.

In traditional programming, the application logic is stationary, and data is constantly fetched from databases and other services to be processed. OSP inverts this model, it allows your computation to travel to where your data lives. This approach is more natural, efficient, and scalable for the interconnected data that defines modern AI applications.

## Journey from OOP to OSP
---
The transition from Object-Oriented Programming to Object-Spatial Programming begins with understanding how Jac perceives your program's structure.

### `with entry` vs `if __name__ == "__main__":`

In Python, the entry point of a program is typically defined by the `if __name__ == "__main__":` block. This tells the interpreter, "Start running the script from here."

Jac's `with entry` block serves a similar purpose but has a deeper, more powerful meaning. It isn't just starting a script, it is your moment of entry into a persistent, spatial environment. Think of it as opening the door to a workshop. When your program starts, this workshop is not empty; it contains a single, special starting point: the `root` node. We're entering the root of a global graph structure that we can build upon and traverse.

![With Entry](../assets/examples/jac_book/with_entry.png){ width=350px }

`with entry` marks your entry point into the program's graph. This graph initially contains only the root node, which serves as the anchor for everything you will build.


Everything you create and connect within this graph space can be persisted, traversed, and reasoned about spatially.

### Creating a Node and adding it to the Graph

When the `with entry` block is executed, it creates a root node in the Jac graph. From there, we can add nodes` and `edges` to build our data structure. Lets look at an example of creating a simple node using Jac's syntax:

```jac
node Node{
    has name: str;
}

with entry {
    node_a = Node(name="A");
}
```
<br />

![With Entry](../assets/examples/jac_book/node1.png){ width=350px }


Here, we define a node using the `node` keyword, which is similar to defining a class in traditional OOP. The `has` keyword declares properties for the node, and we create an instance of this node within the `with entry` block.

### Connecting Nodes with Edges

When the entry point is executed, it creates a root node on the Jac graph, which can be accessed using the `root` variable. This root node serves as the starting point for the program's graph structure, enabling traversal and manipulation of connected nodes.

In the example above, we create a new node `node_a` with the name "A". However, this node is not automatically part of the graphâ€”it exists in isolation. To incorporate it into the graph, we need to connect it to an existing node using an `edge`.

This is where the `++>` operator comes in. It creates a directional edge from the root node to `node_a`, effectively linking the two and adding `node_a` into the graph.

```jac
node Node{
    has name: str;
}

with entry {
    node_a = Node(name="A");
    root ++> node_a;  # Add node_a to the root graph
}
```
<br />

![With Entry](../assets/examples/jac_book/node2.png){ width=350px }


### Building out the rest of the Graph

Now that we have a basic understanding of nodes and edges, let's add a few more nodes and edges to create a more complex graph structure. We'll introduce a second node and connect it to the first one:

```jac
node Node{
    has name: str;
}

with entry {
    node_a = Node(name="A");
    node_b = Node(name="B");

    root ++> node_a;  # Add node_a to the root graph
    node_a ++> node_b;  # Connect node_a to node_b
}
```
<br />

Next let's define a terminal node that will represent the end of our graph traversal. This node will not have any outgoing edges, indicating that it is a leaf node in our graph structure:

```jac
node EndNode {}
glob END = EndNode();  # Create a global end node
```
<br />

Now we can connect our nodes to this end node, creating a complete graph structure:
```jac
node Node{
    has name: str;
}
node EndNode {}
glob END = EndNode();

with entry {
    node_a = Node(name="A");
    node_b = Node(name="B");

    root ++> node_a;  # Add node_a to the root graph
    node_a ++> node_b;  # Connect node_a to node_b
    node_b ++> END;  # Connect node_b to the end node
}
```
<br />

![With Entry](../assets/examples/jac_book/node3.png){ width=350px }

## From "Data to Computation" to "Computation to Data"


### Walking the Graph

In Object-Oriented Programming, your objects are stationary. You call a method on an object, and the logic executes within that object's context.

One of the core innovations of Object-Spatial Programming (OSP) is the concept of **walkers**. A walker is a mobile unit of computation that you design to travel through your graph, moving from node to node along the edges that connect them. Instead of pulling data to your logic, a walker brings your logic directly to the data.

Walkers operate **locally**, performing actions at each node or edge they encounter. This enables a more natural and efficient way to process distributed data, especially in systems modeled as networks, hierarchies, or flows.


Walkers are more than simple graph crawlers. Because they are a subtype of the `object` archetype, they can,

- Maintain State: A walker can have its own attributes (has fields) to store information it collects during its journey.
- Execute Logic: A walker has methods (can abilities) that are automatically triggered when it "lands on" a specific type of node or edge.
- Make Decisions: Based on the data it finds at its current location, a walker can decide where to go next.

This paradigm shiftâ€”from centralized logic to distributed, mobile computationâ€”is what makes OSP so powerful for modeling complex, real-world systems.


Getting back to our graph structure, lets define a simple walker that will traverse our graph and gather the names of the nodes it visits. When it reaches the terminal node, it will stop and return the collected names as a string:

First, we need to enhance our graph with a starting and ending point.

```jac
node Node {
    has name: str;
}

# A special node to mark the end of a path.
node EndNode {}

# Our full graph structure
with entry {
    # Spawn nodes and attach them to the graph.
    node_a = root ++> Node(name="A");
    node_b = node_a ++> Node(name="B");
    node_c = node_b ++> Node(name="C");
    end_node = node_c ++> EndNode(); # The path ends here.
}
```

Next we define our walker archetype, that has a `input` field to store the names of the nodes it visits:
```jac
walker PathWalker {
    has input: str;
}

walker PathWalker {
    has input: str;

    # 1. The starting point for the walker's journey.
    can start with `root entry {
        # Start visiting nodes connected to the root.
        visit [-->];
    }

    # 2. This ability triggers every time the walker lands on a 'Node'.
    can visit_node with Node entry {
        # 'here' refers to the node the walker is currently on.
        self.input += ", visiting " + here.name;  # Append node name to input
        # Continue to the next node in the path.
        visit [-->];
    }

    # 3. This ability triggers when the walker reaches the 'EndNode'.
    can visit_end with EndNode entry {
        self.input += ", reached the end";  # Append end message
        return;  # Stop visiting
    }
}
```
<br />

### The `visit` Statement and `-->` Syntax

To understand how walkers move through the graph, it's important to break down the `visit` statement and the `-->` operator used in the example above.

In Jac, visit tells the walker to continue its traversal along the graph. What makes this powerful is the use of edge selectors inside the square brackets, like `[-->]`, which control how and where the walker moves.

The `-->` symbol represents a forward edge in the graphâ€”specifically, an edge from the current node (`here`) to any of its connected child nodes. So when you write visit `[-->];`, you're instructing the walker to follow all outgoing edges from the current node to the next set of reachable nodes.

Let's walk through what each part means:

- `visit [-->];`: Move the walker along all forward edges from the current node.
- `visit [<--];`: Move backward (along incoming edges), useful for reverse traversals or backtracking.
- `visit [-->-->];`: Move along two forward edges in succession, allowing for deeper traversal into the graph.

Jac supports more complex edge selectors as well which we'll explore in subsequent chapters. For now, the key takeaway is that `visit` combined with edge selectors allows walkers to navigate the graph structure dynamically, processing nodes and edges as they go.


### Putting it All Together

Lets put everything together in a complete example that demonstrates how to create a graph, define a walker, and run it to collect node names:

```jac
node Node{
    has name: str;
}

node EndNode {}
glob END = EndNode();

walker PathWalker {
    has input: str;

    can start with `root entry {
        visit [-->];
    }

    can visit_node  with Node entry{
        self.input += ", visiting " + here.name;
        visit [here-->];
    }

    can visit_end with EndNode entry {
        self.input += ", reached the end";
        return;
    }
}

with entry {
    root ++> Node(name="A")
         ++> Node(name="B")
         ++> END;

    my_walker = PathWalker(input="Start walking") spawn root;

    print(my_walker.input);
}
```
<br />

```bash
$ jac run path_walker.jac
Start walking, visiting A, visiting B, reached the end
```
<br />


## Wrapping Up

In this chapter, we've introduced the core concepts of Object-Spatial Programming (OSP) and how it differs from traditional object-oriented programming. We've seen how Jac allows us to define nodes and edges, create walkers, and traverse graphs in a way that naturally reflects the relationships between data.


## Key Takeaways


- **Computation to data**: Move processing to where data naturally lives
- **Spatial relationships**: Model connections as first-class graph structures
- **Natural representation**: Express real-world relationships directly in code
- **Distributed processing**: Each data location can be processed independently

**Core Concepts:**

- **Nodes**: Stateful entities that hold data and can react to visitors
- **Edges**: First-class relationships with their own properties and behaviors
- **Walkers**: Mobile computation that traverses and processes graph structures
- **Graph thinking**: Shift from object-oriented to relationship-oriented design

**Key Advantages:**

- **Intuitive modeling**: Problems are expressed in their natural graph form
- **Efficient processing**: Computation happens exactly where it's needed
- **Scalable architecture**: Naturally distributes across multiple nodes
- **Maintainable code**: Clear separation of data, relationships, and processing logic


!!! tip "Try It Yourself"
    Start thinking spatially by modeling:
    - Family trees with person nodes and relationship edges
    - Social networks with user connections
    - Organization charts with employee and department relationships
    - Knowledge graphs with concept connections

    Remember: OSP shines when your problem naturally involves connected data!

---

*You've now grasped the fundamental paradigm shift of OSP. Let's build the foundation with nodes and edges!*




================================================================================
FILE: docs/jac_book/chapter_9.md
================================================================================


# Chapter 9: Nodes and Edges
---

In Object-Spatial Programming, **nodes** and **edges** are the fundamental building blocks of your application's graph. A node represents an entity or a location for your data, while an edge represents a typed, directional relationship between two nodes.
This chapter will show you how to define these core components and how to give your nodes special abilities, allowing them to interact with the walkers that visit them.


## Node Abilities
---
So far, we have seen how walkers can be programmed with intelligence to traverse a graph and collect information. But in Jac, nodes are not just passive data containers. They can have their own abilitiesâ€”methods that are specifically designed to trigger when a certain type of walker arrives.
This two-way dynamic enables powerful, flexible interactions between walkers and the graph they explore.

### Usecase: Uninformed State Agent
Imagine you have a generic agent, a StateAgent, whose job is to collect information about its environment. This agent knows nothing in advance about the types of nodes it will encounter. In a traditional program, this would be difficult; how can code act on data structures it doesn't know exist?

In Jac, we can make the nodes themselves intelligent. They can recognize the StateAgent when it arrives and "teach" it about their own data.
First, let's define our simple StateAgent. Its only feature is a state dictionary to store any information it gathers.


First, let's define our StateAgent walker:
```jac
walker StateAgent {
    # This dictionary will hold the data collected during the journey.
    has state: dict = {};

    # The walker's journey starts at the root node.
    can start with `root entry {
        # From the root, visit all directly connected nodes.
        visit [-->];
    }
}
```

Next, we will define two different types of nodes, `Weather` and `Time`. Each one will have a special ability that only triggers for a StateAgent.

```jac
node Weather {
    has temp: int = 80;

    # This ability is only triggered when a walker of type 'StateAgent' arrives.
    can get with StateAgent entry {
        # 'visitor' is a special keyword that refers to the walker currently on this node.
        visitor.state["temperature"] = self.temp;
    }
}
```

The `Weather` node knows that when a `StateAgent` visits, it should update the agent's state dictionary by adding a "temperature" key with its own local temp value.


```jac
node Time {
    has hour: int = 12;

    # This node also has a specific ability for the StateAgent.
    can get with StateAgent entry {
        visitor.state["time"] = f"{self.hour}:00 PM";
    }
}
```
Similarly, the `Time` node updates the agent's state with the current hour.

Finally, let's build the graph and dispatch our agent.

```jac
with entry {
    # Create and connect our nodes to the root.
    root ++> Weather();
    root ++> Time();

    # Create an instance of our agent and spawn it on the root node to begin.
    agent = StateAgent() spawn root;

    # After the walker has finished visiting all connected nodes,
    # print the state it has collected.
    print(agent.state);
}
```

When you run this program, the `StateAgent` starts at the `root`, visits both the `Weather` node and the `Time` node, and at each stop, the node's specific ability is triggered. By the time the walker's journey is complete, its state dictionary has been fully populated by the nodes themselves.


```jac
# node_abilities.jac
walker StateAgent{
    has state: dict = {};

    can start with `root entry {
        visit [-->];
    }
}

node Weather {
    has temp: int = 80;

    can get with StateAgent entry {
        visitor.state["temperature"] = self.temp;
    }
}

node Time {
    has hour: int = 12;

    can get with StateAgent entry {
        visitor.state["time"] = f"{self.hour}:00 PM";
    }
}

with entry {
    root ++> Weather();
    root ++> Time();

    agent = StateAgent() spawn root;
    print(agent.state);
}
```


```terminal
$ jac run node_abilities.jac

{"temperature": 80, "time": "12:00 PM"}
```

This pattern is incredibly powerful. It allows you to build a complex world of specialized nodes and then explore it with simple, generic agents. The intelligence is distributed throughout the graph, not just centralized in the walker.

## Node Inheritance
---

In Jac, nodes are more than just dataâ€”they can encapsulate behavior and interact with walkers. When building modular systems, itâ€™s often useful to group nodes by type or functionality. This is where node inheritance comes in.

Letâ€™s revisit the `Weather` and `Time` nodes from the previous example. While they each provide different types of information, they serve a common purpose: delivering contextual data to an agent. In Jac, we can express this shared role using inheritance, just like in traditional object-oriented programming.

We define a base node archetype called `Service`. This acts as a common interface for all context-providing nodes. Any node that inherits from `Service` is guaranteed to support certain interactionsâ€”either by shared methods or simply by tagging it with a common type.

```jac
node Service {}
```

Next, we will redefine `Weather` and `Time` to inherit from `Service`. This tells our system that they are both specific kinds of `Service` nodes.

```jac
# Weather is a type of Service.
node Weather(Service) {
    has temp: int = 80;

    can get with StateAgent entry {
        visitor.state["temperature"] = self.temp;
    }
}

# Time is also a type of Service.
node Time(Service) {
    has hour: int = 12;

    can get with StateAgent entry {
        visitor.state["time"] = f"{self.hour}:00 PM";
    }
}
```
<br />

Now that our nodes are organized, we can make our `StateAgent` walker much smarter. Instead of blindly visiting every node connected to the root, we can instruct it to only visit nodes that are a Service.

```jac
walker StateAgent {
    has state: dict = {};

    can start with `root entry {
        visit [-->(`?Service)];  # Visit any node that is a subtype of Service
    }
}
```
<br />

This simple change makes your `StateAgent` incredibly flexible. If you later add new service nodes to your graph, like `Location` or `Date`, you don't need to change the walker's code at all. As long as the new nodes inherit from `Service`, the walker will automatically visit them.


The ```-->(`?NodeType)``` syntax is a powerful feature of Jac that allows you to filter nodes by type. It tells the walker to visit any node that matches the `NodeType` type, regardless of its specific implementation.

### Usecase: A Smarter NPC

Let's apply these advanced patterns to a practical and engaging example. We will create an NPC (non-player character) in a game whose behavior changes based on the **weather** or **time of day**. For instance, the NPC might be cheerful in the morning, grumpy when it's hot, or sleepy at night.

We have already built the perfect foundation for this.
- We have `Weather` and `Time` nodes that can provide environmental context.
- They both inherit from a common `Service` type.
- We have a StateAgent walker that can automatically visit all `Service` nodes and collect their data into its state dictionary.

Now, let's build the NPC itself.

#### Step 1 - The Mood Function

Our NPC needs to determine its mood based on the environmental data collected by the StateAgent. Instead of writing complex if/else statements, we can delegate this creative task to a Large Language Model (LLM).

Using the byLLM plugin, we can define a function that sends the agent's state to an LLM and asks it to return a mood.

Hereâ€™s the code for our mood function:
```jac
import from byllm { Model }

# Configure the LLM
glob npc_model = Model(model_name="gpt-4.1-mini");

"""Adjusts the tone or personality of the shop keeper npc depending on weather/time."""
def get_ambient_mood(state: dict) -> str by npc_model();
```
This function, `get_ambient_mood`, takes a dictionary (the walkerâ€™s state) and sends it to the model. The model interprets the contents like `temperature` and `time`â€”and returns a textual mood that fits the situation.

#### Step 2 - The NPC Node

Next, we'll define the `NPC` node. Its key feature is an ability that triggers when our StateAgent visits. This ability uses the get_ambient_mood function to determine its own mood based on the information the agent has already collected.


```jac

node NPC {
    can get with StateAgent entry {
        visitor.state["npc_mood"] = get_ambient_mood(visitor.state);
    }
}
```
This is where the NPCâ€™s personality is generatedâ€”based entirely on the graph-derived context.


#### Walker Composition
Our `StateAgent` knows how to collect environmental data, but it doesn't know to visit an `NPC` node. We can create a new, more specialized walker that does both.

Using walker inheritance, we can create an NPCWalker that inherits all the abilities of StateAgent and adds a new ability to visit NPC nodes.

```jac
walker NPCWalker(StateAgent) {
    can visit_npc with `root entry {
        visit [-->(`?NPC)];
    }
}
```
The `NPCWalker` first inherits the behavior of `StateAgent` (which collects context), and then adds a second phase to interact with the NPC after that context is built.


#### Putting It All Together

Finally, we can compose everything in a single entry point:
```jac
import from byllm { Model }

# Configure different models
glob npc_model = Model(model_name="gpt-4.1-mini");

node Service{}

walker StateAgent{
    has state: dict = {};

    can start with `root entry {
        visit [-->(`?Service)];
    }
}

node Weather(Service) {
    has temp: int = 80;

    can get with StateAgent entry {
        visitor.state["temperature"] = self.temp;
    }
}

node Time(Service) {
    has hour: int = 12;

    can get with StateAgent entry {
        visitor.state["time"] = f"{self.hour}:00 PM";
    }
}

"""Adjusts the tone or personality of the shop keeper npc depending on weather/time."""
def get_ambient_mood(state: dict) -> str by npc_model();

node NPC {
    can get with StateAgent entry {
        visitor.state["npc_mood"] = get_ambient_mood(visitor.state);
    }
}

walker NPCWalker(StateAgent) {
    can visit_npc with `root entry{
        visit [-->(`?NPC)];
    }
}


with entry {
    root ++> Weather();
    root ++> Time();
    root ++> NPC();

    agent = NPCWalker() spawn root;
    print(agent.state['npc_mood']);
}
```
<br />

```terminal
$ jac run npc_mood.jac

"The shopkeeper greets you warmly with a bright smile, saying, "What a hot day weâ€™re having!
Perfect time to stock up on some refreshing potions or cool drinks. Let me know if you need
anything to beat the heat!"
```
<br />


## Edge Types and Relationships
---
In Jac, edges are the pathways that connect your nodes. They are more than just simple pointers; they are first-class citizens of the graph. This means an `edge` can have its own attributes and abilities, allowing you to model rich, complex relationships like friendships, ownership, or enrollment.

Edges in Jac are not just connections - they're full objects with their own properties and behaviors. This makes relationships as important as the data they connect.

### Basic Edge Declaration

You define an edge's blueprint using the `edge` keyword, and you can give it has attributes just like a node or object.

Let's model a simple school environment with Student, Teacher, and Classroom nodes, and the various relationships that connect them.

```jac
# Basic node for representing teachers
node Teacher {
    has name: str;
    has subject: str;
    has years_experience: int;
    has email: str;
}

# Basic node for representing students
node Student {
    has name: str;
    has age: int;
    has grade_level: int;
    has student_id: str;
}

node Classroom {
    has room_number: str;
    has capacity: int;
    has has_projector: bool = True;
}

# Edge for student enrollment
edge EnrolledIn {
    has enrollment_date: str;
    has grade: str = "Not Assigned";
    has attendance_rate: float = 100.0;
}

# Edge for teaching assignments
edge Teaches {
    has start_date: str;
    has schedule: str;  # "MWF 9:00-10:00"
    has is_primary: bool = True;
}

# Edge for friendship between students
edge FriendsWith {
    has since: str;
    has closeness: int = 5;  # 1-10 scale
}

with entry {
    # 1. Create the main classroom node and attach it to the root.
    science_lab = root ++> Classroom(
        room_number="Lab-A",
        capacity=24,
        has_projector=True
    );

    # 2. Create a teacher AND the 'Teaches' edge that connects them to the classroom.
    dr_smith = science_lab +>:Teaches(
        start_date="2024-08-01",
        schedule="TR 10:00-11:30"
    ):+> Teacher(
        name="Dr. Smith",
        subject="Chemistry",
        years_experience=12,
        email="smith@school.edu"
    );
}
```
Let's break down the edge creation syntax: <+:EdgeType(attributes):+>.
science_lab: The starting node (the "source" of the edge).

- `<+: ... :+>`: This syntax creates a bi-directional edge. It means the relationship can be traversed from science_lab to dr_smith and also from dr_smith back to science_lab.
- `Teaches(...)`: The type of edge we are creating, along with the data for its attributes.
- `Teacher(...)`: The destination node.

## Graph Navigation and Filtering
---
Jac provides powerful and expressive syntax for navigating and querying graph structures. Walkers can traverse connections directionallyâ€”forward or backwardâ€”and apply filters to control exactly which nodes or edges should be visited.

### Directional Traversal
- `-->` : Follows outgoing edges from the current node.
- `<--` : Follows incoming edges to the current node.

These can be wrapped in a visit statement to direct walker movement:
```jac
visit [-->];   # Move to all connected child nodes
visit [<--];   # Move to all parent nodes
```


### Filter by Node Type
To narrow traversal to specific node types, use the filter syntax:
```jac
-->(`?NodeType)
```

This ensures the walker only visits nodes of the specified archetype.
```jac
# Example: Visit all Student nodes connected to the root
walker FindStudents {
    can start with `root entry {
        visit [-->(`?Student)];
    }
}
```
This allows your walker to selectively traverse part of the graph, even in the presence of mixed node types.

### Filtering by Node Attributes
To make your walkers more intelligent, you can instruct them to only visit nodes of a specific type. You achieve this using the (?NodeType) filter. It's also called **attribute-based filtering**.


```jac
-->(`?NodeType: attr1 op value1, attr2 op value2, ...)
```
Where:

- `NodeType` is the node archetype to match (e.g., `Student`)
- `attr1`, `attr2` are properties of that node
- `op` is a comparison operator


#### Supported Operators

| Operator   | Description                    | Example                             |
|------------|--------------------------------|-------------------------------------|
| `==`       | Equality                       | `grade == 90`                        |
| `!=`       | Inequality                     | `status != "inactive"`              |
| `<`        | Less than                      | `age < 18`                           |
| `>`        | Greater than                   | `score > 70`                         |
| `<=`       | Less than or equal to          | `temp <= 100`                       |
| `>=`       | Greater than or equal to       | `hour >= 12`                        |
| `is`       | Identity comparison            | `mood is "happy"`                   |
| `is not`   | Negative identity comparison   | `type is not "admin"`              |
| `in`       | Membership (value in list)     | `role in ["student", "teacher"]`    |
| `not in`   | Negative membership            | `status not in ["inactive", "banned"]` |

#### Example
```jac
# Find all students with a grade above 85
walker FindTopStudents {
    can start with `root entry {
        visit [-->(`?Student: grade > 85)];
    }
}
```
This walker will only visit `Student` nodes where the `grade` property is greater than 85.

### Filtering by Edge Type and Attributes

In addition to filtering by node types and attributes, Jac also allows you to filter based on edge types and edge attributes, enabling precise control over traversal paths in complex graphs.

To traverse only edges of a specific type, use the following syntax:
```jac
visit [->:EdgeType->];
```

This tells the walker to follow only edges labeled as `EdgeType`, regardless of the type of the nodes they connect.

#### Example
```jac
# Only follow "enrolled_in" edges
visit [->:enrolled_in->];
```

### Edge Atribute Filtering
You can further refine edge traversal by applying attribute-based filters directly to the edge:
```jac
visit [->:EdgeType: attr1 op val1, attr2 op val2:->];
```
This format allows you to filter based on metadata stored on the edge itself, not the nodes.

#### Example
```jac
# Follow "graded" edges where score is above 80
visit [->:graded: score > 80:->];
```
This pattern is especially useful when edges carry contextual data, such as timestamps, weights, relationships, or scores.

## Wrapping Up
---
In this chapter, we explored the foundational concepts of nodes and edges in Jac. We learned how to define nodes with properties, create edges to represent relationships, and navigate the graph using walkers. We also saw how to filter nodes and edges based on types and attributes, enabling powerful queries and interactions.

These concepts form the backbone of Object-Spatial Programming, allowing you to model complex systems and relationships naturally. As you continue to build your Jac applications, keep these principles in mind to create rich, interconnected data structures that reflect the real-world entities and relationships you want to represent.

## Key Takeaways
---

**Node Fundamentals:**

- **Spatial objects**: Nodes can be connected and automatically persist when linked to root
- **Property storage**: Nodes hold data using `has` declarations with automatic constructors
- **Automatic persistence**: Nodes connected to root persist between program runs
- **Type safety**: All node properties must have explicit types

**Edge Fundamentals:**

- **First-class relationships**: Edges are full objects with their own properties and behaviors
- **Typed connections**: Edges define the nature of relationships between nodes
- **Bidirectional support**: Edges can be traversed in both directions
- **Rich metadata**: Store relationship-specific data directly in edge properties

**Graph Operations:**

- **Creation syntax**: Use `++>` to create new connections, `-->` to reference existing ones
- **Navigation patterns**: `[-->]` for outgoing, `[<--]` for incoming connections
- **Filtering support**: Apply conditions to find specific nodes or edges
- **Traversal efficiency**: Graph operations are optimized for spatial queries

**Practical Applications:**

- **Natural modeling**: Represent real-world entities and relationships directly
- **Query capabilities**: Find related data through graph traversal
- **Persistence automation**: No manual database management required
- **Scalable architecture**: Graph structure supports distributed processing

!!! tip "Try It Yourself"
    Practice with nodes and edges by building:
    - A classroom management system with students, teachers, and courses
    - A family tree with person nodes and relationship edges
    - A social network with users and friendship connections
    - An inventory system with items and location relationships

    Remember: Nodes represent entities, edges represent relationships - think spatially!

---

*Your graph foundation is solid! Now let's add mobile computation with walkers and abilities.*




================================================================================
FILE: docs/jac_book/index.md
================================================================================


# The Jac Programming Language Book

This guide will help you get started with Jac, a programming language that introduces **Object-Spatial Programming (OSP)**  which is designed for building AI-powered applications. We will walk through practical examples to help you understand Jac's core features.


!!! info "About This Book"
    This book teaches Jac through practical examples and real-world applications. Each chapter builds on the previous one, culminating in complete applications that demonstrate Jac's unique capabilities.

---

## What Makes Jac Special?

Jac offers a unique approach to programming by combining established concepts with new features tailored for AI development. Here are some of the key elements that set it apart:

- **Object-Spatial Programming**: Jac introduces a new way to think about programming by allowing computation to happen where the data is located.[2] This approach is particularly useful for applications with connected data, like social networks or file systems, and helps make them easier to scale.
- **Scale-Agnostic Architecture**: You can write your code once and run it on your local machine or scale it for the cloud without making changes to the code itself.
- **AI-First Design**: Jac is designed with artificial intelligence at its core, providing built-in capabilities for AI without the need for complex integrations.
- **Zero-Configuration Deployment**: Jac automates the process of generating APIs and managing data persistence, which simplifies the deployment of your applications.

---

## Book Structure

This book is organized into four progressive parts that build your expertise systematically:

### Part I: Jac Fundamentals
*Master the language basics and unique features*

#### Chapter 1: Introduction to Jac
- What is Jac and why it matters
- Installation and development environment setup
- Your first Jac program
- Scale-agnostic programming philosophy

!!! example "Code Focus"
    Hello World with explanation of Jac's unique features

#### Chapter 2: Syntax and Development Environment
- Setting up VS Code with Jac extension
- Basic syntax differences from Python
- Project structure and best practices
- Development workflow with `jac run` and `jac serve`

!!! example "Code Focus"
    Development environment setup and basic project structure

#### Chapter 3: Variables, Types, and Control Flow
- Enhanced type system with mandatory typing
- Variables, data structures, and type annotations
- Control flow: if/else, loops, and pattern matching
- Error handling and exception management

!!! example "Code Focus"
    Student record system demonstrating type safety and control flow

#### Chapter 4: Functions, AI Functions, and Decorators
- Function definitions with mandatory type annotations
- Built-in AI function capabilities with `by llm()`
- Decorators for enhanced functionality
- Lambda functions and functional programming patterns
- Async functions and concurrent programming

!!! example "Code Focus"
    Math functions library with AI integration and decorators

#### Chapter 5: Advanced AI Operations
- byLLM (Meaning Typed Programming) overview
- Model configuration and selection
- Semantic strings for enhanced AI context
- Multimodal support for images, audio, and text
- Error handling and fallback strategies

!!! example "Code Focus"
    Image captioning tool with multiple AI models

#### Chapter 6: Imports System and File Operations
- Import statements and module organization
- Implementation separation with `.impl.jac` files
- Python library integration
- File operations and configuration management
- Package structure for scalable applications

!!! example "Code Focus"
    Multi-module configuration management system

---

### Part II: Enhanced Object-Oriented Programming
*Build on familiar OOP concepts with modern enhancements*

#### Chapter 7: Enhanced OOP - Objects and Classes
- From Python `class` to Jac `obj`
- Automatic constructors with `has` declarations
- Access control with `:pub`, `:priv`, `:protect`
- Inheritance and composition patterns
- Implementation separation and clean architecture

!!! example "Code Focus"
    Pet shop management system with automatic constructors and access control

---

### Part III: Object-Spatial Programming (OSP)
*Master the revolutionary paradigm that makes Jac unique*

#### Chapter 8: OSP Introduction and Paradigm Shift
- From "data to computation" to "computation to data"
- Spatial programming foundations
- Graph thinking vs object thinking
- Mental model transformation
- Benefits of the OSP paradigm

!!! example "Code Focus"
    Family tree comparison showing traditional vs spatial approaches

#### Chapter 9: Nodes and Edges
- Node creation and properties
- Edge types and first-class relationships
- Graph creation syntax and connection operators
- Graph navigation and filtering
- Persistence through root connection

!!! example "Code Focus"
    Classroom management system with students, teachers, and connections

#### Chapter 10: Walkers and Abilities
- Walker creation and mobile computation
- Ability definitions and event-driven triggers
- Entry and exit behaviors
- Walker spawn, visit, and traversal control
- Flow control and disengage patterns

!!! example "Code Focus"
    Message delivery system traversing classroom networks

#### Chapter 11: Advanced Object Spatial Operations
- Advanced filtering and multi-criteria queries
- Visit patterns and traversal control
- Breadth-first vs depth-first strategies
- Priority-based visiting and custom ordering
- Performance optimization for large graphs

!!! example "Code Focus"
    Social network analysis with friend-of-friend discovery

---

### Part IV: Scale-Agnostic Cloud Applications
*Build applications that scale from single-user to distributed systems*

#### Chapter 12: Walkers as API Endpoints
- Automatic API generation from walkers
- Request/response handling and parameter validation
- REST patterns using walker semantics
- Multi-user applications with shared data
- Type-safe API contracts

!!! example "Code Focus"
    Shared notebook system with automatic REST API generation

#### Chapter 13: Persistence and the Root Node
- Automatic persistence with `jac serve`
- Root node as persistence gateway
- State consistency across requests and restarts
- Database-backed applications without setup
- Persistent graph structures

!!! example "Code Focus"
    Counter application demonstrating automatic state persistence

#### Chapter 14: Multi-User Architecture and Permissions
- User isolation and data privacy patterns
- Permission-based access control systems
- Role-based and attribute-based security
- Shared data management strategies
- Security best practices for cloud applications

!!! example "Code Focus"
    Multi-user notebook with comprehensive permission system

#### Chapter 15: Advanced Jac Cloud Features
- Environment variables and configuration management
- Logging and monitoring capabilities
- Webhook integration for external services
- Background tasks and automated maintenance
- Performance optimization strategies

!!! example "Code Focus"
    Chat room system with configuration, logging, and webhooks

---

### Part V: Advanced Topics and Best Practices
*Master sophisticated features and production deployment*

#### Chapter 16: Type System Deep Dive
- Advanced generics and type parameterization
- Type constraints and bounded generics
- Graph-aware type checking for OSP
- Runtime type validation and guards
- Building type-safe, reusable components

!!! example "Code Focus"
    Generic data processing system with type constraints

#### Chapter 17: Testing and Debugging
- Built-in testing framework and patterns
- Testing walkers, nodes, and graph structures
- Debugging spatial applications effectively
- Performance testing and optimization
- Test-driven development with OSP

!!! example "Code Focus"
    Comprehensive test suite for spatial applications

#### Chapter 18: Deployment Strategies
- Local vs cloud deployment comparison
- Docker containerization for Jac applications
- Kubernetes orchestration and scaling
- CI/CD pipelines for automated deployment
- Production monitoring and maintenance

!!! example "Code Focus"
    Complete deployment pipeline from development to production

#### Chapter 19: Performance Optimization
- Graph structure optimization strategies
- Algorithm optimization for spatial operations
- Caching patterns and memory management
- Distributed performance considerations
- Profiling and benchmarking techniques

!!! example "Code Focus"
    Performance optimization of large-scale graph applications

#### Chapter 20: Python to Jac Migration
- Migration strategies and planning
- Converting Python classes to Jac objects
- Transforming traditional data structures to spatial graphs
- Hybrid applications during transition
- Team adoption and training strategies

!!! example "Code Focus"
    Step-by-step migration of a Python application to Jac

---

## Learning Paths

!!! tip "Choose Your Learning Journey"
    **Quick Start (Chapters 1-4, 7-11)**: Get productive with Jac quickly for OSP development

    **Full Foundation (Chapters 1-16)**: Complete journey through core concepts and scale-agnostic features

    **AI-Focused (Chapters 1-5, 12-16)**: Emphasize AI-enhanced programming with cloud deployment

    **Enterprise Ready (Complete Book)**: Full mastery including advanced topics and production deployment

## What You'll Build

Throughout this book, you'll create increasingly sophisticated applications:

- **Part I**: Mathematical functions with AI integration
- **Part II**: Pet shop management with enhanced OOP
- **Part III**: Classroom and social network systems using OSP
- **Part IV**: Multi-user applications with automatic scaling
- **Part V**: Production-ready systems with comprehensive testing

## Prerequisites

- Basic programming experience (Python knowledge helpful but not required)
- Familiarity with object-oriented programming concepts
- Understanding of web applications (for cloud chapters)
- Interest in AI integration and spatial programming

## Getting Help

- **[Documentation](https://www.jac-lang.org/)**: Comprehensive guides and API references
- **[Community](https://discord.gg/6j3QNdtcN6)**: Join our Discord for discussions and support
- **[Issues](https://github.com/jaseci-labs/jaseci/issues)**: Report bugs and request features on GitHub

## Book Features

!!! summary "What You'll Learn"

    **Core Concepts:**

    - **Object-Spatial Programming**: Revolutionary paradigm for connected data
    - **Scale-Agnostic Architecture**: Code that works everywhere without changes
    - **AI Integration**: Built-in AI capabilities without complex setup
    - **Type Safety**: Advanced type system for robust applications

    **Practical Skills:**

    - **Graph Modeling**: Natural representation of real-world relationships
    - **Mobile Computation**: Walkers that process data where it lives
    - **API Development**: Automatic REST API generation from application logic
    - **Cloud Deployment**: Zero-configuration scaling and persistence

    **Professional Development:**

    - **Best Practices**: Industry-standard patterns and techniques
    - **Testing Strategies**: Comprehensive testing for spatial applications
    - **Performance Optimization**: Scaling to handle large datasets
    - **Production Deployment**: Real-world deployment and maintenance

    **Advanced Features:**

    - **Multi-User Systems**: Secure, scalable user management
    - **External Integration**: Webhooks, APIs, and service connections
    - **Monitoring**: Logging, metrics, and operational excellence
    - **Migration Strategies**: Moving from traditional to spatial programming

---

*Ready to revolutionize how you think about programming? Let's begin with [Chapter 1: Welcome to Jac](chapter_1.md)!*




================================================================================
FILE: docs/learn/beginners_guide_to_jac.md
================================================================================


# The Complete Beginner's Guide to Programming with Jac

> **Welcome to Programming!** This guide will teach you how to program using Jac as your first programming language. No prior experience required. We'll start from the absolute basics and build up to advanced concepts step by step.

---

## Table of Contents

1. [Introduction: What is Programming?](#1-introduction-what-is-programming)
2. [Setting Up: Your First Program](#2-setting-up-your-first-program)
3. [The Basics: Variables and Data](#3-the-basics-variables-and-data)
4. [Making Decisions: Control Flow](#4-making-decisions-control-flow)
5. [Repeating Actions: Loops](#5-repeating-actions-loops)
6. [Organizing Code: Functions](#6-organizing-code-functions)
7. [Collections: Working with Multiple Values](#7-collections-working-with-multiple-values)
8. [Grouping Things: Classes and Objects](#8-grouping-things-classes-and-objects)
9. [Understanding Relationships: Graphs](#9-understanding-relationships-graphs)
10. [The Magic of Jac: Object-Spatial Programming](#10-the-magic-of-jac-object-spatial-programming)
11. [Putting It All Together: Complete Examples](#11-putting-it-all-together-complete-examples)
12. [What's Next?](#12-whats-next)

---

## 1. Introduction: What is Programming?

Programming is giving instructions to a computer. Just like you might give directions to a friend ("turn left, then go straight"), you give instructions to a computer using a programming language.

### Why Jac?

Jac is special because it teaches you **two ways of thinking**:

1. **Traditional Programming** - Like most languages (Python, JavaScript, Java)
2. **Object-Spatial Programming (OSP)** - A new way to think about how data and computation work together

Think of it this way:
- **Traditional Programming**: You call a restaurant and order food to be delivered to you
- **Object-Spatial Programming**: You send a robot to visit different restaurants and collect food

Both get you fed, but they work differently! By the end of this guide, you'll understand both approaches.

---

## 2. Setting Up: Your First Program

Every Jac program needs a place to start. We use a special block called `with entry`:

> **[Section condensed]**



================================================================================
FILE: docs/learn/bigfeatures.md
================================================================================


<h2 style="color: orange; font-weight: bold; text-align: center;">Roadmap (Coming Soon)</h2>

## One Language for Frontend (JS) and Backend (PY)

## Zero to Native Code as fast as Rust



> **[Section condensed]**



================================================================================
FILE: docs/learn/data_spatial/FAQ.md
================================================================================



================================================================================
FILE: docs/learn/data_spatial/filtering.md
================================================================================


# Node and Edge Filtering

JacLang provides flexible filtering mechanisms to control graph traversal and operations, allowing precise selection of nodes and edges based on specific criteria. These filters enable developers to optimize traversal and focus only on relevant parts of the graph.

---

## Node-Based Filtering

Node-based filtering restricts traversal to specific nodes that satisfy predefined conditions. This is useful when you need to:

- Limit traversal to nodes with certain attributes or properties.
- Filter nodes dynamically based on walker state or external context.

### Example:

We can filter specific types of nodes from a list of visitable nodes based on their type, and further apply conditions on node attributes to refine the results.
=== "Jac"
    <div class="code-block">
    ```jac
    --8<-- "jac/examples/data_spatial/filtering.jac"
    ```
    </div>
??? example "Graph"
    ```mermaid
    flowchart LR
    0 -->|"a()"| 1
    1 -->|"b()"| 2
    2 -->|"c()"| 3
    2 -->|"c()"| 4
    5 -->|"a()"| 4
    1 -->|"b()"| 5
    0["Root()"]
    1["A(val=5)"]
    2["B(val=10)"]
    3["C(val=15)"]
    4["C(val=25)"]
    5["A(val=20)"]
    ```

## Edge-Based Filtering

Edge filtering in JacLang allows developers to control traversal by selecting edges based on specific attributes or conditions. This is especially useful in scenarios where certain edges in the graph are more relevant to the task at hand, such as weighted graphs or context-sensitive connections.

---

### Example:
We can filter nodes based on specific edge attributes, such as filtering by edge values to retrieve a subset of connected nodes.
=== "Jac"
    <div class="code-block">
    ```jac
    --8<-- "jac/examples/data_spatial/edge_filtering.jac"
    ```
    </div>

??? example "Graph"
    ```mermaid
    flowchart LR
    0 -->|"a(val=10)"| 1
    0 -->|"a(val=20)"| 2
    0 -->|"b(val=30)"| 3
    0["Root()"]
    1["A(val=10)"]
    2["A(val=20)"]
    3["A(val=30)"]
    ```



================================================================================
FILE: docs/learn/data_spatial/nodes_and_edges.md
================================================================================


# <span style="color: orange">Nodes and Edges</span>

## Nodes
Nodes are archetypes forming part of a graph, holding properties. They can be compared to custom classes in object-oriented programming (OOP).

```jac linenums="1"
node node_name{
    has node_property: int;
}
node node_name{
    has node_property: int = 10;
}
```

### Custom Node Types
- You can define custom node types to create specific instances within the graph.
- Each node can have `attributes` (like fields in a class) and `abilities` (similar to methods in OOP).

### Abilities in Nodes
- **Callable Abilities:** They are similar to standard methods in OOP. Inside any ability, the node can refer to itself using the `self` keyword, much like in OOP.

- **Visit-dependent Abilities:** These abilities are only triggered when a specific type of "walker" (discussed later) interacts with the node. This ensures that certain actions are performed only in response to a walker's visit. In these abilities, a special keyword `here` is used to reference the visiting walker. This allows you to access the walker's attributes and abilities directly during its interaction with the node.

- This is an example of defining a node.
```jac linenums="1"
node test_node {
    has value: int;

    can log_entry with entry {
        print(f">>> Some Walker entered the node: ", self);
    }
    can log_test_walker_entry with test_walker entry {
        print(f">>> {here} entered the node {self}");
        here.callable();
    }
    can log_test_walker_exit with test_walker exit {
        print(f"<<< {here} exited the node {self}");
    }
    can log_exit with exit {
        print(f"<<< Some Walker exited the node {self}");
    }
    def callable {
        print(f"===== Callable on {self}");
    }
}
```

### Connecting Nodes
Nodes in JacLang can establish connections in various ways, offering flexibility for building complex graphs:

- **One-to-One**: A single node connects to another single node.
- **One-to-Many**: A single node connects to multiple nodes.
- **Many-to-One**: Multiple nodes connect to a single node.
- **Many-to-Many**: A group of nodes connects to another group of nodes.

This versatility allows for creating intricate and highly interconnected graph structures, tailored to the specific needs of your application.
=== "one2one.jac"
    ```jac linenums="1"
    node MyNode{}

    with entry{
    first_node = MyNode();
    second_node = MyNode();

    root ++> first_node;
    first_node ++> second_node;

    }
    ```
    ??? example "Graph"
        ```mermaid
        flowchart LR
        0 --> 1
        1 --> 2
        0["Root()"]
        1["MyNode()"]
        2["MyNode()"]
        ```
=== "one2many.jac"
    ```jac linenums="1"
    node MyNode{}

    with entry{
    first_node = MyNode();
    second_tier = [MyNode() for i in range(2)];

    root ++> first_node;
    first_node ++> second_tier; # one to many

    }
    ```
    ??? example "Graph"
        ```mermaid
        flowchart LR
        0 --> 1
        1 --> 2
        1 --> 3
        0["Root()"]
        1["MyNode()"]
        2["MyNode()"]
        3["MyNode()"]
        ```
=== "many2one.jac"
    ```jac linenums="1"
    node MyNode{}

    with entry{
    first_tier = [MyNode() for i in range(2)];
    second_node = MyNode();
    root ++> first_tier;
    first_tier ++> second_node; # many to one

    }
    ```
    ??? example "Graph"
        ```mermaid
        flowchart LR
        0 --> 1
        1 --> 2
        3 --> 2
        0 --> 3
        0["Root()"]
        1["MyNode()"]
        2["MyNode()"]
        3["MyNode()"]
        ```
=== "many2many.jac"
    ```jac linenums="1"
    node MyNode{}

    with entry{
        first_tier =[MyNode() for i in range(2)];
        second_tier =[MyNode() for i in range(2)];

        root ++> first_tier;
        first_tier ++> second_tier;

        end_tier = MyNode();
        second_tier ++> end_tier;
    }
    ```
    ??? example "Graph"
        ```mermaid
        flowchart LR
        0 --> 1
        1 --> 2
        3 --> 2
        0 --> 3
        3 --> 4
        1 --> 4
        4 --> 5
        2 --> 5
        0["Root()"]
        1["MyNode()"]
        2["MyNode()"]
        3["MyNode()"]
        4["MyNode()"]
        5["MyNode()"]
        ```

## Edges
Nodes can be linked using either *default edges* (generic connections) or *custom edges*, which have specific properties as shown in the following examples.
=== "Generic Edges"
    ```jac linenums="1"
    with entry {
      node_1 ++> node_2; # uni directional edge
      node_1 <++> node_2; # bidirectional edge
    }
    ```
=== "Custom Edges"
    ```jac linenums="1"
    edge custom1 {
        has atrib1:str;
    }

    with entry {
      node_1 +:custom1:atrib1='val1':+> node_2; # uni directional edge
      node_1 <+:custom1:atrib1='val2':+> node_2; # bidirectional edge
    }
    ```

To delete an edge between two nodes the ````del``` keyword can be used as shown below.

```jac linenums="1"
node_1 del --> node_2;
```




================================================================================
FILE: docs/learn/data_spatial/sequence.md
================================================================================


# Walker and Node ability trigger sequence

<div class="code-block">
```jac
node Node {
    has val: str;

    can entry1 with entry {
        print(f"{self.val}-2");
    }

    can entry2 with Walker entry {
        print(f"{self.val}-3");
    }

    can exit1 with Walker exit {
        print(f"{self.val}-4");
    }

    can exit2 with exit {
        print(f"{self.val}-5");
    }
}

walker Walker {
    can entry1 with entry {
        print("walker entry");
    }

    can entry2 with `root entry {
        print("walker enter to root");
        visit [-->];
    }

    can entry3 with Node entry {
        print(f"{here.val}-1");
    }

    can exit1 with Node exit {
        print(f"{here.val}-6");
    }

    can exit2 with exit {
        print("walker exit");
    }
}

with entry{
    root ++> Node(val = "a");
    root ++> Node(val = "b");
    root ++> Node(val = "c");

    Walker() spawn root;
}
```
</div>




================================================================================
FILE: docs/learn/data_spatial/walkers.md
================================================================================


# <span style="color: orange">Walkers</span>
Walkers are "worker bots" that move (walk) along the graph while performing tasks on the nodes they visit.

They play a crucial role in executing visit-dependent abilities as discussed in nodes and facilitating interactions between graph nodes and themselves.

## Spawning a Walker
A walker can be spawned at any point on the graph with the ```spawn``` keyword.

=== "Jac"
    <div class="code-block">
    ```jac
    --8<-- "jac/examples/data_spatial/define_walker.jac"
    ```
    </div>
??? example "Graph"
    ```mermaid
    flowchart LR
    0 -->|"a()"| 1
    1 -->|"a()"| 2
    2 -->|"a()"| 3
    1 -->|"a()"| 4
    4 -->|"a()"| 5
    0["Root()"]
    1["A(val=5)"]
    2["A(val=10)"]
    3["A(val=15)"]
    4["A(val=20)"]
    5["A(val=25)"]
    ```

## Graph Traversal Using Visit
Walkers navigate the graph using the ```visit``` keyword.
=== "visiting_node.jac"
    ```jac linenums="1"
    visit [node_name]; # Visits a particular node
    ```
=== "visiting_sucessor.jac"
    ```jac linenums="1"
    visit [node_name-->]; # Visits successive nodes of a node
    ```
=== "visiting_predecessor.jac"
    ```jac linenums="1"
    visit [<--node_name]; # Visits predecessor nodes of a node
    ```
## Attributes & Abilities
- Similar to nodes, walkers can have their own attributes and abilities including both callable and visit-dependent abilities.

- **Visit-dependent Abilities:**
    - Ensures the ability is executed only when the walker visits a node.
    - Can be defined within:
        - **Nodes:** Triggered upon a walker's arrival.
        - **Walkers:**  Specific to the walkerâ€™s operation during its visit.
## Reference Keywords:
- ```self``` : Refers to the walker object itself.
- ```here```: References the current node visited by the walker, enabling access to its attributes and callable abilities.
    This allows seamless interaction between walker and node attributes.

- Control Movement:
    - Use ```visit``` to:
        - Direct the walker to a specific node.
        - Walk along an edge connecting nodes.

- Remove Walkers:
    - Use ```disengage``` to remove a walker from the graph.

## Walkers in Action:
- Walkers prioritize their visit-dependent abilities first before executing the abilities of the visited node.
- This enables flexible task delegation:
    - Define visit-dependent tasks either within the walker or in the node.

By using these principles, walkers can efficiently traverse and interact with graphs, enabling dynamic workflows.

### Example:
=== "Jac"
    <div class="code-block">
    ```jac
    --8<-- "jac/examples/data_spatial/ds_entry_exit.jac"
    ```
    </div>

!!! Abstract  "can log_entry with entry"
    -  This ability is triggered once when the walker is spawned. It is essentially the "entry point" of the walkerâ€™s operation.
    In the example, it logs the entry at the beginning, increments entry_count by 1, and prints the node where the walker starts (in this case, the root node).
    !!! Info ""
        - This DS function is called once at the beginning of the walkerâ€™s traversal before visiting any nodes.

!!! Abstract "can log_visit with test_node exit"
    - This ability is executed each time the walker visits a node of type test_node during its traversal.
    In the example, whenever the walker visits a test_node, it prints the node and appends the node to visited_nodes.
    !!! Info ""
        - This DS function operates during traversal and is called on each node of type test_node the walker visits.

!!! Abstract "can log_exit with exit"
    - This ability is triggered once when the walker finishes its traversal, marking the end of its operation.
    In the example, it logs the exit point, increments exit_count by 1, and prints the final node visited.
    !!! Info ""
        - This DS function is executed at the end of the walker's execution, after all nodes have been visited.



================================================================================
FILE: docs/learn/dspfoundation.md
================================================================================


# Object-Spatial Programming: A Topological Approach to Computation
#### By Jason Mars ([Original Paper on Arxiv](https://arxiv.org/abs/2503.15812))

## Introduction
As modern software systems grow increasingly complex and interconnected, traditional programming paradigms often struggle to represent the rich spatial and topological relationships inherent in many problem domains. While Object-Oriented Programming (OOP) has served as a dominant paradigm for decades, it faces significant limitations when modeling systems with inherently graph-like structures, dynamic traversal patterns, or context-dependent behaviors. These limitations become particularly pronounced in domains such as social networks, agent-based systems, neural networks, and other topologically-oriented computational problems.

Traditional programming models, including procedural, functional, and object-oriented paradigms, typically separate data structures from the algorithms that manipulate them. In this conventional model, data flows to computation through parameter passing and return values, with algorithms remaining stationary in functions and methods. This "data-to-compute" programming model is pervasive, being ubiquitous at the programming interface and can even be found as a fundamentally embedded presupposition in the von Neumann computer design itself, where data is moved from memory to the CPU for processing. Notably absent from the programming language landscape is a system of language constructs that naturally supports a complementary "compute-to-data" paradigm while maintaining compatibility with conventional popular programming languages. The lack of such a programming model creates friction when representing a wide range of computational problems where:

- The topology of connections is central to the underlying computational model
- Computation logically flows through a network of interconnected entities
- Behavior is context-dependent based on tight couplings between data and compute
- Traversal patterns are complex and dynamically determined

Though graph algorithms and data structure libraries can be constructed in most programming languages, they remain secondary citizens, without first-class language support for topological semantics. This forces developers to implement complex traversal logic, maintain graph integrity, and manage event propagation through ad-hoc mechanisms that are often error-prone and difficult to maintain.

Beyond the programmability advantages, embedding topological abstractions at the language level provides the runtime environment with rich semantic information about program behavior that would otherwise be obscured in conventional programming models. This heightened awareness of the spatial relationships and traversal patterns enables a new class of optimizations that are particularly relevant to modern hardware architectures. The runtime can make informed decisions about data locality, parallel execution paths, and distribution strategies based on the explicit topology of the computation graph. For instance, nodes that are frequently traversed together can be co-located in memory or on the same computational unit, reducing latency and communication overhead. Similarly, independent walker traversals can be automatically parallelized across processing cores or distributed across network nodes without developer intervention. Edge connections can inform predictive prefetching strategies, while the declarative nature of topological relationships enables automated reasoning about program correctness and performance characteristics. These runtime-level optimizations, which would require complex and error-prone manual implementation in traditional programming models, emerge naturally when the language itself encodes spatial and topological semantics as first-class citizens.

To address these challenges, we introduce **Object-Spatial Programming (OSP)**, a novel programming model that fundamentally inverts the relationship between data and computation. Rather than moving data to stationary computation units (as in traditional programming), OSP enables computation to move to data through topologically-aware constructs. This paradigm extends the semantics of Object-Oriented Programming by introducing specialized class-like constructs called **archetypes** that formalize spatial and topological relationships within the programming model itself.

At the core of Object-Spatial Programming are four key archetypes that extend traditional class semantics:

1. **Object Classes** ($\tau_{\text{obj}}$): The universal supertype from which all other archetypes inherit, providing backward compatibility with traditional OOP concepts.

2. **Node Classes** ($\tau_{\text{node}}$): Extensions of object classes that represent discrete locations or entities within a topological structure, capable of hosting computation and connecting to other nodes.

3. **Edge Classes** ($\tau_{\text{edge}}$): First-class entities that represent relationships between nodes, encoding both the topology of connections and the semantics of those relationships. Edges serve not only as connections but also as potential locations where computation can reside.

4. **Walker Classes** ($\tau_{\text{walker}}$): Autonomous computational entities that traverse the node-edge structure, residing and executing on both nodes and edges as they move through the topological space, carrying state and behaviors that execute based on their current location.

Together, these archetypes create a complete topological representation framework where data (in nodes), relationships (as edges), and computational processes (through walkers) are explicitly modeled and integrated. This integration enables a paradigm shift from "data moving to computation" to "computation moving to data."

The OSP paradigm offers significant advantages for a wide range of applications, including but not limited to: for agent-based systems, walkers provide a direct representation for autonomous agents that navigate environments, gather information, and make decisions based on local context; in distributed systems, the decoupling of data (nodes) from computation (walkers) creates a natural model for distributed execution where computational tasks can move between data locations; in social networks and graph-based systems, it enables intuitive representations of complex social structures through the natural mapping of users, relationships, and content to nodes and edges; and for finite state machines, states map naturally to nodes, transitions to edges, and execution flow to walker traversal, creating a clean representation of state-based systems. These examples represent just a few of the potential applications, as the paradigm's flexibility extends to numerous other domains. By formalizing these topological relationships at the language level, OSP enables more expressive, maintainable, and semantically rich programs for domains where connection topology is a fundamental aspect of the problem space.

This paper makes the following contributions:

1. We formalize Object-Spatial Programming as an extension to Object-Oriented Programming, introducing four distinct archetypes: object classes, node classes, edge classes, and walker classes.

2. We define a semantic model that specifies how these archetypes interact, including instantiation rules, lifecycle management, and execution semantics for traversal operations.

3. We introduce specialized operators and statements for object-spatial execution, including the spawn operator ($\Rightarrow$) for activating computational entities and the visit statement ($\triangleright$) for traversing topological structures.

4. We present the concept of **abilities** as a new function type with implicit execution semantics, triggered by spatial events rather than explicit invocation.

5. We demonstrate the practical application of OSP through a case study of a social media application that naturally maps domain concepts to object-spatial constructs.

## Object-Spatial Topological Semantics

The foundational concept of Object-Spatial Programming is the formalization of topological relationships through the introduction of special class types and a handful of new language constructs. This section outlines the core semantic elements of these constructs related to object-spatial topology, which fundamentally inverts the traditional relationship between data and computation.

### Unified Notation

To ensure clarity and consistency throughout the formalization of Object-Spatial Programming, we define the following notation:

| **Symbol** | **Definition** |
|------------|---------------|
| **Classes and Instances** | |
| $C$ | Set of all class definitions in the programming model |
| $\tau_{\text{obj}}$ | Object class type (universal supertype) |
| $\tau_{\text{node}}$ | Node class type (extends object classes) |
| $\tau_{\text{edge}}$ | Edge class type (extends object classes) |
| $\tau_{\text{walker}}$ | Walker class type (extends object classes) |
| $n, n_i, n_{\text{src}}, n_{\text{dst}}$ | Instances of node classes |
| $e, e_i$ | Instances of edge classes |
| $w, w'$ | Instances of walker classes |
| $o$ | Generic instance of any class |
| **Object-Spatial Constructs** | |
| $\mathcal{P}$ | Path collection (ordered collection of nodes or edges) |
| $\mathcal{P}_N$ | Node path (ordered collection of connected nodes) |
| $\mathcal{P}_E$ | Edge path (ordered collection of connected edges) |
| $Q_w$ | Walker's traversal queue |
| **Operations and References** | |
| $\Rightarrow$ | Spawn operator (activates a walker) |
| $\triangleright$ | Visit statement (adds to walker's traversal queue) |
| $a_{\text{walker}}$ | Walker ability (triggered during traversal) |
| $a_{\text{node}}$ | Node ability (triggered by walker visits) |
| $a_{\text{edge}}$ | Edge ability (triggered by walker traversal) |
| $a^{\text{entry}}$ | Entry ability (triggered on arrival) |
| $a^{\text{exit}}$ | Exit ability (triggered on departure) |
| $\mathbf{self}$ | Self-reference within an instance |
| $\mathbf{here}$ | Contextual reference to current walker's edge or node location |
| $\mathbf{visitor}$ | Contextual reference to current location's visiting walker |
| $\mathbf{path}$ | Contextual reference to current walker's destination queue $Q_w$ |
| $\prec$ | Execution precedence relation between operations; $a \prec b$ means operation $a$ must complete before operation $b$ begins |
| **Set and Logical Notation** | |
| $x \in X$ | $x$ is an element of set $X$ |
| $A \subseteq B$ | Set $A$ is a subset of set $B$ |
| $A \cup B$ | Union of sets $A$ and $B$ |
| $A \cap B$ | Intersection of sets $A$ and $B$ |
| $\wedge$ | Logical AND |
| $\vee$ | Logical OR |
| $\neg$ | Logical NOT |
| $\forall$ | Universal quantification ("for all") |
| $\exists$ | Existential quantification ("there exists") |
| $f : X \rightarrow Y$ | Function $f$ mapping from domain $X$ to codomain $Y$ |
| $:=$ | Definition or assignment |
| $=$ | Equality test |

### Archetypes of Classes

We define four distinct **archetype** classes, extending the traditional class paradigm to incorporate object-spatial semantics:

1. **Object Classes** ($\tau_{\text{obj}}$): These are conventional classes, analogous to traditional OOP class types. Objects can have properties that describe their intrinsic characteristics and methods that operate on those properties. They serve as the foundational building blocks from which other archetypes derive, maintaining backward compatibility with existing OOP concepts while enabling integration with object-spatial extensions.

2. **Node Classes** ($\tau_{\text{node}}$): These extend object classes and can be connected via edges. Nodes represent discrete locations or entities within a topological graph structure. They encapsulate data, compute, and the potential for connections, serving as anchoring points in the object-spatial topology of the program. In addition to object semantics, nodes bind computation to data locations through *abilities*, allowing execution to be triggered by visitation rather than explicit invocation.

3. **Edge Classes** ($\tau_{\text{edge}}$): These represent directed relationships between two node instances and can only be instantiated when two nodes are specified. Edges encode both the topology of connections and the semantics of those connections. Unlike simple references in traditional OOP, edges are first-class object entities with their own properties and behaviors, enabling rich modeling of connection types, weights, capacities, or other relationship attributes. Importantly, edges serve not only as connections but also as traversable locations for walkers, with their own computational context.

4. **Walker Classes** ($\tau_{\text{walker}}$): These model autonomous entities that traverse node and edge objects. Walkers represent active computational elements that move through the data topological structure, processing data or triggering behaviors as they visit different nodes and edges. They enable decoupling of traversal logic from data structure, allowing for modularity in algorithm design and implementation. Walkers embody the paradigm shift of OSP, carrying computational behaviors to data rather than data being passed to computation.

This archetype system creates a complete topological representation framework, where data (in nodes and edges), relationships (as edges), and computational processes (through walkers) are all explicitly modeled and integrated, inverting the traditional paradigm of passing data to functions.

#### Formalization

Let $C$ be the set of all class definitions in the programming model, where:

1. $\tau_{\text{obj}} \in C$ is a standard object class type, representing the universal supertype from which all other archetypes inherit.

2. $\tau_{\text{node}} \subseteq \tau_{\text{obj}}$ represents node class types, which extend object classes with connectivity capabilities and data-bound computation. This subset relationship ensures that nodes inherit all capabilities of objects while adding topological semantics and the ability to bind computation to data locations.

3. $\tau_{\text{edge}} \subseteq \tau_{\text{obj}}$ represents edge class types, which extend object classes with relational semantics. Edges are not merely references but full-fledged objects that encapsulate relationship properties and behaviors, serving as both connections and traversable locations.

4. $\tau_{\text{walker}} \subseteq \tau_{\text{obj}}$ represents walker class types, which extend object classes with mobility semantics within the node-edge structure. Walkers combine data, state, and traversal logic to model computational processes that flow through the topological structure, actualizing the concept of "computation moving to data."

Each instance $n$ of a **node class** $\tau_{\text{node}}$ is defined simply as: $n = ()$.
Nodes exist as independent entities in the topological structure, serving as primary data locations. Unlike edges which require references to nodes, nodes can exist without connections to other elements, though they typically participate in the graph structure through edges that reference them.

Each instance $e$ of an **edge class** $\tau_{\text{edge}}$ is defined as a tuple:

$$e = (n_{\text{src}}, n_{\text{dst}})$$

where:

- $n_{\text{src}}, n_{\text{dst}} \in \tau_{\text{node}}$ are the source and destination node instances, serving as the endpoints of the relationship. These must exist prior to edge creation, establishing a dependency constraint that maintains object-spatial graph integrity.

This formalization ensures that edges properly connect existing nodes, maintaining topological graph consistency within the program.

Each instance $w$ of a **walker class** $\tau_{\text{walker}}$ may exist in one of three states:

$$w = \begin{cases}
(n_{\text{loc}}) & \text{if active within node topological context} \\
(e_{\text{loc}}) & \text{if active within edge topological context} \\
() & \text{if inactive as a standard object}
\end{cases}$$

where $n_{\text{loc}} \in \tau_{\text{node}}$ is the node the walker resides on, or $e_{\text{loc}} \in \tau_{\text{edge}}$ is the edge the walker traverses when active. This location property is dynamic and changes as the walker traverses the topological structure, allowing the walker to access different data contexts based on its current position. When inactive, the walker exists as a standard object without object-spatial context, allowing for manipulation before activation within a object-spatial context.

The **overall topological structure** with active computational elements can be represented as:

$$G = (N, E, W, L)$$

where:
- $N$ is the set of all node instances, representing data locations in the topological space
- $E$ is the set of all edge instances, defining the connectivity between nodes
- $W$ is the set of all walker instances, representing the computational entities
- $L: W \rightarrow N \cup E \cup \{\emptyset\}$ is a location mapping function that associates each walker with its current position in the topology, where $\emptyset$ indicates an inactive walker

This representation captures both the static structural components (nodes and edges) and the dynamic computational elements (walkers) of the object-spatial system, along with their current positions within the topological structure. Next, we introduce the first-class construct of a path collection which represents a traversable path through a object-spatial topology.

### Path Collections ($\mathcal{P}$) and Walker Destination Queues ($Q_w$)

The Object-Spatial Programming model introduces two complementary constructs that govern traversal dynamics: **path collections** ($\mathcal{P}$), which represent potential traversal routes through the topology, and **walker destination queues** ($Q_w$), which manage the actual execution sequence during traversal. Together, these constructs create a flexible yet deterministic framework for computational movement through data spaces.

#### Path Collections

The **path collection** ($\mathcal{P}$) introduces a higher-order topological construct that represents an ordered sequence of nodes and edges within the object-spatial structure. As first-class citizens in the programming model, path collections can be created, modified, and manipulated like any other data structure. This abstraction serves as a critical link between topology and traversal semantics, enabling concise expression of traversal patterns while maintaining the integrity of the object-spatial model.

The intent of the path collection is to provide a unified framework that bridges graph theory and computation, creating a formal way to express how walkers move through connected data structures. Rather than treating node traversals and edge traversals as separate concerns, the path collection unifies them into a single construct that preserves topological relationships while enabling richer expression of traversal algorithms.

A path collection is defined as:
$$\mathcal{P} = [p_1, p_2, \ldots, p_k]$$
where each $p_i \in N \cup E$ (i.e., each element is either a node or an edge), subject to the following constraints:

1. **Origin Connectivity:** The first element $p_1$ must be connected to an origin node $n_{\text{origin}} \in N$, either by being the origin itself or by being an edge with $n_{\text{origin}}$ as an endpoint.

2. **Sequential Connectivity:** For each element $p_i$ where $i > 1$ in $\mathcal{P}$, at least one of the following must hold:
   - If $p_i$ is a node, then there must exist at least one element $p_j$ where $j < i$ such that either:
     - $p_j$ is a node and there exists an edge $e \in E$ connecting $p_j$ and $p_i$, or
     - $p_j$ is an edge with $p_i$ as one of its endpoints

   - If $p_i$ is an edge, then at least one of its endpoints must appear as a node in $\{p_1, p_2, \ldots, p_{i-1}\}$

3. **Path Completeness:** For any element $p_i$ in $\mathcal{P}$, there must exist a path from $n_{\text{origin}}$ to $p_i$ such that all intermediate elements (nodes and edges) on that path are present in the prefix $\{p_1, p_2, \ldots, p_{i-1}\}$. This ensures that the path collection contains at least one valid traversal route to each included element.

4. **Traversal Coherence:** When multiple elements are eligible for inclusion at a given point in the sequence (e.g., multiple nodes connected to previously included elements), their relative ordering follows breadth-first search (BFS) semantics from the most recently added elements, preserving locality of traversal.

This definition ensures topological validity by anchoring all nodes to a common origin while allowing flexible expression of traversal patterns. The breadth-first ordering provides predictability and consistency for walkers traversing the path, particularly when dealing with hierarchical structures where multiple branches might need to be explored.

As first-class citizens, path collections support arbitrary modifications, including additions, removals, reorderings, and transformations, provided that the resulting collection maintains the properties of a valid path collection. Operations such as concatenation, slicing, filtering, and mapping can be applied to path collections, yielding new valid path collections. This flexibility enables algorithmic manipulation of potential traversal paths while preserving the topological integrity of the underlying data structure.

This generalized path collection model reflects a natural way to describe, in a declarative way, potential routes as to how walker may navigate through a data topology. By allowing both nodes and edges in the same sequence while maintaining topological context, path collections enable algorithms to be expressed in terms of the connected data structures they operate on, rather than as abstract operations that receive data as input.

#### Path Construction

Building on the definition of path collections as first-class citizens in the programming model, a path collection can be constructed in several ways:

1. **Explicit Construction**: By directly specifying the ordered sequence of nodes and optional edges:

    $$\mathcal{P} = [p_1, p_2, \ldots, p_k] \text{ where } p_i \in N \cup E$$

    When explicitly constructing path collections, the elements must satisfy the reachability and ordering constraints defined earlier, ensuring that walkers can traverse through the path in a topologically valid sequence. Edges, when included, must immediately precede the nodes they connect to on the reachability path from the origin node.

2. **Query-Based Construction**: By specifying an origin node and a traversal predicate:

    $$\mathcal{P} = \text{path}(n_{\text{origin}}, \text{predicate}, \text{includeEdges}, d)$$

    where:
    - $n_{\text{origin}} \in N$ is the origin node from which all nodes in the path must be reachable
    - $\text{predicate}: N \cup E \rightarrow \{\text{true}, \text{false}\}$ is a function that determines whether an element should be included in the path
    - $\text{includeEdges} \in \{\text{true}, \text{false}\}$ specifies whether edges should be explicitly included in the path collection
    - $d \in \{\text{outgoing}, \text{incoming}, \text{any}\}$ specifies the traversal direction for constructing the path

    The construction algorithm performs a breadth-first traversal from the origin node, adding elements to the path collection according to the predicate and the includeEdges parameter. This ensures that the resulting path maintains proper reachability relations while allowing flexible filtering of elements.

    A common example of query-based construction is creating a path that follows a specific sequence of edge types:

    $$\mathcal{P} = \text{path}(n_{\text{origin}}, \lambda e : e \in E \land \text{type}(e) \in [\tau_{\text{edge}}^1, \tau_{\text{edge}}^2, \ldots, \tau_{\text{edge}}^k] \text{ in sequence}, \text{true}, \text{outgoing})$$

    This creates a path collection starting at $n_{\text{origin}}$ and following only edges that match the specified sequence of edge types. The path resolution algorithm traverses the graph, selecting edges and their connected nodes that conform to this type pattern. A walker traversing this path would follow a route determined by these edge type constraints, enabling declarative specification of complex traversal patterns based on relationship types.

Once constructed, these path collections can be passed to walkers to guide their traversal through the topological structure, as we'll see in the next section on walker destination queues.

#### Walker Destination Queues

While path collections define potential traversal routes through the topology, **walker destination queues** ($Q_w$) represent the actual execution sequence that a walker follows during its traversal. Each active walker $w$ maintains an internal traversal queue $Q_w$ that determines its next destinations:

$$Q_w = [q_1, q_2, \ldots, q_m] \text{ where } q_i \in N \cup E$$

Walker destination queues have several key properties that govern traversal dynamics:

1. **First-In-First-Out (FIFO) Processing**: Walker destination queues follow FIFO semantics, with elements processed in the order they were added. When a walker completes execution at its current location, it automatically moves to the next element in its queue.

2. **Dynamic Modification**: Walker destination queues are designed for dynamic modification during traversal through visit statements and other control flow mechanisms:

    $$\text{visit}(w, n) \Rightarrow Q_w \leftarrow Q_w \cup [n]$$

    This allows walkers to adapt their traversal paths based on discovered data or computed conditions.

3. **Automatic Edge-to-Node Transitions**: When a walker traverses an edge, the appropriate destination node is automatically added to its queue if not already present, ensuring continuity in the traversal process.

4. **Path-to-Queue Conversion**: When a walker spawns on or visits a path collection, the path is converted into queue entries according to traversal requirements:

    $$\text{visit}(w, \mathcal{P}) \Rightarrow Q_w \leftarrow Q_w \cup \text{expandPath}(\mathcal{P}, L(w))$$

    where $\text{expandPath}(\mathcal{P}, L(w))$ transforms the path collection into a physically traversable sequence from the walker's current location $L(w)$. This function ensures that:

    - All elements in $\mathcal{P}$ are included in the expanded queue
    - Any necessary intermediate nodes or edges required for physical traversal between non-adjacent elements are inserted
    - The resulting sequence maintains the relative ordering of elements in the original path collection
    - The expanded path respects the connectivity constraints of the topological structure

    This conversion enables walkers to traverse path collections that express higher-level traversal intent without requiring explicit specification of every intermediate step.

5. **Activity Persistence**: Once a walker transitions to an active state via spawn, it remains active until its queue is exhausted or it is explicitly disengaged. This ensures computational continuity during traversal, maintaining the walker's contextual state throughout its path exploration. When a walker's queue becomes empty after all abilities at its current location have executed, it automatically transitions back to an inactive state. However, while at a node with an empty queue, it temporarily preserves its active status, allowing for potential reactivation through new visit statements before the current execution cycle completes.

The relationship between the path collection ($\mathcal{P}$) and the dynamic walker queue ($Q_w$) creates a flexible yet deterministic traversal model, allowing for both declarative path specifications and runtime adaptation of traversal behavior.

### Abilities

In addition to traditional methods $m: \tau \rightarrow \tau'$, we introduce **abilities**, a new function type $a: \varnothing \rightarrow \varnothing$ with *implicit* execution semantics. Unlike ordinary functions, abilities neither accept explicit arguments nor return values; instead, they gain access to relevant data through the walker or location (node or edge) that triggers them. This represents a fundamental paradigm shift: rather than moving data to computation through parameters and return values, computation is distributed throughout the topology and automatically activated by object-spatial interactions. Abilities are named using the same conventions as methods, providing a consistent interface pattern across the programming model.

Each ability specifies an execution trigger that determines when it is activated during traversal:

**Walker Abilities** $a_{\text{walker}}$ are automatically triggered when a walker enters or exits a node or edge of a specified type:

$$a_{\text{walker}} : (\tau_{\text{location}}, t) \rightarrow \bot$$

where $\tau_{\text{location}} \in \{\tau_{\text{node}}, \tau_{\text{edge}}\}$ and $t \in \{\text{entry}, \text{exit}\}$ specifies whether the ability is triggered upon the walker's entry to or exit from a location of the specified type. This notation indicates the *condition* under which the ability is invoked, rather than a parameter list. The ability thus acts as an event handler for location arrival or departure events. Once invoked, the ability can directly access the triggering walker's data (via $\mathbf{self}$), the location it arrived at or is departing from (via $\mathbf{here}$), and its traversal path and queue (via $\mathbf{path}$). The walker can modify its traversal queue $Q_w$ through visit statements or direct manipulation of $\mathbf{path}$. This allows walkers to respond contextually to different location types they encounter, implementing type-specific processing logic without explicit conditional branching and dynamically adapting their traversal path based on discovered data. The walker serves both as a carrier of computational behavior and as an activator of location-bound computation throughout the topology.

**Node Abilities** $a_{\text{node}}$ are automatically triggered when a walker of a specified type enters or exits the node:

$$a_{\text{node}} : (\tau_{\text{walker}}, t) \rightarrow \bot$$

where $t \in \{\text{entry}, \text{exit}\}$ specifies whether the ability is triggered upon the walker's entry to or exit from the node. Similarly, this indicates the condition (arrival or departure of a walker of type $\tau_{\text{walker}}$), not an explicit parameter. The ability functions as an event handler for walker arrival or departure events. When triggered, the ability can access the node's data (via $\mathbf{self}$), the incoming or outgoing walker (via $\mathbf{visitor}$), and the walker's destination queue (via $\mathbf{path}$). This allows nodes to respond differently to different types of walkers, implementing specialized processing logic based on the visitor type and traversal stage, and potentially influencing the walker's future traversal path. Node abilities demonstrate that nodes are not merely passive data containers but active computational sites that respond to traversal events, embodying the distributed nature of computation in the OSP model.

**Edge Abilities** $a_{\text{edge}}$ are automatically triggered when a walker of a specified type enters or exits the edge:

$$a_{\text{edge}} : (\tau_{\text{walker}}, t) \rightarrow \bot$$

where $t \in \{\text{entry}, \text{exit}\}$ specifies whether the ability is triggered upon the walker's entry to or exit from the edge. This ability functions similarly to node abilities but is specific to edge contexts. When triggered, the ability can access the edge's data (via $\mathbf{self}$), the traversing walker (via $\mathbf{visitor}$), and the walker's destination queue (via $\mathbf{path}$). Edge abilities enable computational behavior to be bound to relationship transitions, allowing for processing that specifically occurs during the movement between nodes, including the possibility of modifying the walker's future traversal path. This enables modeling of transition-specific computation, such as filtering, transformation, or validation of data as it flows through the topological structure. The presence of computational abilities in edges reinforces that in the OSP model, even transitions between data locations are first-class citizens capable of containing and executing computation.

#### Ability Execution Order

When a walker traverses the topological structure, abilities are executed in a consistent, predictable order regardless of location type. This execution order respects both entry/exit specifications and the dual-perspective model of location-walker interaction:

1. **Arrival Phase** - When a walker arrives at any location (node or edge):
   a. First, all relevant location entry abilities for the arriving walker type are executed. This allows the location (node or edge) to respond to the walker's arrival, potentially modifying its own state or the state of the walker. This represents location-bound computation triggered by mobile traversal.

   b. Next, all relevant walker entry abilities for the current location type are executed. This allows the walker to respond to its new context, potentially modifying its own state or the state of the location. This represents mobile computation processing data at its current position.

   c. During execution of these abilities, the walker may modify its traversal queue $Q_w$ through visit statements if at a node, or have its queue automatically updated if at an edge:
      - At nodes: The walker may execute visit statements to enqueue new destinations
      - At edges: The appropriate endpoint node is automatically added to $Q_w$ if not already present, based on traversal direction:
        - If arrived from $n_{\text{src}}$, then $Q_w \leftarrow Q_w \cup [n_{\text{dst}}]$
        - If arrived from $n_{\text{dst}}$, then $Q_w \leftarrow Q_w \cup [n_{\text{src}}]$

2. **Departure Phase** - When a walker prepares to leave any location (node or edge):
   a. First, all relevant walker exit abilities for the current location type are executed. This allows the walker to finalize any processing before departure.

   b. Next, all relevant location exit abilities for the departing walker type are executed. This allows the location to respond to the walker's departure, potentially performing cleanup or transition operations.

   c. After all exit abilities have executed, the walker updates its location to the next element in its queue: $L(w) \leftarrow \text{dequeue}(Q_w)$

3. **Queue Exhaustion** - When a walker's queue $Q_w$ becomes empty after dequeuing:
   a. If the walker is on a node, it remains at that node until further visit statements are executed or until explicitly disengaged

   b. If the walker is on an edge, the program raises an error, as edges cannot be terminal locations

This unified execution order establishes a predictable pattern where locations first respond to walker arrival before walkers process their new context, and walkers prepare for departure before locations respond to their exit. The order is expressed formally as:

$$\begin{array}{c}
\forall a_{\text{loc}}^{\text{entry}} \in l, \forall a_{\text{walker}}^{\text{entry}} \in w : \text{execute}(a_{\text{loc}}^{\text{entry}}) \prec \text{execute}(a_{\text{walker}}^{\text{entry}}) \\
\forall a_{\text{walker}}^{\text{exit}} \in w, \forall a_{\text{loc}}^{\text{exit}} \in l : \text{execute}(a_{\text{walker}}^{\text{exit}}) \prec \text{execute}(a_{\text{loc}}^{\text{exit}})
\end{array}$$

Additionally, the relationship between queue operations and ability execution follows this pattern:

$$\begin{array}{c}
\forall w \in W, \forall l \in L(w) : \text{execute-all-abilities}(w, l) \prec \text{dequeue}(Q_w) \\
\forall w \in W, \forall l' \in \text{dequeue}(Q_w) : \text{dequeue}(Q_w) \prec \text{execute-all-abilities}(w, l')
\end{array}$$

where $\prec$ denotes execution precedence, $l$ represents either a node or edge location, and
$\text{execute-all-abilities}(w, l)$ represents the complete sequence of ability executions for walker $w$ at location $l$.

This execution model creates a bidirectional coupling between data and computation that is central to the OSP paradigm, allowing both locations and walkers to respond to traversal events in a coordinated sequence while maintaining the queue-based traversal mechanism that guides walkers through the topological structure.

#### Self and Contextual References

To support the implicit execution model of abilities, OSP provides special reference mechanisms that give abilities access to their execution context:

- **Self-reference** ($\mathbf{self}$): Traditional self-reference within an instance, providing access to the instance's own properties and methods. In walker abilities, $\mathbf{self}$ refers to the walker instance, while in node or edge abilities, $\mathbf{self}$ refers to the node or edge instance respectively.

- **Here-reference** ($\mathbf{here}$): In walker abilities, $\mathbf{here}$ refers to the current location (node or edge) the walker is positioned at, providing access to the location's properties and methods from the walker's perspective. This enables walkers to interact with their current object-spatial context, representing mobile computation accessing local data.

- **Visitor-reference** ($\mathbf{visitor}$): In node or edge abilities, $\mathbf{visitor}$ refers to the walker triggering the ability, providing access to the walker's properties and methods from the location's perspective. This enables locations to interact with visiting walkers based on their specific properties, representing data-bound computation accessing the mobile computational entity.

- **Path-reference** ($\mathbf{path}$): In all abilities, $\mathbf{path}$ provides access to the walker's traversal path and destination queue $Q_w$, allowing inspection and manipulation of the planned traversal sequence. This enables walkers to dynamically adjust their future movement based on conditions encountered during traversal. The path reference gives runtime access to the entire destination queue, enabling operations such as:
  - Viewing the next planned destinations
  - Modifying the order of destinations
  - Inserting or removing destinations based on runtime conditions
  - Querying path properties such as length, connectivity, or destination types

These contextual references create a dual-perspective model where both walkers and locations can access each other's state when they interact. This bidirectional access pattern enables rich interaction models where both entities can influence each other during traversal events, actualizing the tight coupling between data and computation that characterizes the OSP paradigm.

### Complete Topological Structure

With the foundational elements and constructs defined, we can now formally describe the complete topological structure that embodies a Object-Spatial Program. This structure encapsulates both the interconnected elements and the distributed computational capabilities:

$$G = (N, E, W, Q, L)$$

where:
- $N = \{n_1, n_2, \ldots, n_m\}$ is the set of all node instances, each representing both a data location and a potential site of computation in the topological space
- $E = \{e_1, e_2, \ldots, e_k\}$ is the set of all edge instances, each defining not only connectivity between nodes but also computational behaviors at transitions, where each $e_i = (n_{\text{src}}, n_{\text{dst}})$
- $W = \{w_1, w_2, \ldots, w_j\}$ is the set of all walker instances, representing autonomous computational entities that activate location-bound behaviors
- $Q = \{Q_{w_1}, Q_{w_2}, \ldots, Q_{w_j}\}$ is the set of all walker destination queues, representing the planned traversal sequences for each active walker
- $L: W \rightarrow N \cup E \cup \{\emptyset\}$ is a location mapping function that associates each walker with its current position in the topology, where $\emptyset$ indicates an inactive walker

The state of the topological structure at any given moment during program execution is characterized by:

1. **Distributed Computational Capacity**: Unlike traditional models where computation is centralized in functions, the OSP model distributes computational capabilities across all elements:
   - Nodes contain both data and computational abilities ($a_{\text{node}}$) that activate in response to walker visits
   - Edges contain both relational data and computational abilities ($a_{\text{edge}}$) that execute during transitions
   - Walkers contain both traversal logic and computational abilities ($a_{\text{walker}}$) that respond to encountered locations

2. **Static Topological State**: The configuration of nodes and edges that form the underlying graph structure. This includes:
   - The set of all nodes $N$ with their internal data states and latent computational abilities
   - The set of all edges $E$ with their connection patterns and transition-specific abilities
   - The resulting graph connectivity properties, such as reachability between nodes

3. **Dynamic Computational State**: The current positions and planned movements of walkers within the structure. This includes:
   - The location mapping $L$ that tracks the current position of each walker
   - The traversal queues $Q_{w_i}$ for each active walker $w_i$, defining its future traversal path

As the program executes, this topological structure evolves through several key mechanisms:

1. **Computational Activation**: The OSP model fundamentally inverts traditional computation:
   - Rather than data moving to stationary computation (functions), walkers activate computation embedded within themselves and the data locations they visit
   - Nodes and edges contain dormant computational abilities that are triggered by compatible walkers
   - The interaction between a walker and its current location creates a dynamic computational context where both entities can affect each other

2. **Structural Modifications**: Changes to the node-edge graph through:
   - Creation or deletion of nodes, affecting the set $N$
   - Creation or deletion of edges, affecting the set $E$ and the connectivity of the graph

3. **Path Construction and Utilization**: Although not part of the fundamental structure, path collections $\mathcal{P}$ play a crucial role as programming constructs that:
   - Define traversable routes through the topology
   - Provide abstraction mechanisms for walker traversal patterns
   - Serve as intermediaries between static structure and dynamic traversal

4. **Computational Movements**: Changes to the positions and traversal plans of walkers through:
   - Activation of walkers via the spawn operator, transitioning walkers from inactive objects to active object-spatial entities positioned at specific locations
   - Traversal between nodes and edges via the visit statement, updating the location mapping $L$ and modifying walker destination queues $Q_{w_i}$
   - At each traversal step, triggering a cascade of ability executions that constitute the actual computational work
   - Termination of traversals through disengage statements, removing walkers from the active set

5. **State Transformations**: Changes to the internal states of elements through:
   - Execution of node and edge abilities triggered by walker visits, allowing data locations to compute in response to visitors
   - Execution of walker abilities triggered by encountered locations, allowing computational entities to respond to data contexts
   - Bidirectional modification of properties through the **self** and **here** references
   - Distributed effects as computation ripples through the topology via walker traversal

This complete topological structure $G$ provides a unified mathematical representation of the OSP paradigm's distinctive approach: computation is not centralized in functions but distributed throughout a topological structure. Nodes and edges are not merely passive data containers but active computational sites that respond to walker visits. Walkers serve as both computational entities and activation mechanisms that trigger dormant abilities embedded within the topology.

## Object-Spatial Execution Semantics

The execution model of Object-Spatial Programming combines traditional method invocation with object-spatial traversal operations and context-sensitive execution. This section details how instances are created and how computation flows through the topological structure, fundamentally inverting the traditional relationship where data is moved to computation.

### Instantiation Rules

To maintain object-spatial graph consistency and support higher-order topological structures, OSP enforces specific instantiation constraints for different archetypes and references:

1. **Object Instantiation**: Standard objects follow traditional OOP instantiation patterns, with constructors defining initial state.

2. **Node Instantiation**: Nodes are instantiated like standard objects but gain the additional capability to serve as endpoints for edges and hosts for walkers. Their constructors may initialize object-spatial properties and connection capabilities. Nodes effectively become locations where data resides and computation can be triggered, rather than passive data containers.

3. **Edge Instantiation**: An instance $e$ of an edge class $\tau_{\text{edge}}$ can only be created if two nodes $n_{\text{src}}, n_{\text{dst}}$ exist and are specified upon instantiation. This constraint ensures that edges always connect existing object-spatial elements, preventing dangling connections and maintaining referential integrity within the topological structure.

4. **Walker Instantiation**: An instance $w$ of a walker class $\tau_{\text{walker}}$ can be instantiated as a standard object without an initial location. In this state, the walker functions as a regular object with all its properties and methods accessible, but it does not participate in object-spatial traversal until activated via the spawn operator.

These instantiation rules ensure that all object-spatial elementsâ€”from individual nodes and edges to higher-order path collectionsâ€”maintain topological consistency while providing flexible construction mechanisms. The rules for path collections are particularly important as they bridge between the static topological structure and the dynamic execution patterns of walkers, allowing for complex traversal strategies to be expressed concisely while preserving the integrity of the object-spatial model.

### Lifecycle Management

OSP extends traditional object lifecycle management with specialized rules for object-spatial archetypes:

1. *Object Lifecycle*: Standard object instances follow traditional object lifecycle patterns from OOP, with standard creation, usage, and garbage collection.

2. *Walker Lifecycle*: Walkers have a dual lifecycle, existing first as standard objects and then potentially transitioning to active object-spatial entities through the spawn operator. When active within the topological structure, walkers maintain their position and traversal state. They can be deactivated and return to standard object status under program control or when their traversal completes. This lifecycle reflects the mobile nature of computation in OSP, where algorithmic behaviors physically move through the data topology.

3. *Node Lifecycle*: When a node instance is deleted, all edge instances that connect to or from that node are automatically deleted as well. This cascading deletion ensures object-spatial integrity by preventing dangling edges that would otherwise reference non-existent nodes. This constraint is expressed formally as:

    $$\forall e \in \tau_{\text{edge}} \text{ where } e = (n_{\text{src}}, n_{\text{dst}}) : \text{del}(n_{\text{src}}) \lor \text{del}(n_{\text{dst}}) \Rightarrow \text{del}(e)$$

4. *Edge Lifecycle*: Edge instances exist as long as both their source and destination nodes exist. They are automatically garbage collected when either endpoint node is deleted, or when explicitly deleted by the program.

This lifecycle management system ensures that the topological structure remains consistent throughout program execution, with automatic cleanup of dependent connections when nodes are removed, while providing flexibility for walker activation and deactivation.

### Spawn Operator ($\Rightarrow$)

The **spawn operator** ($\Rightarrow$) activates a walker within the topological structure by placing it at a specified node, edge, or path. This operation transitions the walker from a standard object state to an active object-spatial entity within the graph $G$:

**Spawning on a Single Element**

For spawning on a node:
$$w \Rightarrow n \rightarrow w'$$

where:
- $w$ is a walker instance currently in an inactive state ($L(w) = \emptyset$)
- $n \in N$ is the node where the walker will be spawned
- $w'$ is the resulting active walker with updated location $L(w') = n$
- $Q_{w'} = []$ (empty queue) as no further destinations are automatically queued

For spawning on an edge:
$$w \Rightarrow e \rightarrow w'$$

where:
- $w$ is a walker instance currently in an inactive state ($L(w) = \emptyset$)
- $e = (n_{\text{src}}, n_{\text{dst}}) \in E$ is the edge where the walker will be spawned
- $w'$ is the resulting active walker with updated location $L(w') = e$
- $Q_{w'} = [n_{\text{dst}}]$ by default, as edges cannot be terminal locations and require a subsequent node destination

**Spawning on a Path**

The spawn operator can also be applied to a path collection, allowing a walker to begin traversing a connected substructure:

$$w \Rightarrow \mathcal{P} \rightarrow w'$$

where:
- $w$ is a walker instance currently in an inactive state ($L(w) = \emptyset$)
- $\mathcal{P} = [p_1, p_2, \ldots, p_k]$ is a path collection where each $p_i \in N \cup E$
- $w'$ is the resulting active walker with updated location $L(w') = p_1$
- The remaining elements are directly added to the walker's queue: $Q_{w'} = [p_2, \ldots, p_k]$
- Since $\mathcal{P}$ is well-formed by definition, the path maintains topological validity, ensuring the walker can traverse from each element to the next without additional path resolution

This approach creates a direct mapping between the path collection and the walker's traversal queue, reflecting the assumption that path collections are already topologically valid. The spawn operation initiates the walker's journey through the specified path, activating it at the first element and scheduling visits to all subsequent elements in the exact order provided.

The spawn operation has several important properties that affect the topological structure $G = (N, E, W, Q, L)$:

1. It can only be applied to a walker that is not already active within the topological structure ($L(w) = \emptyset$)

2. When executed, it modifies the location mapping $L$ to position the walker at the specified location (the first element of the spawn target)

3. It initializes the walker's queue $Q_w$ based on the spawn target:
   - For a single node: $Q_w = []$ (empty queue)
   - For a single edge: $Q_w = [n_{\text{dst}}]$ (destination node)
   - For a path: $Q_w = [p_2, \ldots, p_k]$ (remaining path elements)

4. The operation triggers all entry abilities associated with the walker's arrival at the spawn location:
   - First, relevant location entry abilities for the arriving walker type
   - Next, relevant walker entry abilities for the location type

5. After spawning, the walker maintains its active state until either:
   - Its queue is exhausted and all abilities at its final location have executed, at which point it automatically returns to an inactive state
   - It is explicitly terminated via a disengage statement

6. The spawn operator marks the transition of computation from a dormant state to an active participant in the distributed computational system

7. When spawned on a path, the walker traverses the elements in the exact order specified, relying on the path's well-formed nature to maintain topological validity

The path-based spawn operation extends the expressiveness of the OSP model by allowing walkers to be initialized with a complete traversal plan, rather than building the traversal dynamically through visit statements. This enables more declarative expression of algorithms that operate on connected substructures.

The spawn operator creates a clear separation between the initialization and activation phases of walker usage, allowing for complex setup before object-spatial traversal begins. It also marks the moment when the distributed computational model comes alive, with location-bound abilities and walker abilities beginning their interplay throughout the topological structure.

### Visit Statement ($\triangleright$)

The **visit statement** ($\triangleright$) enables a walker to move between nodes and edges in the topological structure, representing the dynamic traversal capability that is central to the OSP model. This statement produces side effects by adding destinations to the walker's traversal queue and can be applied to traverse either a single element, multiple elements based on directional constraints, or an entire path collection.

**Single Element Traversal**

For node to node traversal:
$$w \triangleright n \rightarrow n$$

where $w = (n_{\text{curr}})$ and $n \in \tau_{\text{node}}$, meaning that the walker at node $n_{\text{curr}}$ directly visits node $n$. This requires that a direct edge connection exists between $n_{\text{curr}}$ and $n$, i.e., $\exists e \in \tau_{\text{edge}} : e = (n_{\text{curr}}, n) \lor e = (n, n_{\text{curr}})$.

For node to edge traversal:
$$w \triangleright e \rightarrow \{e, n_{\text{next}}\}$$

where $e = (n_{\text{src}}, n_{\text{dst}})$ and $w = (n_{\text{curr}})$, meaning that the walker at node $n_{\text{curr}}$ moves to edge $e$. This requires that $n_{\text{curr}}$ is one of the endpoints of $e$, i.e., $n_{\text{curr}} = n_{\text{src}} \lor n_{\text{curr}} = n_{\text{dst}}$. Importantly, when a walker visits an edge, both the edge and its appropriate endpoint node are automatically queued in sequence:

- If $n_{\text{curr}} = n_{\text{src}}$, then $n_{\text{next}} = n_{\text{dst}}$
- If $n_{\text{curr}} = n_{\text{dst}}$, then $n_{\text{next}} = n_{\text{src}}$

**Edge Traversal Constraints**

When a walker is positioned on an edge, the visit statement cannot be called. Instead, after completing any edge abilities, the walker automatically transitions to the appropriate endpoint node that was queued during the preceding visit operation:

$$w = (e) \text{ where } e = (n_{\text{src}}, n_{\text{dst}}) \Rightarrow n_{\text{next}}$$

This constraint ensures that edges serve as transitions between nodes rather than locations where traversal decisions are made, maintaining the natural flow of the walker through the topological structure.

**Path Traversal**

The visit statement can be applied to path collections, allowing a walker to traverse a connected substructure:

$$w \triangleright \mathcal{P} \rightarrow \{p_1, p_2, ..., p_k\}$$

where:
- $w$ is an active walker instance currently at node $n_{\text{curr}}$
- $\mathcal{P} = [p_1, p_2, \ldots, p_k]$ is a path collection where each $p_i \in N \cup E$
- The path's first element $p_1$ must be directly reachable from the walker's current location:
  - If $p_1$ is a node, either $n_{\text{curr}} = p_1$ or there exists an edge connecting $n_{\text{curr}}$ and $p_1$
  - If $p_1$ is an edge, $n_{\text{curr}}$ must be an endpoint of $p_1$
- All elements in the path are added to the walker's traversal queue in their path order: $Q_w \leftarrow Q_w \cup [p_1, p_2, \ldots, p_k]$
- Since $\mathcal{P}$ is well-formed by definition, the path maintains topological validity, ensuring the walker can traverse from each element to the next without additional path resolution

Note that a visit statement can only be initiated from a node, not from an edge, in accordance with the edge traversal constraints.

The visit statement has several important properties:

1. It is only valid if the walker is currently active and located at a node within the topological structure. Visit statements cannot be executed while a walker is on an edge.

2. When executed from a node, the walker destination queues up all selected elements to visit after completing execution at its current location.

3. When visiting an edge, both the edge and its appropriate endpoint node are automatically queued, ensuring that walkers always progress through the structure in a node-edge-node pattern.

4. Once the walker completes executing all exit abilities at its current node, it will move to the first queued destination and trigger all relevant entry abilities at that new location.

5. When on an edge, after executing all edge abilities, the walker automatically transitions to the queued endpoint node without requiring an explicit visit statement.

6. This process continues recursively, with the walker moving through all queued locations until there are no more destinations in its queue.

7. When the queue becomes empty after all abilities at the walker's current location have executed, the walker automatically transitions back to an inactive state.

8. Multiple calls to the visit statement from a node append destinations to the walker's existing queue, allowing for dynamic construction of traversal paths during execution.

9. When visiting a path, the walker enqueues all elements in the exact order specified in the path, relying on the path's well-formed nature to maintain topological validity.

10. When a path collection is used with the visit statement, the first element of the path must be directly reachable from the walker's current position, enforcing a strict reachability constraint.

11. When directly visiting a node from another node, the walker implicitly traverses the connecting edge, but does not trigger any edge abilities or perform any edge-specific processing. This provides a shorthand for node-to-node traversal when the intermediate edge context is not relevant to the algorithm.

12. The model ensures that walkers never "get stuck" on edges, as they always automatically progress to nodes where further traversal decisions can be made.

The path-based visit statement extends the expressiveness of the OSP model by allowing walkers to enqueue entire connected substructures for traversal in a single operation. This enables more concise expression of algorithms that operate on related sets of nodes or edges, such as graph search, path following, or subgraph processing.

By supporting node-to-node, node-to-edge, and path-based traversal patterns, the visit statement enables programmatic expression of complex traversal paths, allowing algorithms to navigate the topological structure in a controlled and semantically meaningful way. The automatic queuing of endpoint nodes when visiting edges ensures that walkers maintain the fundamental node-edge-node traversal pattern that reflects the object-spatial topology. The clear distinction that visit statements can only be executed from nodes, not edges, reinforces the concept that nodes are decision points in the traversal process, while edges are transitions between nodes. This embodiment of computation moving to data creates a fundamentally different programming model compared to conventional approaches where data is passed to stationary functions.

### Additional Flow Control Statements

To provide finer control over walker traversal execution, OSP includes two additional specialized flow control statements that operate within the context of object-spatial execution:

**Skip Statement**

The **skip** statement allows a walker to immediately terminate execution at its current location and proceed to the next location in its traversal queue:

$$\text{skip}(w) \Rightarrow L(w) \leftarrow \text{dequeue}(Q_w)$$

where:
- $w$ is the active walker instance with current location $L(w)$
- $Q_w$ is the walker's traversal queue with at least one queued location

When a skip statement is executed:
- All remaining ability execution at the current location is immediately terminated
- Any exit abilities for the current location type are bypassed
- The walker immediately updates its position: $L(w) \leftarrow \text{dequeue}(Q_w)$
- Normal entry ability execution begins at the new location following the established order:
  - First, relevant location entry abilities for the arriving walker type
  - Next, relevant walker entry abilities for the location type

The skip statement is analogous to the *continue* statement in traditional loop constructs, allowing the walker to abort processing at the current location while continuing its overall traversal. This enables efficient implementation of conditional processing logic where certain nodes or edges might be examined but not fully processed based on their properties or the walker's state, providing fine-grained control over the distributed computation process.

**Disengage Statement**

The **disengage** statement allows a walker to immediately terminate its entire object-spatial traversal and return to an inactive object state:

$$\text{disengage}(w) \Rightarrow L(w) \leftarrow \emptyset, Q_w \leftarrow []$$

where:
- $w$ is the active walker instance with current location $L(w) \in N \cup E$

When a disengage statement is executed:
- All remaining ability execution at the current location is immediately terminated
- Any exit abilities for the current location type are bypassed
- The walker's traversal queue is cleared: $Q_w \leftarrow []$
- The walker's location is set to inactive: $L(w) \leftarrow \emptyset$
- The walker transitions from an active participant in the distributed computational system to an inactive object
- The walker retains all its properties and data accumulated during traversal

The disengage statement is analogous to the *break* statement in traditional loop constructs, allowing the walker to completely exit the object-spatial execution context. This enables early termination of traversals when certain conditions are met, such as finding a target node, completing a computation, or encountering an error condition.

Together with the visit statement, these flow control statements provide essential mechanisms for implementing complex traversal algorithms where the path and processing logic may adapt dynamically based on discovered data or computed conditions within the topological structure. They offer precise control over both the walker's movement through the topology and its participation in the distributed computational process that characterizes the OSP model.

## Implementation Considerations

A practical implementation of the Object-Spatial Programming model must address several important concerns that collectively guide the development of concrete OSP implementations in various programming languages. By addressing these aspects systematically, we can ensure that the theoretical OSP model translates into practical, efficient, and usable programming tools that effectively leverage the paradigm shift from moving data to computation to moving computation to data.

### Type Safety
The archetype system should be integrated with the host language's type system to ensure that object-spatial constraints (such as walker traversal rules) are checked at compile time when possible. This integration enables early detection of topology violations and provides developers with immediate feedback about invalid traversal patterns.

### Concurrency
In multi-walker scenarios, access to shared node and edge data must be properly synchronized to prevent race conditions. Implementations may adopt various concurrency models, from simple locking mechanisms to more sophisticated actor-based approaches. The "computation moves to data" paradigm creates new challenges and opportunities for parallel execution models, particularly when multiple walkers operate on overlapping sections of the topological structure.

### Efficiency
Naive implementations of walker traversal could lead to performance issues in large topological structures. Optimizations such as object-spatial indexing, traversal path caching, or parallel walker execution may be necessary for practical applications. The performance characteristics of mobile computation differ from traditional models and may require specialized optimization techniques, particularly for applications with complex traversal patterns or large data structures.

### Integration
OSP should be designed to complement rather than replace existing OOP mechanisms, allowing for gradual adoption and integration with legacy codebases. Hybrid approaches may be needed to bridge the paradigm gap between conventional data-to-computation models and OSP's computation-to-data approach. This enables incremental migration of existing systems toward object-spatial programming patterns while preserving investment in existing code.

### Walker State Management
The multi-state nature of walkers (as standard objects, active on nodes, or active on edges) requires careful state management to ensure consistency between these modes of operation, particularly when transitioning between states via spawn and disengage operations. Implementations must guarantee that walker state remains coherent throughout traversal operations and across transitions between active and inactive states.

### Entry/Exit Ability Optimization
Implementations should efficiently dispatch entry and exit abilities to minimize overhead during traversal operations, particularly in performance-critical applications. The implicit execution model of abilities requires careful design to maintain predictable performance characteristics. Techniques such as ability caching, ahead-of-time compilation, or just-in-time optimization may be necessary for high-performance systems.

### Edge Transition Management
The automatic queuing of edge destination nodes requires efficient handling of traversal queues and execution contexts to maintain predictable walker flow through the topological structure. This includes optimizing the mechanisms for determining the appropriate destination node based on traversal direction and managing the lifecycle of edge-bound computational processes.

### Flow Control Semantics
Implementations must handle visit, skip, and disengage statements efficiently, ensuring proper cleanup of execution contexts and maintaining the integrity of the walker's state during these control flow transitions. This is particularly important for complex traversal patterns where walkers may dynamically alter their paths based on discovered data or computational results.

### Data Locality and Caching
The computation-to-data paradigm can potentially improve data locality and cache efficiency compared to traditional approaches, but implementations must be designed to fully exploit these advantages, particularly when walkers traverse both nodes and edges. Memory layout strategies that co-locate related nodes and edges can significantly improve performance by reducing cache misses during traversal operations.



================================================================================
FILE: docs/learn/examples/agentic_ai/aider-genius-lite/aider-genius-lite.md
================================================================================


# <span style="color: orange">Aider Genius Lite - AI Coding Assistant

## <span style="color: orange">Overview

Aider Genius Lite is a simple Jac-based Streamlit application for AI-powered code generation with task planning and validation. It provides a clean, intuitive interface for generating code from natural language requests with real-time feedback and validation.

## <span style="color: orange">Features

- Simple, clean interface for code generation requests
- Pre-built example requests for quick testing
- Real-time task progress and results display
- Easy code viewing with syntax highlighting
- AI feedback and validation results
- Separate Jac Streamlit frontend and backend

## <span style="color: orange">Files

- `genius_lite.jac` - Backend with AI logic, task processing, and API endpoints
- `frontend.jac` - Streamlit frontend interface

## <span style="color: orange">Complete Code Preview

Here's what you'll build - a simple AI coding assistant in just **two files**:

=== "Frontend Preview"
    ![Aider Genius Lite Frontend](aider.png)

=== "genius_lite.jac"
    ```jac linenums="1"
    --8<-- "docs/learn/examples/agentic_ai/aider-genius-lite/genius_lite.jac"
    ```

=== "frontend.jac"
    ```jac linenums="1"
    --8<-- "docs/learn/examples/agentic_ai/aider-genius-lite/frontend.jac"
    ```

---

## <span style="color: orange">Setup

### <span style="color: orange">Installation

**Install dependencies:**
   ```bash
   pip install jac-streamlit requests jaclang jac-cloud byllm
   ```

4. **Open your browser** to `http://localhost:8501`

## <span style="color: orange">Usage

1. **Start the backend server:**
   ```bash
   jac serve genius_lite.jac
   ```
   The backend API will be available at `http://localhost:8000`

2. **Launch the frontend (in a new terminal):**
   ```bash
   jac streamlit frontend.jac
   ```
   The web interface will be available at `http://localhost:8501`

## <span style="color: orange">Usage Examples

### <span style="color: orange">Basic Code Generation
Try these example requests:

- "Create a Python calculator with basic math operations"
- "Make a simple number guessing game in Python"

> **Looking for the full version?** This is a lite version for learning purposes. Check out the [full-scale Aider Genius project](https://github.com/jaseci-labs/Agentic-AI/tree/main/aider-genius) for a complete implementation with advanced features.

## <span style="color: orange">Code Architecture Deep Dive

### <span style="color: orange">Task Planning System
The core of Genius Lite's intelligence lies in its task planning system, which:
- Analyzes the complexity and scope of user requests
- Breaks down large problems into smaller, manageable components
- Creates dependency graphs for complex multi-step tasks
- Prioritizes execution order for optimal results

### <span style="color: orange">Code Generation Pipeline
1. **Request Analysis**: Understanding the user's intent and requirements
2. **Context Gathering**: Identifying relevant libraries, frameworks, and patterns
3. **Code Synthesis**: Generating code that meets the specified requirements
4. **Quality Assurance**: Validating syntax, logic, and best practices

### <span style="color: orange">Validation Framework
The validation system ensures code quality through:

- **Syntax Checking**: Validates generated code for syntactic correctness
- **Logic Analysis**: Reviews code flow and potential edge cases
- **Best Practice Compliance**: Ensures adherence to coding standards
- **Security Assessment**: Identifies potential security vulnerabilities



### <span style="color: orange">Integration Options

---

*Aider Genius Lite demonstrates the power of agentic AI for code generation, showcasing how intelligent systems can understand, plan, and execute complex programming tasks autonomously.*



================================================================================
FILE: docs/learn/examples/agentic_ai/friendzone-lite/friendzone-lite.md
================================================================================


# <span style="color: orange">Friendzone Lite - AI Memory Capture System

## <span style="color: orange">Overview

Friendzone Lite is an AI-powered memory capture and organization system that helps you extract, refine, and structure memories from images through intelligent conversation. It transforms images into structured, searchable memories through natural language interaction.

## <span style="color: orange">Features

### <span style="color: orange">Image-Based Memory Extraction
- Upload images via URL to start memory capture sessions
- AI analyzes visual content to understand the context
- Extracts initial memory details from image content

### <span style="color: orange">Interactive Memory Refinement
- Conversational interface to gather missing details
- AI asks targeted follow-up questions
- Progressive refinement of memory information

### <span style="color: orange">Structured Memory Organization
- **When**: Date information (YYYY-MM-DD format)
- **Who**: People involved in the memory
- **Where**: Locations relevant to the memory
- **What**: Description of what the memory is about

### <span style="color: orange">Completion Tracking
- Real-time progress indication
- Summary generation when details are complete
- Clear completion status with final memory summary

## <span style="color: orange">Architecture

### <span style="color: orange">Core Components
- **Memory Processing Function**: `update_memory_details()` - AI-powered memory extraction and refinement
- **Session Node**: Maintains persistent memory state across interactions
- **Update Walker**: Handles user interactions and memory updates

```jac
obj Response {
    has follow_up_questions: str;    # Next question to ask
    has summary: str;                # Concise memory summary
    has when: str;                   # Date in YYYY-MM-DD format
    has who: List[str];              # Names of people involved
    has what: str;                   # What the memory is about
    has where: List[str];            # Relevant locations
    has terminate_conversation: bool; # Completion flag
    has show_summary: bool;          # Display summary flag
}
```

## <span style="color: orange">Complete Code Preview

Here's what you'll build - an AI memory capture system in just **two files**:

=== "Frontend Preview"
    ![Friendzone Lite Frontend](friendzone.png)

=== "friendzone_lite.jac"
    ```jac linenums="1"
    --8<-- "docs/learn/examples/agentic_ai/friendzone-lite/friendzone_lite.jac"
    ```

=== "frontend.jac"
    ```jac linenums="1"
    --8<-- "docs/learn/examples/agentic_ai/friendzone-lite/frontend.jac"
    ```

---

## <span style="color: orange">Usage

1. Install dependencies:
   ```bash
   pip install jac-streamlit requests jaclang jac-cloud byllm
   ```

2. Start the Jac Cloud server:
   ```bash
   jac serve friendzone_lite.jac
   ```

3. Run the frontend:
   ```bash
   jac streamlit frontend.jac
   ```

## <span style="color: orange">Usage Workflow

### <span style="color: orange">Step 1: Image Upload
- Provide an image URL of a photo containing a memory you want to capture
- The system supports various image formats (JPEG, PNG, WebP)
- Images can be from social media, cloud storage, or any accessible web location

### <span style="color: orange">Step 2: Initial Analysis
The AI will:
- Analyze the visual content of your image
- Identify key elements like people, places, and activities
- Generate an initial memory framework
- Ask the first targeted question to gather more details

### <span style="color: orange">Step 3: Conversational Refinement
Engage in a natural conversation where the AI will:
- Ask specific questions about missing details
- Focus on one aspect at a time (when, who, where, what)
- Build upon your previous answers
- Gradually complete the memory profile

### <span style="color: orange">Step 4: Memory Completion
When sufficient details are gathered:
- The AI will indicate the conversation is complete
- A comprehensive summary will be generated
- All memory details will be structured and stored

## <span style="color: orange">Example Memory Capture Session

### <span style="color: orange">Initial Image Analysis
**User uploads:** Beach vacation photo with friends

**AI Initial Response:**
"I can see this appears to be a beach scene with several people. To help me capture this memory completely, when was this photo taken?"

### <span style="color: orange">Conversational Flow
**User:** "This was taken last summer, around July 2024"

**AI:** "Great! I can see there are several people in the photo. Can you tell me who these people are?"

**User:** "That's me with my college friends Sarah and Mike"

**AI:** "Wonderful! Where was this beach vacation? Which beach or location was this at?"

**User:** "This was at Santa Monica Beach in California"

**AI:** "Perfect! What was the occasion or what were you doing during this beach visit?"

**User:** "We were celebrating Sarah's birthday with a beach day trip"

### <span style="color: orange">Final Summary
**Generated Memory:**

- **When:** 2024-07-15
- **Who:** User, Sarah, Mike
- **Where:** Santa Monica Beach, California
- **What:** Beach day celebration for Sarah's birthday

## <span style="color: orange">Advanced Features

### <span style="color: orange">Memory Categories
The system automatically categorizes memories:
- **Social Events**: Gatherings, parties, celebrations
- **Travel Experiences**: Vacations, trips, explorations
- **Personal Milestones**: Achievements, life events
- **Daily Moments**: Casual interactions, routine activities

### <span style="color: orange">Context Enhancement
- **Emotional Context**: Captures feelings and atmosphere
- **Environmental Details**: Weather, time of day, setting
- **Activity Recognition**: Identifies specific actions and events
- **Relationship Mapping**: Understands social connections

### <span style="color: orange">Quality Assurance
- **Consistency Checking**: Validates logical coherence of memory details
- **Completeness Assessment**: Ensures all key aspects are captured
- **Accuracy Verification**: Cross-references visual and textual information

> **Looking for the full version?** This is a lite version for learning purposes. Check out the [full-scale FriendZone project](https://github.com/jaseci-labs/Agentic-AI/tree/main/FriendZone) for a complete implementation with advanced features.

## <span style="color: orange">Technical Implementation

### <span style="color: orange">Visual Analysis Pipeline
1. **Image Processing**: Loads and preprocesses uploaded images
2. **Object Detection**: Identifies people, objects, and scenes
3. **Scene Understanding**: Analyzes context and activities
4. **Initial Memory Extraction**: Creates preliminary memory structure

### <span style="color: orange">Conversational AI System
1. **Question Generation**: Creates contextually relevant follow-up questions
2. **Response Processing**: Analyzes and incorporates user answers
3. **Progress Tracking**: Monitors completion of memory aspects
4. **Dialogue Management**: Maintains conversation flow and coherence

### <span style="color: orange">Memory Storage Format
```json
{
  "memory_id": "unique_identifier",
  "created_at": "timestamp",
  "image_url": "source_image_url",
  "details": {
    "when": "2024-07-15",
    "who": ["User", "Sarah", "Mike"],
    "where": ["Santa Monica Beach", "California"],
    "what": "Beach day celebration for Sarah's birthday"
  },
  "summary": "Comprehensive memory description",
  "conversation_log": ["question_response_pairs"]
}
```

## <span style="color: orange">Customization Options

### Question Templates
Modify questioning strategies for different memory types:

- **Event-focused**: Emphasizes activities and occasions
- **People-centered**: Prioritizes social connections and relationships
- **Location-based**: Focuses on geographical and environmental details
- **Time-sensitive**: Emphasizes chronological and temporal aspects

### Analysis Depth
Configure the level of detail for memory capture:

- **Quick Capture**: Basic who, what, when, where
- **Detailed Analysis**: Extended context and emotional elements
- **Comprehensive Profiling**: Full environmental and social mapping

### Integration Possibilities
- **Photo Libraries**: Connect with Google Photos, iCloud, or other services
- **Social Media**: Import memories from Facebook, Instagram, or Twitter
- **Calendar Integration**: Link memories with calendar events and dates
- **Search Functionality**: Build searchable memory databases

## Use Cases and Applications

### Personal Memory Keeping
- **Family Archives**: Document family events and milestones
- **Travel Journals**: Capture vacation and trip memories
- **Life Documentation**: Record personal achievements and experiences
- **Social Memories**: Preserve moments with friends and loved ones

### Professional Applications
- **Event Documentation**: Corporate events and team building activities
- **Project Milestones**: Capture important project moments
- **Training Records**: Document learning experiences and workshops
- **Client Interactions**: Preserve significant business relationships

### Therapeutic and Wellness
- **Memory Therapy**: Support for individuals with memory challenges
- **Mindfulness Practice**: Intentional memory capture and reflection
- **Gratitude Journaling**: Focus on positive experiences and emotions
- **Life Review**: Systematic documentation of life experiences

## Troubleshooting

### Common Issues

**Image Loading Problems:**
- Verify image URL accessibility and format support
- Check internet connection and firewall settings
- Ensure image file size is within reasonable limits

**Conversation Flow Issues:**
- Provide clear, specific answers to AI questions
- If stuck, try rephrasing or providing additional context
- Restart the session if conversation becomes inconsistent

**Memory Quality Concerns:**
- Be specific and detailed in your responses
- Correct any misunderstandings immediately
- Use follow-up sessions to refine captured memories


---

*Friendzone Lite showcases the potential of combining visual AI with conversational intelligence to create meaningful, structured memory systems that preserve and organize life's important moments.*



================================================================================
FILE: docs/learn/examples/agentic_ai/task-manager-lite/task-manager-lite.md
================================================================================


# <span style="color: orange">Task Manager Lite - Intelligent Task Routing System

## <span style="color: orange">Running the Application

1. **Start the backend server:**
   ```bash
   jac serve task_manager.jac
   ```
   The API server will be available at `http://localhost:8000`

2. **Launch the frontend (in a new terminal window):**
   ```bash
   jac streamlit frontend.jac
   ```
   The web interface will be accessible at `http://localhost:8501`

## <span style="color: orange">Usage Examples

Task Management Operationsk Manager Lite is a lightweight AI-powered task management system that intelligently routes user requests to specialized handlers for task management, email writing, and general conversation.

## <span style="color: orange">Features

### <span style="color: orange">Intelligent Routing
- Automatically determines the best handler for your request
- Routes to specialized nodes: TaskHandling, EmailHandling, or GeneralChat
- Uses AI-powered classification for accurate routing

### <span style="color: orange">Task Management
- **Add Tasks**: Create tasks with dates and times
- **Task Summarization**: Get summaries of all scheduled tasks
- **Smart Extraction**: Automatically extracts task details from natural language

### <span style="color: orange">Email Writing
- Generate professional emails for various purposes
- Context-aware email content creation
- Support for different email types (meetings, follow-ups, etc.)

### <span style="color: orange">General Chat
- Ask questions and get intelligent responses
- Get advice on productivity and time management
- General AI assistance for various topics

## <span style="color: orange">Architecture

### <span style="color: orange">Nodes
- **TaskHandling**: Manages task creation, scheduling, and summarization
- **EmailHandling**: Handles email content generation
- **GeneralChat**: Provides general AI conversation capabilities

### <span style="color: orange">Walker
- **task_manager**: Main walker that routes requests and coordinates responses

## <span style="color: orange">Complete Code Preview

Here's what you'll build - an intelligent task routing system in just **two files**:

=== "Frontend Preview"
    ![Task Manager Lite Frontend](task manager.png)

=== "task_manager.jac"
    ```jac linenums="1"
    --8<-- "docs/learn/examples/agentic_ai/task-manager-lite/task_manager.jac"
    ```

=== "frontend.jac"
    ```jac linenums="1"
    --8<-- "docs/learn/examples/agentic_ai/task-manager-lite/frontend.jac"
    ```

---

## <span style="color: orange">Usage

1. Install dependencies:
   ```bash
   pip install jac-streamlit requests jaclang jac-cloud byllm
   ```

1. Start the Jac Cloud server:
   ```bash
   jac serve task_manager.jac
   ```

2. Run the frontend:
   ```bash
   jac streamlit frontend.jac
   ```

### <span style="color: orange">Task Management
- "Add a task to buy groceries tomorrow at 3 PM"
- "Schedule a meeting with the team for Friday at 10 AM"
- "Summarize all my tasks"

### <span style="color: orange">Email Writing
- "Write an email to schedule a meeting with my team"
- "Create a follow-up email for the project update"
- "Write a professional email to request a deadline extension"

### <span style="color: orange">General Chat
- "What are the best practices for time management?"
- "How can I be more productive at work?"
- "What was the most popular programming language in 2020?"

## <span style="color: orange">Requirements

- Python 3.8+
- JAC (Jaseci Action Circuit)
- Streamlit (for frontend)
- OpenAI API key (for GPT-4)

## <span style="color: orange">Configuration

The system uses GPT-4 by default. You can modify the model in `task_manager.jac`:

```jac
glob llm = Model(model_name="gpt-4o");
```

> **Looking for the full version?** This is a lite version for learning purposes. Check out the [full-scale Task Manager project](https://github.com/jaseci-labs/Agentic-AI/tree/main/task_manager) for a complete implementation with advanced features.

## <span style="color: orange">File Structure

1. **Install required dependencies:**
   ```bash
   pip install jac-streamlit jaclang datetime byllm jac-cloud
   ```

### Running the Application

1. **Start the backend server:**
   ```bash
   jac serve task_manager.jac
   ```
   The API server will be available at `http://localhost:8000`

2. **Launch the frontend interface:**
   ```bash
   jac streamlit frontend.jac
   ```
   The web interface will be accessible at `http://localhost:8501`

## Usage Examples

### Task Management Operations

**Creating Tasks:**
```
"Schedule a team meeting with the development team next Tuesday at 2 PM"
"Remind me to call the client about the project update tomorrow morning"
"Add a deadline for the quarterly report submission on March 15th"
```

**Task Queries:**
```
"What do I have scheduled for next week?"
"Show me all my high-priority tasks"
"Summarize my meetings for this month"
```

### <span style="color: orange">Email Generation

**Meeting Invitations:**
```
"Write an email inviting the team to a project kickoff meeting"
"Create a follow-up email for the client presentation yesterday"
```

**Professional Communications:**
```
"Draft an email updating stakeholders on project progress"
"Write a professional response declining a meeting request"
```

### <span style="color: orange">General Chat and Assistance

**Productivity Questions:**
```
"What are some effective time management strategies for remote work?"
"How can I better organize my daily tasks?"
"What's the best way to handle multiple project deadlines?"
```

**Information Requests:**
```
"Explain the Pomodoro technique"
"What are common productivity tools for teams?"
```

## <span style="color: orange">Technical Deep Dive



### <span style="color: orange">Task Extraction Algorithm

Natural language processing extracts structured task information:

```jac
obj Task {
    has title: str;
    has description: str;
    has due_date: str;
    has priority: str;
    has status: str;
    has assignee: str;
}
```

### <span style="color: orange">Email Template System

Dynamic email generation based on context and purpose:

```jac
obj EmailTemplate {
    has subject: str;
    has greeting: str;
    has body: str;
    has closing: str;
    has tone: str; # formal, casual, urgent
}
```

## <span style="color: orange">Advanced Features

### <span style="color: orange">Smart Scheduling
- **Conflict Detection**: Identifies scheduling conflicts automatically
- **Optimal Time Suggestions**: Proposes best meeting times based on availability
- **Calendar Integration**: Syncs with external calendar systems
- **Timezone Handling**: Manages tasks across different time zones

### <span style="color: orange">Task Dependencies
- **Prerequisite Tracking**: Manages task dependencies and ordering
- **Automatic Prioritization**: Adjusts task priorities based on dependencies
- **Progress Monitoring**: Tracks completion of dependent tasks
- **Bottleneck Identification**: Highlights tasks blocking project progress

### <span style="color: orange">Email Context Integration
- **Task-Aware Emails**: Incorporates relevant task information in emails
- **Meeting Summaries**: Generates emails with meeting outcomes and action items
- **Status Updates**: Creates progress reports based on task completion
- **Reminder Emails**: Automated follow-ups for upcoming deadlines

### <span style="color: orange">Learning and Adaptation
- **User Pattern Recognition**: Learns from user preferences and habits
- **Improved Routing**: Enhances intent classification over time
- **Personalized Responses**: Adapts communication style to user preferences
- **Context Memory**: Maintains long-term conversation context


## <span style="color: orange">Future Integration Improvements

### Calendar Systems
- **Google Calendar**: Sync tasks and events with Google Calendar
- **Outlook Integration**: Connect with Microsoft Outlook and Exchange
- **Calendar APIs**: Support for various calendar service APIs
- **ICS Export**: Generate standard calendar files for import

### Communication Platforms
- **Slack Integration**: Send task updates and reminders via Slack
- **Microsoft Teams**: Integrate with Teams for collaborative task management
- **Email Services**: Connect with SMTP servers for automated email sending
- **Notification Systems**: Push notifications for task deadlines and updates

### Project Management Tools
- **Jira Sync**: Synchronize with Jira for software development projects
- **Trello Integration**: Connect with Trello boards and cards
- **Asana Compatibility**: Import and export tasks to Asana projects
- **Custom APIs**: Flexible integration with proprietary systems

## Performance Optimization

### Scalability Features
- **Async Processing**: Handle multiple requests concurrently
- **Caching Systems**: Cache frequent responses and classifications
- **Load Balancing**: Distribute requests across multiple handler instances
- **Database Optimization**: Efficient storage and retrieval of tasks and emails

### Response Time Optimization
- **Predictive Loading**: Pre-load common responses and templates
- **Smart Caching**: Cache personalized responses for frequent users
- **Batch Processing**: Handle multiple similar requests efficiently
- **Resource Management**: Optimal allocation of computational resources

## Security and Privacy

### Data Protection
- **Encryption**: Secure storage of tasks and personal information
- **Access Control**: Role-based permissions for multi-user environments
- **Audit Logging**: Track all system interactions and modifications
- **Data Anonymization**: Protect sensitive information in logs and analytics

### Authentication and Authorization
- **User Authentication**: Secure login and session management
- **API Security**: Token-based authentication for API access
- **Permission Management**: Fine-grained control over feature access
- **Single Sign-On**: Integration with enterprise authentication systems

## Monitoring and Analytics

### Usage Analytics
- **Request Patterns**: Analysis of common user requests and intents
- **Handler Performance**: Metrics on routing accuracy and response quality
- **User Satisfaction**: Feedback collection and satisfaction measurement
- **System Health**: Monitoring of system performance and availability

### Improvement Metrics
- **Classification Accuracy**: Intent recognition success rates
- **Response Quality**: User ratings of generated content
- **Task Completion Rates**: Success metrics for task management features
- **User Engagement**: Metrics on user interaction and retention

---

*Task Manager Lite demonstrates the power of intelligent routing and specialized handling in agentic AI systems, showing how different capabilities can be combined to create comprehensive and effective task management solutions.*



================================================================================
FILE: docs/learn/examples/littleX/tutorial.md
================================================================================


# Tutorial
# Build Your First Social Media App with Jaseci

You'll build **LittleX**, a Twitter-like application, in just 200 lines of code. This tutorial guides you through each step, from installation to deployment.

---

## What You'll Learn

By the end of this tutorial, you'll understand how to:

- **Store data** in connected graph structures
- **Navigate** through relationships between data
- **Add AI features** to your application
- **Deploy** a working social media platform

---

## What You'll Build: LittleX

**LittleX** lets users:

- Create accounts and profiles
- Post messages (tweets)
- Follow other users
- View a personalized feed

### Complete Code Preview

Here's what you'll build - just **200 lines of code** for a full social media platform:

=== "Frontend Preview"
    ![LittleX Frontend](src/front_end.png)

=== "Single User Graph"
      ```mermaid
      graph TD
      %% Root Nodes
      Root1((Root1)):::root --> P1[Profile]:::profile

      %% Tweets
      P1 -->|Post| T1(Tweet):::tweet
      P1 -->|Post| T2(Tweet):::tweet

      %% Comments for P1's Tweet
      T1 --> C1(Comment):::comment
      C1 --> C1a(Comment):::comment
      C1 --> C1b(Comment):::comment
      ```
=== "Multiple User Graph"
      ```mermaid
      graph TD
      %% Subgraph 1: Root1
      subgraph Cluster1[ ]
            direction TB
            Root1((Root1)):::root
            Root1 --> P1[Profile]:::profile
            P1 -->|Post| T1(Tweet):::tweet
            P1 -->|Post| T2(Tweet):::tweet
            T2 --> C4(Comment):::comment
            Root1 -- Follow --> P2
            Root1 -- Like --> T3
      end

      %% Subgraph 2: Root2
      subgraph Cluster2[ ]
            direction TB
            Root2((Root2)):::root
            Root2 --> P2[Profile]:::profile
            P2 -->|Post| T3(Tweet):::tweet
            P2 -->|Post| T4(Tweet):::tweet
            T3 --> C1(Comment):::comment
            C1 --> C1a(Comment):::comment
            C1 --> C1b(Comment):::comment
            Root2 --> T7(Tweet):::tweet
            T7 --> C5(Comment):::comment
            P2 -- Follow --> P3
      end

      %% Subgraph 3: Root3
      subgraph Cluster3[ ]
            direction TB
            Root3((Root3)):::root
            Root3 --> P3[Profile]:::profile
            P3 -->|Post| T5(Tweet):::tweet
            P3 -->|Post| T6(Tweet):::tweet
            T5 --> C2(Comment):::comment
            T6 --> C3(Comment):::comment
      end
      ```

=== "LittleX.jac"
    ```jac linenums="1"
    --8<-- "docs/learn/examples/littleX/src/littleX.jac"
    ```

=== "LittleX.impl.jac"
    ```jac linenums="1"
    --8<-- "docs/learn/examples/littleX/src/littleX.impl.jac"
    ```

=== "LittleX.test.jac"
    ```jac linenums="1"
    --8<-- "docs/learn/examples/littleX/src/littleX.test.jac"
    ```

---

## Before You Start

You'll need:

- **15 minutes** to complete this tutorial
- **Python 3.12 or later** installed
- A text editor or IDE

---

## Step 1: Install Jaseci

Install the required libraries:

```bash
pip install jac_cloud
```

If the install is successful, you'll see:
```
Successfully installed jac_cloud
```

You're ready to start building!

---

## Step 2: Get the Code

Clone the repository:

```bash
git clone https://github.com/Jaseci-Labs/littleX.git
cd littleX
```

Install dependencies:

```bash
# Backend dependencies
pip install -r littleX_BE/requirements.txt

# Frontend dependencies
cd littleX_FE
npm install
cd ..
```

---

## Understanding Jaseci's Building Blocks

Jaseci uses **three main components** to build applications. Let's see how they work together:

### File Structure: Three Files, One Application

Jaseci organizes code into three files that work together automatically:

#### **littleX.jac** - What Your App Has
```jac
# Define what exists
node Profile {
    has username: str;
    can update with update_profile entry;
}
```

#### **littleX.impl.jac** - How Your App Works
```jac
# Define how things work
impl Profile.update {
    self.username = here.new_username;
    report self;
}
```

#### **littleX.test.jac** - Proving It Works
```jac
# Test functionality
test create_tweet {
    root spawn create_tweet(content = "Hello World");
    tweet = [root --> (?Profile) --> (?Tweet)][0];
    check tweet.content == "Hello World";
}
```

### Running Your Code

Jaseci automatically links these files:

```bash
# Run the application
jac run littleX.jac

# Run tests
jac test littleX.jac

# Start API server
jac serve littleX.jac
```

### 1. Nodes: Store Your Data

**Nodes** hold information. In LittleX:

- **Profile nodes** store user information
- **Tweet nodes** store message content
- **Comment nodes** store replies

**Simple Example:**
```jac
node User {
    has username: str;
}
```

This creates a user object with a username.

### 2. Edges: Connect Your Data

**Edges** create relationships between nodes. In LittleX:

- **Follow edges** connect users who follow each other
- **Post edges** connect users to their tweets
- **Like edges** connect users to tweets they liked

**Simple Example:**
```jac
edge Follow {}
```

This creates a "Follow" connection between users.

### 3. Walkers: Make Things Happen

**Walkers** move through your graph and perform actions. They make your app interactive.

**Simple Example:**
```jac
walker create_tweet(visit_profile) {
    has content: str;
    can tweet with Profile entry;
}
```

This walker creates new tweets when users post messages.

---

## Build LittleX Step by Step

Now let's build your social media app by combining these pieces:

### Step 3: Create User Profiles

When someone signs up, we create their profile:

```jac
walker visit_profile {
    can visit_profile with `root entry;
}

impl visit_profile.visit_profile {
    visit [-->(`?Profile)] else {
        new_profile = here ++> Profile();
        grant(new_profile[0], level=ConnectPerm);
        visit new_profile;
    }
}
```

**What this does:** Creates a new profile if one doesn't exist, or visits the existing profile.

### Step 4: Post Messages

Users can create and share posts:

```jac
walker create_tweet(visit_profile) {
    has content: str;
    can tweet with Profile entry;
}

impl create_tweet.tweet {
        embedding = vectorizer.fit_transform([self.content]).toarray().tolist();
        tweet_node = here +>:Post():+> Tweet(content=self.content, embedding=embedding);
        grant(tweet_node[0], level=ConnectPerm);
        report tweet_node;
}
```

**What this does:** Creates a new tweet with the user's message and connects it to their profile.

### Step 5: Follow Other Users

Build your network by following others:

```jac
walker follow_request {}

impl Profile.follow {
    current_profile = [root-->(`?Profile)];
    current_profile[0] +>:Follow():+> self;
    report self;
}
```

**What this does:** Creates a follow relationship between the current user and another user.

### Step 6: View Your Feed

See posts from people you follow:

```jac
walker load_feed(visit_profile) {
    has search_query: str = "";
    has results: list = [];
    can load with Profile entry;
}

impl load_feed.load {
    visit [-->(`?Tweet)];
    for user_node in [->:Follow:->(`?Profile)] {
        visit [user_node-->(`?Tweet)];
    }
    report self.results;
}
```

**What this does:** Collects tweets from the current user and everyone they follow.

---

## Step 7: Run Your App

Let's see your social media platform in action:

### Start the Backend

```bash
jac serve littleX_BE/littleX.jac
```

You should see:
```
INFO: Uvicorn running on http://127.0.0.1:8000
```

Your backend is running!

### Start the Frontend

Open a new terminal:

```bash
cd littleX_FE
npm run dev
```

You should see:
```
Local: http://localhost:5173/
```

Your frontend is ready!

### Try Your App

1. **Open your browser** to: [`http://localhost:5173`](http://localhost:5173)

2. **Test these features**

    - Create an account
    - Post a message
    - Follow someone
    - Check your feed

If everything works, you've successfully built a social media platform!

---

## Key Code Components

Let's examine the main parts of your LittleX app:

### Profile Node
```jac
node Profile {
    has username: str = "";

    can update with update_profile entry;
    can get with get_profile entry;
    can follow with follow_request entry;
    can un_follow with un_follow_request entry;
}
```

This stores user information and defines what users can do.

### Tweet Node
```jac
node Tweet {
    has content: str;
    has embedding: list;
    has created_at: str = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S");

    can update with update_tweet exit;
    can delete with remove_tweet exit;
    can like_tweet with like_tweet entry;
    can remove_like with remove_like entry;
    can comment with comment_tweet entry;

    def get_info() -> TweetInfo;
    can get with load_feed entry;
}
```

This stores tweet content and handles all tweet interactions.

### Follow Implementation
```jac
impl Profile.follow {
    current_profile = [root-->(`?Profile)];
    current_profile[0] +>:Follow():+> self;
    report self;
}
```

This creates the follow relationship between users.

---

## Try These Extensions

Ready to add more features? Try implementing:

1. **Like system** for posts
2. **User search** by username
3. **Comment replies** for deeper conversations
4. **Profile pages** showing user-specific content

---

## What You've Accomplished

You've built a complete social media application. You now understand:

- **Nodes** for storing data
- **Edges** for connecting information
- **Walkers** for creating functionality

Jaseci's graph-based approach works well for social networks where relationships between data are essential.

---

> **Happy coding with Jaseci!** ðŸš€




================================================================================
FILE: docs/learn/examples/mtp_examples/fantasy_trading_game.md
================================================================================


# <span style="color: orange">Tutorial: Building AI Agents for Fantasy Trading Game

This tutorial demonstrates how to build AI agents with persistent state that can conduct conversations, execute trades, and maintain context across interactions. The tutorial covers integrating AI functions for character generation and dialogue systems.

## <span style="color: orange">Overview

This tutorial covers building a trading game system with:
- AI-powered character generation functions
- AI agents that maintain conversation state
- Trading transaction system
- Persistent conversation history
- Context-aware decision making

## <span style="color: orange">Prerequisites

Required dependencies:

```bash
pip install byllm
```

OpenAI API key configuration:
```bash
export OPENAI_API_KEY="your-api-key-here"
```

## <span style="color: orange">Step 1: Define Game Data Structures

Define objects that represent the game world:

```jac
obj InventoryItem {
    has name: str;
    has price: float;
}

obj Person {
    has name: str;
    has age: int;
    has hobby: str;
    has description: str;
    has money: float;
    has inventory: list[InventoryItem];
}

obj Chat {
    has person: str;
    has message: str;
}
```

**Structure definitions:**
- **InventoryItem**: Tradeable objects with name and price
- **Person**: Character data including stats, money, and items
- **Chat**: Message history for conversation context

## <span style="color: orange">Step 2: Configure the AI Model

Configure the LLM for AI operations:

```jac
import from byllm {Model}

glob llm = Model(model_name="gpt-4o");
```

## <span style="color: orange">Step 3: Implement AI-Powered Character Generation

Create AI-integrated functions that generate game characters:

```jac
def make_player() -> Person by llm();

def make_random_npc() -> Person by llm();
```

These AI functions generate characters with appropriate attributes, starting money, and themed inventory items.

## <span style="color: orange">Step 4: Implement Transaction Logic

Create functions for core game mechanics:

```jac
def make_transaction(buyer_name: str, seller_name: str, item_name: str, price: int| None = None) -> bool {
    buyer = person_record[buyer_name];
    seller = person_record[seller_name];

    # Find item in seller's inventory
    item_to_buy = None;
    item_index = -1;
    for i in range(len(seller.inventory)) {
        if seller.inventory[i].name.lower() == item_name.lower() {
            item_to_buy = seller.inventory[i];
            item_index = i;
            break;
        }
    }

    price = price or item_to_buy.price;

    # Validate transaction
    if not item_to_buy or buyer.money < price {
        return False;
    }

    # Execute transfer
    buyer.money -= price;
    seller.money += price;
    buyer.inventory.append(item_to_buy);
    seller.inventory.pop(item_index);
    return True;
}
```

**Transaction processing:**
1. Locates the item in the seller's inventory
2. Validates the buyer has sufficient funds
3. Transfers money and items between characters

## <span style="color: orange">Step 5: Build Conversational AI Agent

Create an AI agent that maintains state and can execute actions:

```jac
def chat_with_player(player: Person, npc: Person, chat_history: list[Chat]) -> Chat
    by llm(method="ReAct", tools=[make_transaction]);
```

**AI agent characteristics:**
- **Maintains State**: Uses `chat_history` to remember previous interactions
- **Reasons**: Processes conversation context using ReAct method
- **Acts**: Can use tools like `make_transaction` when appropriate
- **Persists Context**: Builds understanding across multiple conversation turns

**Agent capabilities:**
- Remember previous conversations through persistent `chat_history`
- Execute trades when agreements are reached
- Negotiate prices within reasonable bounds
- Stay in character while being functional

## <span style="color: orange">Step 6: Implement the Game Loop

Connect all components in the main execution:

```jac
with entry {
    # Generate characters using AI functions
    player = make_player();
    npc = make_random_npc();

    # Register characters for transactions
    person_record[player.name] = player;
    person_record[npc.name] = npc;

    history = [];

    while True {
        # AI agent generates response with state
        chat = chat_with_player(player, npc, history);
        history.append(chat);

        # Display game state
        for p in [player, npc] {
            print(p.name, ":  $", p.money);
            for i in p.inventory {
                print("  ", i.name, ":  $", i.price);
            }
        }

        # Show NPC response and get player input
        print("\n[[npc]] >> ", chat.message);
        inp = input("\n[[Player input]] >> ");
        history.append(Chat(person=player.name, message=inp));
    }
}
```

**Game loop execution:**
1. Uses AI functions to generate characters (stateless)
2. Registers characters for transaction system
3. Uses the AI agent for NPC responses (stateful - maintains conversation history)
4. Accumulates conversation history for persistent context
5. Displays current game state after each interaction

## <span style="color: orange">AI Functions vs AI Agents

### <span style="color: orange">AI Functions (Stateless)

AI-integrated functions that operate without persistent state:
- `make_player()` and `make_random_npc()` - Generate characters but don't retain memory
- These are AI-powered utilities, not agents

### <span style="color: orange">AI Agents (Stateful)

AI systems that maintain persistent state across interactions:
- `chat_with_player()` with `chat_history` parameter - Retains conversation context
- Builds understanding over multiple turns
- Can reference previous interactions

## <span style="color: orange">Implementation Concepts

### <span style="color: orange">Tool Integration

The AI agent accesses application functions through tools:
- The `chat_with_player` AI agent can call `make_transaction`
- The AI extracts parameters from natural language
- Tool results are incorporated into responses

### <span style="color: orange">State Management

The AI agent maintains state through:
- Structured data objects (`Person`, `InventoryItem`)
- Conversation history (`Chat` objects)
- Global registries (`person_record`)

## <span style="color: orange">Running the Implementation

1. Install dependencies: `pip install byllm`
2. Configure OpenAI API key
3. Execute: `jac run fantasy_trading_game.jac`
4. Interact with the AI agent through natural language

Complete source code: [fantasy_trading_game.jac](https://github.com/jaseci-labs/jaseci/blob/main/jac-byllm/examples/fantasy_trading_game.jac)

## <span style="color: orange">Example Interaction

```
[[Npc]] >> Greetings, traveler! I am Thornwick the Wise, an ancient dwarf
with a passion for collecting rare gemstones. I've been mining these
mountains for over 200 years. I notice you carry yourself like an
adventurer - perhaps we could do some trading?

[[Player]] >> Hello! What do you have for sale?

[[Npc]] >> Ah, a direct sort - I like that! I have several treasures from
my decades of mining. I have a pristine Moonstone Amulet that glows with
inner light for 75 gold pieces, and a rare Dwarven Pickaxe forged by my
grandfather for 120 gold. What catches your interest, friend?
```

## <span style="color: orange">Summary

This tutorial demonstrates building AI agents with persistent state alongside AI-powered functions. The `chat_with_player` agent maintains conversation history and can execute trades through tool integration, while character generation functions provide stateless AI capabilities. The structured datatypes serve as a vocabulary for communicating game concepts to the AI, enabling natural language interactions that result in functional game mechanics.



================================================================================
FILE: docs/learn/examples/mtp_examples/rpg_game.md
================================================================================


# <span style="color: orange">Tutorial: Building an AI-Powered RPG Level Generator

In this tutorial, weâ€™ll build a dynamic RPG level generator using LLMs and Jaclangâ€™s `by llm` syntax. The tutorial covers creating a system that uses AI to generate balanced, progressively challenging game levels.

The system creates game levels automatically through structured data types for spatial positioning and game elements, progressive difficulty scaling that adapts to player progress, and dynamic map rendering from AI-generated data.

Youâ€™ll write code, test it, and see AI-generated levels come to life.

<!-- This tutorial demonstrates how to build a dynamic RPG game level generator using Large Language Models (LLMs) and Jaclang's `by llm` syntax. The tutorial covers creating a system that uses AI to generate balanced, progressively challenging game levels. -->

<div align="center">
  <video width="480" height="300" autoplay loop muted playsinline>
    <source src="/learn/examples/mtp_examples/assets/rpg_demo.mp4" type="video/mp4">
    Your browser does not support the video tag.
  </video>
</div>

<!-- <div align="center" style="margin-top: 20px;">
  <iframe width="560" height="315" src="https://www.youtube.com/watch?v=FSIZmwfQD1s"
          title="RPG Level Generator Tutorial"
          frameborder="0"
          allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
          allowfullscreen>
  </iframe>
</div> -->

#### ðŸ“º **Watch the Tutorial**:

You can find the complete video walkthrough of this RPG level generator tutorial. The video covers each step in detail and shows the AI generation process in action.

<div align="center">
<iframe width="560" height="315" src="https://www.youtube.com/embed/FSIZmwfQD1s?si=rNdyOUNiipFDr6Fn" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
</div>

<!-- ## <span style="color: orange">Overview

This tutorial covers building an AI-driven RPG level generator using Jaclang's `by llm` syntax. The system creates game levels automatically through structured data types for spatial positioning and game elements, progressive difficulty scaling that adapts to player progress, and dynamic map rendering from AI-generated data. -->

## <span style="color: orange">Prerequisites

Required dependencies:

```bash
pip install byllm
```

OpenAI API key configuration:
```bash
export OPENAI_API_KEY="your-api-key-here"
```

- Basic knowledge of [Jaclang syntax](/jac_book/)
- Familiarity with game development concepts (optional)

## <span style="color: orange">Implementation Steps

The implementation consists of the following components:

1. **Define Game Data Structures** - Create the building blocks for the game world
2. **Implement AI-Powered Methods** - Use `by llm` to delegate level creation to AI
3. **Build the Level Manager** - Coordinate the generation process
4. **Test and Iterate** - Run the system and validate AI-generated levels

## <span style="color: orange">Step 1: Define Game Data Structures

**What weâ€™re going to do:**

Weâ€™ll set up the core data structures for the game world: positions, walls, levels, and maps. These serve as a vocabulary that the AI uses to understand and generate game content.

### <span style="color: orange">Basic Position and Wall Objects

Create a new file called `level_manager.jac` and start by writing the foundational objects:

```jac linenums="1"
obj Position {
    has x: int, y: int;     # 2D coordinate

}

obj Wall {
    has start_pos: Position, end_pos: Position;       # wall starts and ends here
}
```

- `Position` (Lines 1-2) defines a point in 2D space. `Wall` (Lines 6-7) uses two positions (`start_pos` and  `end_pos`) to define a barrier.

### <span style="color: orange">Game Configuration Objects

Next, define the main game configuration:

```jac linenums="9"
obj Level {
    has name: str, difficulty: int;     # difficulty scaling
    has width: int, height: int, num_wall: int; # spatial constraints
    has num_enemies: int; time_countdown: int;  # enemies + time
    n_retries_allowed: int;     # retries allowed
}

obj Map {
    has level: Level, walls: list[Wall];    # embeds Level + walls
    has small_obstacles: list[Position];    # extra blocks
    has enemies: list[Position];    # enemy positions
    has player_pos: Position;       # player start
}
```

- `Level` (Lines 9-13) describes rules. `Map` (Lines 16-20) describes actual placement of objects.

## <span style="color: orange">Step 2: Implement AI-Powered Generation Methods

**What weâ€™re going to do:**
Weâ€™ll connect to an LLM (GPT-4o here) and define AI-powered methods for generating new levels and maps.

At the top of `level_manager.jac`, import the model:

```jac
import from byllm { Model }

glob llm = Model(model_name="gpt-4o", verbose=True);
```

- `glob llm` sets up GPT-4o as our generator, with `verbose=True` so we can see detailed outputs.

Now define the `LevelManager` object:

```jac linenums="22"
obj LevelManager {
    has current_level: int = 0, current_difficulty: int = 1,
        prev_levels: list[Level] = [], prev_level_maps: list[Map] = [];

    def create_next_level (last_levels: list[Level], difficulty: int, level_width: int, level_height: int)
    -> Level by llm();

    def create_next_map(level: Level) -> Map by llm();
}
```

- The key parts are **Lines 26 and 29**: the `by llm` keyword makes the AI responsible for generating `Level` and `Map` objects.

- For `create_next_level()` (Line 26), we pass these arguments to retuen a complete level as the output:
    - Historical Context: last_levels ensures variety
    - Difficulty Guidance: difficulty scales challenge
    - Spatial Constraints: level_width, level_height

- For `create_next_map()` (Line 29) we return a detailed map as the output by:
    - Taking a high-level `Level`
    - Generating specific positions for walls, enemies, and player
    - Producing a balanced, playable layout

<!-- ### <span style="color: orange">AI Method Implementation

The `by llm` methods work as follows:

**Level Creation Method**
```jac
def create_next_level (last_levels: list[Level], difficulty: int, level_width: int, level_height: int)
-> Level by llm();
```

**Method parameters:**
- **Historical Context**: `last_levels` - Previous levels for ensuring variety
- **Difficulty Guidance**: `difficulty` - Scale the challenge appropriately
- **Spatial Constraints**: `level_width, level_height` - Boundary parameters
- **Expected Output**: Return a complete `Level` object

**Map Generation Method**
```jac
def create_next_map(level: Level) -> Map by llm();
```

**Method function:**

- Takes a high-level `Level` configuration
- Generates specific positions for walls, enemies, and the player
- Creates a balanced, playable layout
- Returns a detailed `Map` object -->

??? note "AI Data Structure Understanding"
    The AI automatically understands data structures. When you pass a `Level` object, the AI knows about all its properties (difficulty, dimensions, enemy count, etc.) and uses this context to make intelligent decisions.

## <span style="color: orange">Step 3: Manage Level Flow

**What weâ€™re going to do:**
Weâ€™ll write logic to coordinate AI generation: keep track of past levels, scale difficulty, and return a new `Level` + `Map`.

Inside `LevelManager`, add:

```jac linenums="31"
def get_next_level -> tuple(Level, Map) {
    self.current_level += 1;

    # Keeping Only the Last 3 Levels
    if len(self.prev_levels) > 3 {
        self.prev_levels.pop(0);
        self.prev_level_maps.pop(0);
    }

    # Generating the New Level
    new_level = self.create_next_level(
        self.prev_levels,
        self.current_difficulty,
        20, 20
    );

    self.prev_levels.append(new_level);

    # Generating the Map of the New Level
    new_level_map = self.create_next_map(new_level);
    self.prev_level_maps.append(new_level_map);

    # Increasing the Difficulty for end of every 2 Levels
    if self.current_level % 2 == 0 {
        self.current_difficulty += 1;
    }

    return (new_level, new_level_map);
}
```

This method executes the following sequence:

1. **Level Counter**: Increments the level number
2. **Memory Management**: Keeps only the last 3 levels
3. **AI Level Generation**: Calls the AI to create a new level
4. **AI Map Generation**: Requests the AI to generate map
5. **Difficulty Progression**: Increases difficulty every 2 levels
6. **Return Results**: Returns both the level config and detailed map

Now letâ€™s add a visualization helper that converts maps into tile grids. Create a function that converts the AI-generated `Map` into game tiles:

```jac linenums="60"
def get_map(map: Map) -> str {
    map_tiles = [['.' for _ in range(map.level.width)] for _ in range(map.level.height)];

    # Place walls
    for wall in map.walls {
        for x in range(wall.start_pos.x, wall.end_pos.x + 1) {
            for y in range(wall.start_pos.y, wall.end_pos.y + 1) {
                map_tiles[y-1][x-1] = 'B';
            }
        }
    }

    # Place obstacles, enemies, and player
    for obs in map.small_obstacles {
        map_tiles[obs.y-1][obs.x-1] = 'B';
    }
    for enemy in map.enemies {
        map_tiles[enemy.y-1][enemy.x-1] = 'E';
    }
    map_tiles[map.player_pos.y-1][map.player_pos.x-1] = 'P';

    # Add border walls
    map_tiles = [['B'] + row + ['B'] for row in map_tiles];
    map_tiles = [['B' for _ in range(map.level.width + 2)]] + map_tiles + [['B' for _ in range(map.level.width + 2)]];
    return [''.join(row) for row in map_tiles];
}
```

**Now:**

- walls become `B`
- enemies become `E`
- player starts at `P`
- border walls wrap around the map


<!-- ### <span style="color: orange">Map Conversion Process

The conversion function executes these operations:

1. **Initialize Grid**: Creates a 2D array filled with '.' (empty space)
2. **Place Walls**: Converts `Wall` objects into 'B' (block) characters
3. **Add Obstacles**: Places small obstacles as additional 'B' characters
4. **Position Enemies**: Places 'E' characters at enemy positions
5. **Place Player**: Sets 'P' character at the player's starting position
6. **Add Borders**: Surrounds the entire map with walls for boundaries

**Game Symbols:**

- `.` = Empty space (walkable)
- `B` = Block/Wall (impassable)
- `E` = Enemy (dangerous)
- `P` = Player (starting position) -->

## <span style="color: orange">Step 4: Test the AI Level Generator

Weâ€™ll test the system by generating AI levels and printing their difficulty, enemies, and maps.

Create a new file called `test_generator.jac`:

```jac linenums="1"
import from level_manager { LevelManager }

with entry {
    level_manager = LevelManager();

    print("Generating 3 AI-powered levels...\n");

    for i in range(3) {
        level, map_obj = level_manager.get_next_level();
        visual_map = level_manager.get_map(map_obj);

        print(f"=== LEVEL {i+1} ===");
        print(f"Difficulty: {level.difficulty}");
        print(f"Enemies: {level.num_enemies}");
        print(f"Walls: {level.num_wall}");
        print("Map:");
        for row in visual_map {
            print(row);
        }
        print("\n");
    }
}
```

Run this script:
```bash
jac run test_generator.jac
```

Expected output (AI may vary):
```
=== LEVEL 1 ===
Difficulty: 1
Enemies: 2
Walls: 3
Map:
BBBBBBBBBBBBBBBBBBBBBB
B..................B
B.....B............B
B..................B
B........E.........B
B..................B
B..........P.......B
B..................B
B.E................B
BBBBBBBBBBBBBBBBBBBBBB
```

## <span style="color: orange">Summary

<!-- This tutorial demonstrates building an AI-powered RPG level generator that implements: -->
Now you have:

- **AI Integration**: Using `by llm` syntax to delegate complex generation tasks
- **Structured Data Design**: Creating types that guide AI understanding
- **Progressive Systems**: Building difficulty curves and variety mechanisms
- **Practical Application**: Converting AI output into usable game content

The approach combines structured programming with AI creativity. The developer provides the framework and constraints, while the AI handles the creative details.

For more details access the [full documentation of MTP](/learn/jac-byllm/with_llm).



================================================================================
FILE: docs/learn/examples/rag_chatbot/Overview.md
================================================================================


# Build an AI-Powered Multimodal MCP Chatbot

This step-by-step guide will walk you through building a modern chatbot that can chat with your documents, images, and videos. By the end, you'll have a working multimodal AI assistant and understand how to use Jac's unique programming features to build intelligent applications.

## What You'll Build

You'll create a chatbot that can:

- Upload and chat with PDFs, text files, images, and videos
- Search your documents and provide context-aware answers
- Answer general questions using web search
- Understand and discuss images and videos using AI vision
- Route different types of questions to specialized AI handlers


## What You'll Learn

- **Object Spatial Programming**: Use Jac's node-walker architecture to organize your application
- **Mean Typed Programming (MTP)**: Let AI classify and route user queries automatically with just simple definitions
- **Model Context Protocol (MCP)**: Build modular, reusable AI tools
- **Multimodal AI**: Work with text, images, and videos in one application

## Technologies We'll Use

- **Jac Language**: For the main application logic
- **Jac Cloud**: Backend server infrastructure
- **Streamlit**: User-friendly web interface
- **ChromaDB**: Document search and storage
- **OpenAI GPT**: AI chat and vision capabilities
- **Serper API**: Real-time web search

## Project Structure

We'll create six main files:

- `client.jac`: The web interface for chat and file uploads
- `server.jac`: The main application using Object Spatial Programming
- `server.impl.jac`: Implementation details and function bodies for `server.jac` (automatically imported by Jac)
- `mcp_server.jac`: Tool server for document search and web search
- `mcp_client.jac`: Interface to communicate with tools
- `tools.jac`: Document processing and search logic

### Complete Code Preview

Here's what you'll build - a full AI-powered multimodal MCP chatbot:

=== "Frontend Preview"
    ![Chatbot Workflow](images/image.png)

=== "client.jac"
    ```jac linenums="1"
    --8<-- "docs/learn/examples/rag_chatbot/solution/client.jac"
    ```

=== "server.jac"
    ```jac linenums="1"
    --8<-- "docs/learn/examples/rag_chatbot/solution/server.jac"
    ```

=== "server.impl.jac"
    ```jac linenums="1"
    --8<-- "docs/learn/examples/rag_chatbot/solution/server.impl.jac"
    ```

=== "mcp_server.jac"
    ```jac linenums="1"
    --8<-- "docs/learn/examples/rag_chatbot/solution/mcp_server.jac"
    ```

=== "mcp_client.jac"
    ```jac linenums="1"
    --8<-- "docs/learn/examples/rag_chatbot/solution/mcp_client.jac"
    ```

=== "tools.jac"
    ```jac linenums="1"
    --8<-- "docs/learn/examples/rag_chatbot/solution/tools.jac"
    ```

The full source code for this project is also available at: [https://github.com/jaseci-labs/Agentic-AI/tree/main/jac-mcp-chatbot](https://github.com/jaseci-labs/Agentic-AI/tree/main/jac-mcp-chatbot)

---

## Step 1: Set Up Your Environment

First, install the required packages. We recommend Python 3.12 or newer:

```bash
pip install jaclang jac-cloud jac-streamlit byllm langchain langchain-community langchain-openai langchain-chroma chromadb openai pypdf tiktoken requests mcp[cli] anyio
```

Next, get your API keys. You'll need an OpenAI API key for the AI features. For web search, get a free API key from [Serper](https://serper.dev/).

Set your environment variables:

```bash
export OPENAI_API_KEY=<your-openai-key>
export SERPER_API_KEY=<your-serper-key>
```

If you see no errors, you're ready to start building!

## Step 2: Understanding the Architecture

Your application uses Jac's Object Spatial Programming to create a clean, modular design:

**Nodes** represent different parts of your system (Router, Chat types, Sessions). Each node has specific responsibilities and capabilities.

**Walkers** move through your node network, carrying information and executing logic. They represent the actions your system can perform.

**Mean Typed Programming (MTP)** lets AI automatically classify and route requests, making your application intelligent without complex rule-based logic.

**Implementation Separation**: The `server.jac` file contains the high-level structure and logic, while `server.impl.jac` provides the detailed function implementations. Jac seamlessly imports the implementation file, allowing for clean separation of concerns.

The application consists of:

- **Document Processing Engine** (`tools.jac`): Processes and searches documents using vector embeddings
- **Tool Server** (`mcp_server.jac`): Exposes document and web search as MCP tools
- **Tool Client** (`mcp_client.jac`): Interfaces with the tool server
- **Main Application** (`server.jac` + `server.impl.jac`): Routes queries and manages conversations
- **Web Interface** (`client.jac`): User-friendly Streamlit interface

## Step 3: Run Your Application

Now let's see your creation in action! You'll need three terminal windows:

**Terminal 1 - Start the tool server:**
```bash
jac run mcp_server.jac
```

**Terminal 2 - Start the main application:**
```bash
jac serve server.jac
```

**Terminal 3 - Launch the web interface:**
```bash
jac streamlit client.jac
```

If everything starts successfully, open your browser and go to the Streamlit URL (typically `http://localhost:8501`).

## Step 4: Test Your Chatbot

1. **Register and log in** using the web interface
2. **Upload some files**: Try PDFs, text files, images, or videos
3. **Start chatting**: Ask questions about your uploaded content or general questions

The system will automatically route your questions:

- Document questions go to the RAG system
- General questions use web search
- Image questions use vision AI
- Video questions analyze video content

## What You've Accomplished

Congratulations! You've built a sophisticated AI application that demonstrates several advanced concepts:

- **Multimodal AI capabilities** that work with text, images, and videos
- **Intelligent routing** using AI-based classification
- **Modular architecture** with reusable tools via MCP
- **Clean separation of concerns** using Object Spatial Programming
- **Real-time web search integration**
- **Efficient document search** with vector embeddings

## Extending Your Chatbot

Your chatbot is designed to be extensible. You could add:

- **New file types**: Support for audio files, spreadsheets, or presentations
- **Additional tools**: Weather APIs, database connections, or custom business logic
- **Enhanced AI models**: Different LLMs for specialized tasks
- **Advanced search**: Hybrid search combining keyword and semantic search
- **Custom chat nodes**: Specialized handlers for domain-specific questions

## Troubleshooting

If you run into issues:

- **Dependencies**: Make sure all packages are installed and compatible with your Python version
- **Server startup**: Start the MCP server before the main server
- **File uploads**: Check server logs if uploads fail, and verify supported file types
- **API keys**: Verify your OpenAI and Serper API keys are set correctly
- **Ports**: Ensure all three services are running on their respective ports

## API Reference

Your application exposes these main endpoints:

- `POST /user/register` â€” Create a new user account
- `POST /user/login` â€” Login and get an access token
- `POST /walker/upload_file` â€” Upload files (requires authentication)
- `POST /walker/interact` â€” Chat with the AI (requires authentication)

Visit `http://localhost:8000/docs` to see the full API documentation.

---

You now have the foundation to build sophisticated AI applications using Jac's unique programming paradigms. The combination of Object Spatial Programming, Mean Typed Programming, and modular tool architecture gives you a solid base for creating intelligent, scalable applications.




================================================================================
FILE: docs/learn/getting_started.md
================================================================================

# Getting Started with Jac

This guide will help you install and set up Jac for development.


<h1 style="color: orange; font-weight: bold; text-align: center;">Getting Started With Jac and Jaseci</h1>

# Installation

Firstly make sure that Python 3.12 or higher is installed in your environment, then simply install Jac using pip:

```bash
python -m pip install -U jaclang
```

Once you've got Jaclang installed, just give the Jac CLI a try to make sure everything's up and running smoothly.

- Start the Jac CLI:
    ```bash
    jac --version
    ```
- Run a .jac file
    ```bash
    jac run <file_name>.jac
    ```
- To test run a 'Hello World' Program
    ```bash
    echo "with entry { print('Hello world'); }" > test.jac;
    jac run test.jac;
    rm test.jac;
    ```
> **Note**
>
> If these commands prints ```Hello world``` you are good to go.

## <span style="color: orange">Installing the VS Code Extension</span>

In addition to setting up JacLang itself, you may also want to take advantage of the JacLang language extension for Visual Studio Code (VSCode) or Cursor. This will give you enhanced code highlighting, autocomplete, and other useful language features within your editor environment.

**For VS Code users:**
- Visit the VS Code marketplace and install the [Jac Extension](https://marketplace.visualstudio.com/items?itemName=jaseci-labs.jaclang-extension)

**For Cursor users:**
1. Go to the [latest Jaseci release page](https://github.com/Jaseci-Labs/jaseci/releases/latest)
2. Download the latest `jaclang-extension-*.vsix` file from the release assets
3. Open Cursor
4. Press `Ctrl+Shift+P` (or `Cmd+Shift+P` on Mac)
5. Type `>install from vsix` and select the command
6. Select the downloaded VSIX file
7. The extension will be installed and ready to use

## Next Steps

<div class="grid cards" markdown>

-   __Jac in a Flash__

    ---

    *See Jac's Syntax with a Toy*

    [Jac in a Flash](jac_in_a_flash.md){ .md-button .md-button--primary }

-   __A Real World Example__

    ---

    *See somthing real in Jac*

    <!-- [:octicons-arrow-right-24: Getting started](#) -->

    [A Robust Example](examples/littleX/tutorial.md){ .md-button }

-   __Experience Jac in Browser__

    ---

    *Hit the Playground*

    [Jac Playground](../playground/index.html){ .md-button .md-button--primary }

</div>





## Installation Details


# Getting Started with Jac: Installation, Setup, and Your First Program
---
The first step is setting up your development environment. We'll cover how to install Jac, configure your code editor, and write and run your first program.


> To get started, you will need Python 3.12 or newer. While you can use any text editor, we recommend using VS Code with the official Jac extension for the best experience, as it provides helpful features like syntax highlighting and error checking.

[Installation section removed - see Getting Started]
## Hello World in Jac
---
Let's write and run your first Jac program.
1. Create a new file named hello.jac.
2. Add the following code to the file:

```jac
# hello.jac
with entry {
    print("Hello, Jac World!");
}
```
<br />

Run the program from your terminal.
```bash
$ jac run hello.jac
```
<br />

You will see the following output:

<br />

```bash
Hello, Jac World!
```
<br />

If you see this information, you have installed Jac successfully! You're ready to write your first program.



## Next Steps

<div class="grid cards" markdown>

-   __Jac in a Flash__

    ---

    *See Jac's Syntax with a Toy*

    [Jac in a Flash](jac_in_a_flash.md){ .md-button .md-button--primary }

-   __A Real World Example__

    ---

    *See somthing real in Jac*

    <!-- [:octicons-arrow-right-24: Getting started](#) -->

    [A Robust Example](examples/littleX/tutorial.md){ .md-button }

-   __Experience Jac in Browser__

    ---

    *Hit the Playground*

    [Jac Playground](../playground/index.html){ .md-button .md-button--primary }

</div>





================================================================================
FILE: docs/learn/jac-byllm/create_own_lm.md
================================================================================


# Create Your Own Language Model

This guide will help you to bring your own language model to be used with byLLM. This is helpful if you have a self-hosted Language Model or you are using a different service that is not currently supported by byLLM.

> **IMPORTANT**
>
> This assumes that you have a proper understanding on how to inference with your language model. If you are not sure about this, please refer to the documentation of your language model.

## Steps

- Create a new class that inherits from `BaseLLM` class.

In Python,
```python linenums="1"
from byllm.llms.base import BaseLLM

class MyLLM(BaseLLM):
    def __init__(self, verbose: bool = False, max_tries: int = 10, **kwargs):
        self.verbose = verbose
        self.max_tries = max_tries
        # Your model initialization code here

    def __infer__(self, meaning_in: str | list[dict], **kwargs) -> str:
        # Your inference code here
        # If you are using a Multimodal (VLLM) model, use the list of dict -> openai format input with encoded images
        #  kwargs are the model specific parameters
        return 'Your response'
```

In Jaclang,
```jac linenums="1"
import from mtlm.llms.base {BaseLLM}

class MyLLM(BaseLLM) {
    def init(verbose:bool=false, max_tries:int=10, **kwargs: dict) -> None {
        self.verbose = verbose;
        self.max_tries = max_tries;
        # Your model initialization code here
    }

    def __infer__(meaning_in:str|list[dict], **kwargs: dict) -> str {
        # Your inference code here
        # If you are using a Multimodal (VLLM) model, use the list of dict -> openai format input with encoded images
        # kwargs are the model specific parameters
        return 'Your response';
    }
}
```

- Initialize your model with the required parameters.

```jac
import from my_llm {MyLLM}

# Initialize as global variable
glob llm = MyLLM();

# Initialize as local variable
with entry {
    llm = MyLLM();
}
```

## Changing the Prompting Techniques

You can change the prompting techniques overriding the the following parameters in your class.

```python
from byllm.llms.base import BaseLLM

class MyLLM(BaseLLM):
    byLLM_SYSTEM_PROMPT = 'Your System Prompt'
    byLLM_PROMPT = 'Your Prompt' # Not Recommended to change this
_METHOD_PROMPTS = {
        "Normal": 'Your Normal Prompt',
        "Reason": 'Your Reason Prompt',
        "Chain-of-Thoughts": 'Your Chain-of-Thought Prompt',
        "ReAct": 'Your ReAct Prompt',
    }
    OUTPUT_FIX_PROMPT = 'Your Output Fix Prompt'
    OUTPUT_CHECK_PROMPT = 'Your Output Check Prompt'

    # Rest of the code
```

Thats it! You have successfully created your own Language Model to be used with byLLM.

>  **NOTICE**
>
> We are constantly adding new LMs to the library. If you want to add a new LM, please open an issue [here](https://github.com/Jaseci-Labs/Jaseci/issues).



================================================================================
FILE: docs/learn/jac-byllm/creating_byllm_plugins.md
================================================================================


# Creating byLLM Plugins

This document describes how to create plugins for byLLM (Multi-Modal Large Language Model), which is a plugin system for Jaclang's `by llm()` feature.

## Understanding the Plugin System

byLLM uses a plugin architecture based on [Pluggy](https://pluggy.readthedocs.io/), the same plugin system used by pytest. Plugins allow you to extend or modify how byLLM handles LLM calls in Jaclang programs.

### How Plugins Work

When Jaclang's `by llm()` syntax is used, the runtime system looks for registered plugins that implement the `call_llm` hook. This enables:

- Implement custom LLM providers
- Add preprocessing/postprocessing logic
- Implement caching mechanisms
- Add logging or monitoring
- Create mock implementations for testing

## Plugin Architecture Overview

The plugin system consists of three main components:

1. **Hook Specifications**: Define the interface that plugins must implement
2. **Hook Implementations**: Your plugin code that implements the hooks
3. **Plugin Registration**: How plugins are discovered and loaded

## Creating Your First Plugin

### Step 1: Set Up Your Plugin Package

Create a Python package for the plugin:

```
my-byllm-plugin/
â”œâ”€â”€ pyproject.toml
â”œâ”€â”€ README.md
â””â”€â”€ my_byllm_plugin/
    â”œâ”€â”€ __init__.py
    â””â”€â”€ plugin.py
```

### Step 2: Define Your Plugin Class

Create the plugin implementation in `my_byllm_plugin/plugin.py`:

```python
"""Custom byLLM Plugin."""

from typing import Callable

from jaclang.runtimelib.machine import hookimpl
from byllm.llm import Model


class MybyllmMachine:
    """Custom byLLM Plugin Implementation."""

    @staticmethod
    @hookimpl
    def call_llm(
        model: Model, caller: Callable, args: dict[str | int, object]
    ) -> object:
        """Custom LLM call implementation."""
        # Custom logic implementation
        print(f"Custom plugin intercepted call to: {caller.__name__}")
        print(f"Arguments: {args}")

        # Option 1: Modify the call and delegate to the original model
        result = model.invoke(caller, args)

        # Option 2: Implement completely custom logic
        # result = your_custom_llm_logic(caller, args)

        print(f"Result: {result}")
        return result
```

### Step 3: Configure Package Registration

Register the plugin using entry points in `pyproject.toml`:

```toml
[tool.poetry]
name = "my-byllm-plugin"
version = "0.1.0"
description = "My custom byLLM plugin"
authors = ["Your Name <your.email@example.com>"]

[tool.poetry.dependencies]
python = "^3.11"
byllm = "*"
jaclang = "*"

[tool.poetry.plugins."jac"]
my-byllm-plugin = "my_byllm_plugin.plugin:MybyllmMachine"

[build-system]
requires = ["poetry-core>=1.0.0"]
build-backend = "poetry.core.masonry.api"
```

### Step 4: Install and Test Your Plugin

1. Install the plugin in development mode:
   ```bash
   pip install -e .
   ```

2. Create a test Jaclang file to verify plugin functionality:
   ```jaclang
   import:py from byllm, Model;

   glob llm = Model(model_name="gpt-3.5-turbo");

   can test_plugin {
       result = get_answer("What is 2+2?") by llm();
       print(result);
   }

   can get_answer(question: str) -> str by llm();

   with entry {
       test_plugin();
   }
   ```

3. Run the test:
   ```bash
   jac run test.jac
   ```

## Advanced Plugin Examples

### Example 1: Caching Plugin

```python
"""Caching byLLM Plugin."""

import hashlib
import json
from typing import Callable, Any

from jaclang.runtimelib.machine import hookimpl
from byllm.llm import Model


class CachingbyllmMachine:
    """Plugin that caches LLM responses."""

    _cache: dict[str, Any] = {}

    @staticmethod
    @hookimpl
    def call_llm(
        model: Model, caller: Callable, args: dict[str | int, object]
    ) -> object:
        """Cache LLM responses."""
        # Create cache key from function and arguments
        cache_key = hashlib.md5(
            json.dumps({
                "function": caller.__name__,
                "args": str(args),
                "model": model.model_name
            }, sort_keys=True).encode()
        ).hexdigest()

        # Check cache first
        if cache_key in CachingbyllmMachine._cache:
            print(f"Cache hit for {caller.__name__}")
            return CachingbyllmMachine._cache[cache_key]

        # Call original implementation
        result = model.invoke(caller, args)

        # Store in cache
        CachingbyllmMachine._cache[cache_key] = result
        print(f"Cached result for {caller.__name__}")

        return result
```

### Example 2: Logging Plugin

```python
"""Logging byLLM Plugin."""

import time
from typing import Callable

from jaclang.runtimelib.machine import hookimpl
from byllm.llm import Model


class LoggingbyllmMachine:
    """Plugin that logs all LLM calls."""

    @staticmethod
    @hookimpl
    def call_llm(
        model: Model, caller: Callable, args: dict[str | int, object]
    ) -> object:
        """Log LLM calls with timing information."""
        start_time = time.time()

        print(f"[LLM CALL] Starting: {caller.__name__}")
        print(f"[LLM CALL] Model: {model.model_name}")
        print(f"[LLM CALL] Args: {args}")

        try:
            result = model.invoke(caller, args)
            duration = time.time() - start_time

            print(f"[LLM CALL] Completed: {caller.__name__} in {duration:.2f}s")
            print(f"[LLM CALL] Result: {result}")

            return result

        except Exception as e:
            duration = time.time() - start_time
            print(f"[LLM CALL] Failed: {caller.__name__} after {duration:.2f}s")
            print(f"[LLM CALL] Error: {e}")
            raise
```

### Example 3: Custom Model Provider

```python
"""Custom Model Provider Plugin."""

from typing import Callable

from jaclang.runtimelib.machine import hookimpl
from byllm.llm import Model


class CustomProviderMachine:
    """Plugin that implements a custom model provider."""

    @staticmethod
    @hookimpl
    def call_llm(
        model: Model, caller: Callable, args: dict[str | int, object]
    ) -> object:
        """Handle custom model providers."""

        # Check if this is a custom model
        if model.model_name.startswith("custom://"):
            return CustomProviderMachine._handle_custom_model(
                model, caller, args
            )

        # Delegate to default implementation
        return model.invoke(caller, args)

    @staticmethod
    def _handle_custom_model(
        model: Model, caller: Callable, args: dict[str | int, object]
    ) -> object:
        """Implement custom model logic."""
        model_type = model.model_name.replace("custom://", "")

        if model_type == "echo":
            # Simple echo model for testing
            return f"Echo: {list(args.values())[0]}"
        elif model_type == "random":
            # Random response model
            import random
            responses = ["Yes", "No", "Maybe", "I don't know"]
            return random.choice(responses)
        else:
            raise ValueError(f"Unknown custom model: {model_type}")
```

## Plugin Hook Reference

### call_llm Hook

The primary hook that all byLLM plugins implement:

```python
@hookimpl
def call_llm(
    model: Model,
    caller: Callable,
    args: dict[str | int, object]
) -> object:
    """
    Called when Jaclang executes a 'by llm()' statement.

    Args:
        model: The Model instance with configuration
        caller: The function being called with LLM
        args: Arguments passed to the function

    Returns:
        The result that should be returned to the Jaclang program
    """
```

## Best Practices

### 1. Handle Errors Gracefully

```python
@hookimpl
def call_llm(model: Model, caller: Callable, args: dict[str | int, object]) -> object:
    try:
        return model.invoke(caller, args)
    except Exception as e:
        # Log error and provide fallback
        print(f"LLM call failed: {e}")
        return "Error: Unable to process request"
```

### 2. Preserve Original Functionality

Unless you're completely replacing the LLM functionality, always delegate to the original implementation:

```python
@hookimpl
def call_llm(model: Model, caller: Callable, args: dict[str | int, object]) -> object:
    # Your pre-processing logic
    result = model.invoke(caller, args)  # Delegate to original
    # Your post-processing logic
    return result
```

### Use Configuration

Configure plugin behavior:

```python
class ConfigurableMachine:
    def __init__(self):
        self.config = self._load_config()

    def _load_config(self):
        # Load from environment, file, etc.
        return {"enabled": True, "log_level": "INFO"}

    @hookimpl
    def call_llm(self, model: Model, caller: Callable, args: dict[str | int, object]) -> object:
        if not self.config["enabled"]:
            return model.invoke(caller, args)

        # Plugin logic implementation
```

### 4. Testing Your Plugin

Create comprehensive tests:

```python
import pytest
from byllm.llm import Model
from my_byllm_plugin.plugin import MybyllmMachine

def test_plugin():
    machine = MybyllmMachine()
    model = Model("mockllm", outputs=["test response"])

    def test_function(x: str) -> str:
        """Test function."""
        pass

    result = machine.call_llm(model, test_function, {"x": "test input"})
    assert result == "test response"
```

## Plugin Discovery and Loading

Plugins are automatically discovered and loaded when:

1. They're installed as Python packages
2. They register the `"jac"` entry point in their `pyproject.toml`
3. Jaclang is imported or run

The discovery happens in `jaclang/__init__.py`:

```python
plugin_manager.load_setuptools_entrypoints("jac")
```

## Debugging Plugins

### Enable Debug Logging

Set environment variables to see plugin loading:

```bash
export JAC_DEBUG=1
jac run your_script.jac
```

### Verify Plugin Registration

Check if the plugin is loaded:

```python
from jaclang.runtimelib.machine import plugin_manager

# List all registered plugins
for plugin in plugin_manager.get_plugins():
    print(f"Loaded plugin: {plugin}")
```

## Common Pitfalls

1. **Not using `@hookimpl` decorator**: Methods won't be recognized as hook implementations
2. **Incorrect entry point name**: Must be `"jac"` for discovery
3. **Wrong hook signature**: Must match exactly: `call_llm(model, caller, args)`
4. **Forgetting to delegate**: If `model.invoke()` is not called, original functionality is lost

## Conclusion

byLLM plugins extend Jaclang's LLM capabilities through a clean, extensible plugin system. Plugins can add caching, logging, custom providers, and other functionality to enhance the LLM experience.

Key considerations:
- Follow the hook specification exactly
- Test thoroughly with different scenarios
- Document plugin functionality
- Consider backward compatibility
- Handle errors gracefully

For more examples and advanced use cases, see the [official byLLM plugin](https://github.com/Jaseci-Labs/jaclang/tree/main/jac-byllm) implementation.




================================================================================
FILE: docs/learn/jac-byllm/examples.md
================================================================================


# byLLM Tutorials and Examples


## Tutorials

<div class="grid cards" markdown>

-   **RPG Game Level Genaration**

    ---

    *A Tutorial on building an AI-Intergrated RPG Game using byLLM.*

    [Start](./../../examples/mtp_examples/rpg_game/){ .md-button }

-   **Fantacy Trading Game**

    ---

    *A text-based trding game where non-player charaters are handled using large language models. This is use tool calling for game mechanics such as bargaining at shops.*

    [Start](./../../examples/mtp_examples/fantasy_trading_game/){ .md-button }

-   **AI-Powered Multimodal MCP Chatbot**

    ---

    *This Tutorial shows how to implemented a agentic AI application using the byLLM package and object-spatiol programming. In additionn MCP integration is demonstrated here.*

    [Start](./../../examples/rag_chatbot/Overview/){ .md-button }

</div>


## Examples

This section collects the example byllm programs bundled in `jac-byllm/examples/`. Examples are grouped by type. For each example the source is shown in a tab so you can quickly inspect the code.

### Core Examples
Small, focused examples that show common byLLM patterns for integrating LLMs in Jac programs.

Repository location: [jac-byllm/examples/core_examples](https://github.com/Jaseci-Labs/jaseci/tree/main/jac-byllm/examples/core_examples)

??? note "Core examples (code)"

    === "personality_finder.jac"
        ```jac linenums="1"
        --8<-- "jac-byllm/examples/core_examples/personality_finder.jac"
        ```

    === "level_genarator.jac"
        ```jac linenums="1"
        --8<-- "jac-byllm/examples/core_examples/level_genarator.jac"
        ```

### Vision / Multimodal examples

Examples that demonstrate multimodal usage (images and video) with byLLM and vision-capable LLMs. Accompanying media files live alongside the Jac code in the repo.

Repository location: [jac-byllm/examples/vision](https://github.com/Jaseci-Labs/jaseci/tree/main/jac-byllm/examples/vision)

??? note "Vision / Multimodal examples (code)"
    Vision-enabled examples that combine image/video inputs with byLLM workflows. Only the Jac code files are shown below; accompanying media are in the examples folder (e.g. `person.png`, `receipt.jpg`, `mugen.mp4`).

    === "math_solver.jac"
        ```jac linenums="1"
        --8<-- "jac-byllm/examples/vision/math_solver.jac"
        ```

    === "personality_finder.jac"
        ```jac linenums="1"
        --8<-- "jac-byllm/examples/vision/personality_finder.jac"
        ```

    === "receipt_analyzer.jac"
        ```jac linenums="1"
        --8<-- "jac-byllm/examples/vision/receipt_analyzer.jac"
        ```

    === "mugen.jac"
        ```jac linenums="1"
        --8<-- "jac-byllm/examples/vision/mugen.jac"
        ```

### Tool-calling examples

Examples showing how to orchestrate external tools (APIs, search, or internal tool servers) from Jac/byLLM and how to coordinate multi-agent workflows.

Repository location: [jac-byllm/examples/tool_calling](https://github.com/Jaseci-Labs/jaseci/tree/main/jac-byllm/examples/tool_calling)

??? note "Tool-calling examples (code)"
    Examples that demonstrate calling external tools, tool orchestration, or multi-agent interactions.

    === "wikipedia_react.jac"
        ```jac linenums="1"
        --8<-- "jac-byllm/examples/tool_calling/wikipedia_react.jac"
        ```

    === "marketing_agency.jac"
        ```jac linenums="1"
        --8<-- "jac-byllm/examples/tool_calling/marketing_agency.jac"
        ```

    === "fantasy_trading_game.jac"
        ```jac linenums="1"
        --8<-- "jac-byllm/examples/tool_calling/fantasy_trading_game.jac"
        ```

    === "debate_agent.jac"
        ```jac linenums="1"
        --8<-- "jac-byllm/examples/tool_calling/debate_agent.jac"
        ```

### Agentic AI examples

Small agentic patterns and lightweight multi-step reasoning examples (multi-turn planning, simple agents). These live under the agentic_ai examples folder.

Repository location: [jac-byllm/examples/agentic_ai](https://github.com/Jaseci-Labs/jaseci/tree/main/jac-byllm/examples/agentic_ai)

??? note "Agentic AI examples (code)"
    Examples that demonstrate small agentic behaviors and light-weight multi-step reasoning.

    === "friendzone_lite.jac"
        ```jac linenums="1"
        --8<-- "jac-byllm/examples/agentic_ai/friendzone_lite.jac"
        ```

    === "genius_lite.jac"
        ```jac linenums="1"
        --8<-- "jac-byllm/examples/agentic_ai/genius_lite.jac"
        ```

### Microbenchmarks

Short, single-purpose microbenchmarks for probing model behavior and performance on targeted tasks. Used for evaluations done in the MTPm paper.

Repository location: [jac-byllm/examples/microbenchmarks](https://github.com/Jaseci-Labs/jaseci/tree/main/jac-byllm/examples/microbenchmarks)

??? note "Microbenchmarks (code)"
    Small microbenchmarks and single-purpose prompts useful for testing model behavior and performance.

    === "text_to_type.jac"
        ```jac linenums="1"
        --8<-- "jac-byllm/examples/microbenchmarks/text_to_type.jac"
        ```

    === "odd_word_out.jac"
        ```jac linenums="1"
        --8<-- "jac-byllm/examples/microbenchmarks/odd_word_out.jac"
        ```

    === "joke_gen.jac"
        ```jac linenums="1"
        --8<-- "jac-byllm/examples/microbenchmarks/joke_gen.jac"
        ```

    === "grammar_checker.jac"
        ```jac linenums="1"
        --8<-- "jac-byllm/examples/microbenchmarks/grammar_checker.jac"
        ```

    === "translator.jac"
        ```jac linenums="1"
        --8<-- "jac-byllm/examples/microbenchmarks/translator.jac"
        ```

    === "essay_review.jac"
        ```jac linenums="1"
        --8<-- "jac-byllm/examples/microbenchmarks/essay_review.jac"
        ```

    === "expert_answer.jac"
        ```jac linenums="1"
        --8<-- "jac-byllm/examples/microbenchmarks/expert_answer.jac"
        ```




================================================================================
FILE: docs/learn/jac-byllm/litellm_proxy.md
================================================================================


# LiteLLM proxy server

<img width="2069" height="1071" alt="image" src="https://github.com/user-attachments/assets/2680a26d-8f66-4288-a06c-5aa02898a91e" />

byLLM model can also be connected to a [LiteLLM proxy server](https://docs.litellm.ai/docs/simple_proxy). This allows you to use the byLLM model as a proxy for LiteLLM, enabling you to leverage the capabilities of byLLM in a LiteLLM environment.

To set up and deploy the LiteLLM proxy server, you can follow the instructions provided in the LiteLLM documentation:

Reference: [https://docs.litellm.ai/docs/proxy/deploy](https://docs.litellm.ai/docs/proxy/deploy)

Once The proxy server is setted up and running, you can connect to it by simply passing the URL of the proxy server to the byLLM model with the parameter `proxy_url`:

```python
from byllm import Model

llm = Model(
    model_name="gpt-4o",                # The model name to be used
    api_key="your_litellm_api_key",     # LiteLLM proxy server key
    proxy_url="http://localhost:8000",  # URL of the LiteLLM proxy server
)
```

Note that the `api_key` parameter is necessary to authenticate the connection, which is not the OpenAI API key but the virtual key (or master key) generated by the LiteLLM proxy server. You can find more information about how to obtain this key in the [LiteLLM documentation](https://docs.litellm.ai/docs/proxy/virtual_keys).



================================================================================
FILE: docs/learn/jac-byllm/multimodality.md
================================================================================


# Using Multi-modal Models

byLLM supports multimodal inputs including text, images, and videos. This section covers how byLLM handles multimodal inputs.

Images are supported in the default byLLM distribution. Video support requires installing byllm with the `video` extra:

```bash
pip install byllm[video]
```

## Image

byLLM supports image inputs through the `Image` format. Images can be provided as input to byLLM functions or methods:

```jac
import from byllm { Model, Image }

glob llm = Model(model_name="gpt-4o");

'Personality of the Person'
enum Personality {
   INTROVERT,
   EXTROVERT
}

sem Personality.INTROVERT = 'Person who is shy and reticent';
sem Personality.EXTROVERT = 'Person who is outgoing and socially confident';



obj Person {
    has full_name: str,
        yod: int,
        personality: Personality;
}

def get_person_info(img: Image) -> Person by llm();

with entry {
    image = Image("photo.jpg");
    person_obj = get_person_info(image);
    print(person_obj);
}
```

Input Image :
[person.png](https://rarehistoricalphotos.com/wp-content/uploads/2022/06/albert-einstein-tongue-3.webp)


??? example "Output"
    Person(full_name='Albert Einstein', yod=1955, personality=Personality.INTROVERT)

In this example, an image of a person is provided as input to the `get_person_info` method. The method returns a `Person` object containing the extracted information from the image.

## Video

byLLM supports video inputs through the `Video` format. Videos can be provided as input to byLLM functions or methods:

```jac
import from byllm { Model, Video }

glob llm = Model(model_name="gpt-4o");

def explain_the_video(video: Video) -> str by llm();

with entry {
    video_file_path = "SampleVideo_1280x720_2mb.mp4";
    target_fps = 1
    video = Video(path=video_file_path, fps=target_fps);
    print(explain_the_video(video));
}
```

Input Video:
[SampleVideo_1280x720_2mb.mp4](https://github.com/Jaseci-Labs/jaseci/raw/refs/heads/main/jac-byllm/tests/fixtures/SampleVideo_1280x720_2mb.mp4)


??? example "Output"
    The video features a large rabbit emerging from a burrow in a lush, green environment. The rabbit stretches and yawns, seemingly enjoying the morning. The scene is set in a vibrant, natural setting with bright skies and trees, creating a peaceful and cheerful atmosphere.




================================================================================
FILE: docs/learn/jac-byllm/python_integration.md
================================================================================


# byLLM as a Library for Python

The byLLM module is a Jaclang plugin that provides AI functionality. Since Jaclang supersets Python, byLLM can be integrated into Python applications. This guide demonstrates how to use byLLM in Python.

byLLM is a Python package that needs to be installed using:

```bash
pip install byllm
```

## Importing byLLM in Python

byLLM functionality is accessed by importing the `byllm` module and using the `by` decorator on functions.

```python linenums="1"
import jaclang
from dataclasses import dataclass
from byllm import Model, Image, by

llm = Model(model_name="gpt-4o")

@dataclass
class Person:
    full_name: str
    description: str
    year_of_birth: int


@by(llm)
def get_person_info(img: Image) -> Person: ...

img = Image("https://bricknellschool.co.uk/wp-content/uploads/2024/10/einstein3.webp")

person = get_person_info(img)
print(f"Name: {person.full_name}, Description: {person.description}, Year of Birth: {person.year_of_birth}")
```
??? example "NOTE:"
    Here byLLM can only use primitive types and dataclasses as input and output types. We are working to resolve this limitation.


## Model Hyper-parameters

In Jaclang, hyper-parameters are set by passing them to the LLM model:

```jac linenums="1"
import from byllm { Model }

glob llm = Model(model_name="gpt-4o")

def generate_joke() -> str by llm(temperature=0.3);
```

The `temperature` hyper-parameter controls the randomness of the output. Lower values produce more deterministic output, while higher values produce more random output.

In Python, hyper-parameters are passed as follows:

```python linenums="1"
import jaclang
from byllm import Model, by

llm = Model(model_name="gpt-4o")

@by(llm(temperature=0.3))
def generate_joke() -> str: ...
```

## Using Python Functions as Tools

Python functions can be used as tools in byLLM. Functions defined in Python are callable by the LLM to perform specific tasks:

```python linenums="1"
import jaclang
from byllm import Model
llm = Model(model_name="gpt-4o")


def get_weather(city: str) -> str:
    return f"The weather in {city} is sunny."

@by(llm(tools=[get_weather]))
def answer_question(question: str) -> str: ...
```

## Using Semstrings for Semantic Enrichment

In Jac we introduced the `sem` keyword as a means to attach additional semantics to code objects such as object attributes and function argument. The syntax in jac is as follows.

```jac
obj Person {
    has name:str;
    has age:int;
    has ssn: int;
}
sem Person.ssn = "last four digits of the Social Security number"
```

Using `sem` functionality in python is a bit diferent as the attachment is done using a `@sem` decorator.

```python
from jaclang import JacMachineInterface as Jac

@Jac.sem('<Person Semstring>', {
    'name' : '<name semstring>',
    'age' : '<age semstring>',
    'ssn' : "<ssn semstring>"
    }
)
@datclass
class Person:
    name: str
    age: int
    ssn: int
```

!!! note
    The `sem` implementation in Python is a work-in-progress. The Python way of adding semstrings may change in future releases of byLLM.



================================================================================
FILE: docs/learn/jac-byllm/quickstart.md
================================================================================


# Quick Start Guide

## Installation

To get started with byLLM, install the base package:

```bash
pip install byllm
```

## AI-Integrated Function Example

Let's consider an example program where we attempt to categorize a person by their personality using an LLM. For simplicity we will be using names of historical figures.

### Standard Implementation

Traditional implementation of this program with a manual algorithm:

```jac linenums="1"

enum Personality {
    INTROVERT,
    EXTROVERT,
    AMBIVERT
}

def get_personality(name: str) -> Personality {
    # Traditional approach: manual algorithm, prompt-engineered LLM call, etc.
}

with entry {
    name = "Albert Einstein";
    result = get_personality(name);
    print(f"{result} personality detected for {name}");
}
```

**Limitations**: Defining an algorithm in code for this problem is difficult, while integrating an LLM to perform the task would require manual prompt engineering, response parsing, and type conversion to be implemented by the developer.

### byLLM Implementation

The `by` keyword abstraction enables functions to process inputs of any type and generate contextually appropriate outputs of the specified type:

#### Step 1: Configure LLM Model

```jac linenums="1"
import from byllm {Model}

glob llm = Model(model_name="gemini/gemini-2.0-flash");
```

#### Step 2: Implement LLM-Integrated Function

Add `by llm` to enable LLM integration:

```jac linenums="1"
def get_personality(name: str) -> Personality by llm();
```

This will auto-generate a prompt for performing the task and provide an output that strictly adheres to the type `Personality`.

#### Step 3: Execute the Application

Set your API key and run:

```bash
export GEMINI_API_KEY="your-api-key-here"
jac run personality.jac
```

For complete usage methodologies of the `by` abstraction, refer to the [Usage Guide](./usage.md) for documentation on object methods, object instantiation, and multi-agent workflows.


### byLLM Usage in Python

As byLLM is a python package, it can be natively used in jac. The following code show the above example application built in native python with byLLM.

```python linenums="1"
import jaclang
from byllm import Model, by
from enum import Enum

llm = Model(model_name="gemini/gemini-2.0-flash")

class Personality(Enum):
    INTROVERT
    EXTROVERT
    AMBIVERT

@by(model=llm)
def get_personality(name: str) -> Personality: ...

name = "Albert Einstein"
result = get_personality(name)
print(f"{result} personality detected for {name}")
```

To learn more about usage of `by` in python, please refer to [byLLM python Interface](./python_integration.md).




================================================================================
FILE: docs/learn/jac-byllm/usage.md
================================================================================


# AI-Integrated Programming with byLLM

This guide covers different ways to use byLLM for AI-integrated software development in Jaclang. byLLM provides language-level abstractions for integrating Large Language Models into applications, from basic AI-powered functions to complex multi-agent systems. For agentic behavior capabilities, byLLM includes the ReAct method with tool integration.

## Supported Models

byLLM uses [LiteLLM](https://docs.litellm.ai/docs) to provide integration with a wide range of models.

=== "OpenAI"
    ```jac linenums="1"
    import from byllm {Model}

    glob llm = Model(model_name = "gpt-4o")
    ```
=== "Gemini"
    ```jac linenums="1"
    import from byllm {Model}

    glob llm = Model(model_name = "gemini/gemini-2.0-flash")
    ```
=== "Anthropic"
    ```jac linenums="1"
    import from byllm {Model}

    glob llm = Model(model_name = "claude-3-5-sonnet-20240620")
    ```
=== "Ollama"
    ```jac linenums="1"
    import from byllm {Model}

    glob llm = Model(model_name = "ollama/llama3:70b")
    ```
=== "HuggingFace Models"
    ```jac linenums="1"
    import from byllm {Model}

    glob llm = Model(model_name = "huggingface/meta-llama/Llama-3.3-70B-Instruct")
    ```

??? Note
    Additional supported models and model serving platforms are available with LiteLLM. Refer to their [documentation](https://docs.litellm.ai/docs/providers) for model names.

## byLLM for Functions

### Basic Functions

Functions can be integrated with LLM capabilities by adding the `by llm` declaration. This eliminates the need for manual API calls and prompt engineering:

```jac linenums="1"
import from byllm.llm { Model }

glob llm = Model(model_name="gpt-4o");

def translate(text: str, target_language: str) -> str by llm();

def analyze_sentiment(text: str) -> str by llm();

def summarize(content: str, max_words: int) -> str by llm();
```

These functions process natural language inputs and generate contextually appropriate outputs.

### Functions with Reasoning

The `method='Reason'` parameter enables step-by-step reasoning for complex tasks:

```jac linenums="1"
import from byllm.llm { Model }

glob llm = Model(model_name="gpt-4o");

def analyze_sentiment(text: str) -> str by llm(method='Reason');

def generate_response(original_text: str, sentiment: str) -> str by llm();

with entry {
    customer_feedback = "I'm really disappointed with the product quality. The delivery was late and the item doesn't match the description at all.";

    # Function performs step-by-step sentiment analysis
    sentiment = analyze_sentiment(customer_feedback);

    # Function generates response based on sentiment
    response = generate_response(customer_feedback, sentiment);

    print(f"Customer sentiment: {sentiment}");
    print(f"Suggested response: {response}");
}
```

### Structured Output Functions

byLLM supports generation of structured outputs. Functions can return complex types:

```jac linenums="1"
obj Person {
    has name: str;
    has age: int;
    has description: str | None;
}

def generate_random_person() -> Person by llm();

with entry {
    person = generate_random_person();
    assert isinstance(person, Person);
    print(f"Generated Person: {person.name}, Age: {person.age}, Description: {person.description}");
}
```

A more complex example using object schema for context and structured output generation is demonstrated in the [game level generation](../examples/mtp_examples/rpg_game.md) example.


## Context-Aware byLLM Methods

Methods can be integrated with LLM capabilities to process object state and context:

<!-- ### Basic Methods -->

When integrating LLMs for methods of a class, byLLM automatically adds attributes of the initialized object into the prompt of the LLM, adding extra context to the LLM.

```jac linenums="1"
import from byllm.llm { Model }

glob llm = Model(model_name="gpt-4o");

obj Person {
    has name: str;
    has age: int;

    def introduce() -> str by llm();
    def suggest_hobby() -> str by llm();
}

with entry {
    alice = Person("Alice", 25);
    print(alice.introduce());
    print(alice.suggest_hobby());
}
```

<!-- ### Complex AI-Integrated Workflows with Objects -->

<!-- Multi-step workflows can be implemented using object methods: -->

<!-- ```jac linenums="1"
import from byllm.llm { Model }

glob llm = Model(model_name="gpt-4o");

obj Essay {
    has essay: str;

    def get_essay_judgement(criteria: str) -> str by llm();

    def get_reviewer_summary(judgements: dict) -> str by llm();

    "Grade should be 'A' to 'D'"
    def give_grade(summary: str) -> str by llm();
}

with entry {
    essay = "With a population of approximately 45 million Spaniards and 3.5 million immigrants,"
        "Spain is a country of contrasts where the richness of its culture blends it up with"
        "the variety of languages and dialects used. Being one of the largest economies worldwide,"
        "and the second largest country in Europe, Spain is a very appealing destination for tourists"
        "as well as for immigrants from around the globe. Almost all Spaniards are used to speaking at"
        "least two different languages, but protecting and preserving that right has not been"
        "easy for them.Spaniards have had to struggle with war, ignorance, criticism and the governments,"
        "in order to preserve and defend what identifies them, and deal with the consequences.";
    essay = Essay(essay);
    criterias = ["Clarity", "Originality", "Evidence"];
    judgements = {};
    for criteria in criterias {
        judgement = essay.get_essay_judgement(criteria);
        judgements[criteria] = judgement;
    }
    summary = essay.get_reviewer_summary(judgements);
    grade = essay.give_grade(summary);
    print("Reviewer Notes: ", summary);
    print("Grade: ", grade);
}
``` -->

## Adding Explicit Context for Functions, Methods and Objects

Providing appropriate context is essential for optimal LLM performance. byLLM provides multiple methods to add context to functions and objects.

### Adding Context with Docstrings

Docstrings provide context for LLM-integrated functions. byLLM uses docstrings to understand function purpose and expected behavior.

```jac linenums="1"
import from byllm.llm { Model }

glob llm = Model(model_name="gpt-4o");

"""Translate text to the target language."""
def translate(text: str, target_language: str) -> str by llm();

"""Generate a professional email response based on the input message tone."""
def generate_email_response(message: str, recipient_type: str) -> str by llm();
```

### Adding Context with Semantic Strings (Semstrings)

Jaclang provides semantic strings using the `sem` keyword for describing object attributes and function parameters. This is useful for:

- Describing object attributes with domain-specific meaning
- Adding context to parameters
- Providing semantic information while maintaining clean code

```jac linenums="1"
obj Person {
    has name;
    has dob;
    has ssn;
}

sem Person = "Represents the personal record of a person";
sem Person.name = "Full name of the person";
sem Person.dob = "Date of Birth";
sem Person.ssn = "Last four digits of the Social Security Number of a person";

"""Calculate eligibility for various services based on person's data."""
def check_eligibility(person: Person, service_type: str) -> bool by llm();
```

### Additional Context with `incl_info`

The `incl_info` parameter provides additional context to LLM methods for context-aware processing:

```jac linenums="1"
import from byllm.llm { Model }
import from datetime { datetime }

glob llm = Model(model_name="gpt-4o");

obj Person {
    has name: str;
    has date_of_birth: str;

    # Uses the date_of_birth attribute and "today" information
    # from incl_info to calculate the person's age
    def calculate_age() -> str by llm(
        incl_info={
            "today": datetime.now().strftime("%d-%m-%Y"),
        }
    );
}
```


### When to Use Each Approach

- **Docstrings**: Use for function-level context and behavior description
- **Semstrings**: Use for attribute-level descriptions and domain-specific terminology
- **incl_info**: Use to selectively include relevant object state in method calls

The `sem` keyword can be used in [separate implementation files](../../jac_book/chapter_5.md#declaring-interfaces-vs-implementations) for improved code organization and maintainability.

In this example:

<!-- - `greet("Alice")` executes the normal function and returns `"Hello Alice"`
- `greet("Alice") by llm()` overrides the function with LLM behavior
- `format_data(user_data) by llm()` transforms data formatting into human-readable presentation -->


## Tool-Calling Agents with ReAct

The ReAct (Reasoning and Acting) method enables agentic behavior by allowing functions to reason about problems and use external tools. Functions can be made agentic by adding the `by llm(tools=[...])` declaration.

```jac linenums="1"
import from byllm { Model }
import from datetime { datetime }

glob llm = Model(model_name="gpt-4o");

obj Person {
    has name: str;
    has dob: str;
}

"""Calculate the age of the person where current date can be retrieved by the get_date tool."""
def calculate_age(person: Person) -> int by llm(tools=[get_date]);

"""Get the current date in DD-MM-YYYY format."""
def get_date() -> str {
    return datetime.now().strftime("%d-%m-%Y");
}

with entry {
    mars = Person("Mars", "27-05-1983");
    print("Age of Mars =", calculate_age(mars));
}
```

A comprehensive tutorial on [building an agentic application is available here.](../examples/mtp_examples/fantasy_trading_game.md)


## Streaming Outputs

The streaming feature enables real-time token reception from LLM functions, useful for generating content where results should be displayed as they are produced.

Set `stream=True` in the invoke parameters to enable streaming:

```jac linenums="1"
import from byllm { Model }

glob llm = Model(model_name="gpt-4o-mini");

""" Generate short essay (less than 300 words) about the given topic """
def generate_essay(topic: str) -> str by llm(stream=True);


with entry {
    topic = "The orca whale and it's hunting techniques";
    for tok in generate_essay(topic) {
        print(tok, end='', flush=True);
    }
    print(end='\n');
}

================================================================================
FILE: docs/learn/jac-byllm/with_llm.md
================================================================================


<div align="left">
    <img src="/assets/byLLM_name_logo.png" height="150" width="400">
</div>

# **Coding, Less Prompting**

<!-- [![PyPI version](https://img.shields.io/pypi/v/byllm.svg)](https://pypi.org/project/byllm/) [![tests](https://github.com/jaseci-labs/jaseci/actions/workflows/test-jaseci.yml/badge.svg?branch=main)](https://github.com/jaseci-labs/jaseci/actions/workflows/test-jaseci.yml) -->

byLLM is an innovative AI integration framework built for the Jaseci ecosystem, implementing the cutting-edge Meaning Typed Programming (MTP) paradigm. MTP revolutionizes AI integration by embedding prompt engineering directly into code semantics, making AI interactions more natural and maintainable. While primarily designed to complement the Jac programming language, byLLM also provides a powerful Python library interface.


<!-- ## What is MTP?

Meaning-Typed Programming (MTP) is a programming paradigm that automates LLM integration through language-level abstractions. MTP extracts semantic meaning from code to automatically generate prompts and handle response conversion, reducing the need for manual prompt engineering. These abstractions enable seamless LLM integration by automatically generating prompts from code semantics, making it easier to build agentic AI applications. Additional research details are available on arxiv.org.

The MTP concept is implemented in Jac-lang through the **byLLM** plugin, which is available as a PyPI package. -->


<div align="left" style="margin-top: 1em;">
    <a href="https://arxiv.org/abs/2405.08965" class="md-button" style="display: inline-block; margin-right: 10px;">MTP Research</a>
    <a href="./quickstart.md" class="md-button" style="display: inline-block; margin-right: 10px;">Get Started with MTP</a>
    <a href="https://github.com/jaseci-labs/jaseci/tree/main/jac-byllm" class="md-button" style="display: inline-block;">GitHub</a>
</div>

<!-- ![](./assets/byLLM_name_logo.png) -->

<!-- **Quick Links:**

- [About byLLM](https://www.jac-lang.org/learn/jac-byllm/with_llm/)
- [Get started](https://www.jac-lang.org/learn/jac-byllm/quickstart/)
- [Usage docs](https://www.jac-lang.org/learn/jac-byllm/usage/)
- [Research Paper](https://arxiv.org/abs/2405.08965) -->


Installation is simple via PyPI:

```bash
pip install byllm
```

## Basic Example

Consider building an application that translates english to other languages using an LLM. This can be simply built as follows:
=== "Jac"
    ```jac linenums="1"
    import from byllm { Model }

    glob llm = Model(model_name="gpt-4o");

    def translate_to(language: str, phrase: str) -> str by llm();

    with entry {
        output = translate_to(language="Welsh", phrase="Hello world");
        print(output);
    }
    ```
=== "python"
    ```python linenums="1"
    from byllm import Model, by

    llm = Model(model_name="gpt-4o")

    @by(llm)
    def translate_to(language: str, phrase: str) -> str: ...

    output = translate_to(language="Welsh", phrase="Hello world")
    print(output)
    ```

This simple piece of code replaces traditional prompt engineering without introducing additional complexity.

## Power of Types with LLMs

Consider a program that detects the personality type of a historical figure from their name. This can eb built in a way that LLM picks from an enum and the output strictly adhere this type.

=== "Jac"
    ```jac linenums="1"
    import from byllm { Model }
    glob llm = Model(model_name="gemini/gemini-2.0-flash");

    enum Personality {
        INTROVERT,
        EXTROVERT,
        AMBIVERT
    }

    def get_personality(name: str) -> Personality by llm();

    with entry {
        name = "Albert Einstein";
        result = get_personality(name);
        print(f"{result} personality detected for {name}");
    }
    ```
=== "Python"
    ```python linenums="1"
    from byllm import Model, by
    from enum import Enum
    llm =  Model(model_name="gemini/gemini-2.0-flash")

    class Personality(Enum):
        INTROVERT
        EXTROVERT
        AMBIVERT

    @by(model=llm)
    def get_personality(name: str) -> Personality: ...

    name = "Albert Einstein"
    result = get_personality(name)
    print(f"{result} personality detected for {name}")
    ```

Similarly, custom types can be used as output types which force the LLM to adhere to the specified type and produce a valid result.

## Control! Control! Control!

Even if we are elimination prompt engineering entierly, we allow specific ways to enrich code semantics through **docstrings** and **semstrings**.

=== "Jac"
    ```jac linenums="1"
    import from byllm { Model }
    glob llm = Model(model_name="gemini/gemini-2.0-flash");

    """Represents the personal record of a person"""
    obj Person {
        has name: str;
        has dob: str;
        has ssn: str;
    }

    sem Person.name = "Full name of the person";
    sem Person.dob = "Date of Birth";
    sem Person.ssn = "Last four digits of the Social Security Number of a person";

    """Calculate eligibility for various services based on person's data."""
    def check_eligibility(person: Person, service_type: str) -> bool by llm();
    ```
=== "Python"
    ```python linenums="1"
    from jaclang import JacMachineInterface as Jac
    from dataclasses import dataclass
    from byllm import Model, by
    llm =  Model(model_name="gemini/gemini-2.0-flash")

    @Jac.sem('', {  'name': 'Full name of the person',
                    'dob': 'Date of Birth',
                    'ssn': 'Last four digits of the Social Security Number of a person'
                    })
    @dataclass
    class Person():
        name: str
        dob: str
        ssn: str

    @by(llm)
    def check_eligibility(person: Person, service_type: str) -> bool: ...
        """Calculate eligibility for various services based on person's data."""
    ```

Docstrings naturally enhance the semantics of their associated code constructs, while the `sem` keyword provides an elegant way to enrich the meaning of class attributes and function arguments. Our research shows these concise semantic strings are more effective than traditional multi-line prompts.

**ðŸ“š Full Documentation**: [Jac byLLM Documentation](https://www.jac-lang.org/learn/jac-byllm/with_llm/)

**ðŸŽ® Code Examples**: [Jac byLLM Examples](https://www.jac-lang.org/learn/jac-byllm/examples/)

<!-- - [Fantasy Trading Game](https://www.jac-lang.org/learn/examples/mtp_examples/fantasy_trading_game/) - Interactive RPG with AI-generated characters
- [RPG Level Generator](https://www.jac-lang.org/learn/examples/mtp_examples/rpg_game/) - AI-powered game level creation
- [RAG Chatbot Tutorial](https://www.jac-lang.org/learn/examples/rag_chatbot/Overview/) - Building chatbots with document retrieval -->

**ðŸ”¬ Research**: The research paper of byLLM is available on [Arxiv](https://arxiv.org/abs/2405.08965) and accepted for OOPSLA 2025.

## Quick Links

- [Getting Started Guide](https://www.jac-lang.org/learn/jac-byllm/quickstart/)
- [Jac Language Documentation](https://www.jac-lang.org/)
- [GitHub Repository](https://github.com/jaseci-labs/jaseci)

## Contributing

We welcome contributions to byLLM! Whether you're fixing bugs, improving documentation, or adding new features, your help is appreciated.

Areas we actively seek contributions:
- ðŸ› Bug fixes and improvements
- ðŸ“š Documentation enhancements
- âœ¨ New examples and tutorials
- ðŸ§ª Test cases and benchmarks

Please see our [Contributing Guide](https://www.jac-lang.org/internals/contrib/) for detailed instructions.

If you find a bug or have a feature request, please [open an issue](https://github.com/jaseci-labs/jaseci/issues/new/choose).

## Community

Join our vibrant community:
- [Discord Server](https://discord.gg/6j3QNdtcN6) - Chat with the team and community

## License

This project is licensed under the MIT License.

### Third-Party Dependencies

byLLM integrates with various LLM providers (OpenAI, Anthropic, Google, etc.) through [LiteLLM](https://litellm.ai/).

## Cite our research


> Jayanaka L. Dantanarayana, Yiping Kang, Kugesan Sivasothynathan, Christopher Clarke, Baichuan Li, Savini Kashmira, Krisztian Flautner, Lingjia Tang, and Jason Mars. 2025. MTP: A Meaning-Typed Language Abstraction for AI-Integrated Programming. Proc. ACM Program. Lang. 9, OOPSLA2, Article 314 (October 2025), 29 pages. https://doi.org/10.1145/3763092



================================================================================
FILE: docs/learn/jac-cloud/async_walker.md
================================================================================


# Async Walker

## Overview

Async walkers in Jac Cloud allow you to execute walkers asynchronously in separate threads. This is particularly useful for long-running operations that shouldn't block the main execution flow, such as intensive computations or external API calls.

## Basic Usage

To create an async walker, simply add the `async` keyword before the walker declaration:

```jac
async walker sample {
    has value: int = 0;

    can enter with `root entry {
        print("test");
        self.value = 1;
    }
}
```

Key characteristics:

- Executes in a separate thread without blocking the main application
- Returns immediately with a reference ID while continuing execution in the background
- Similar to task scheduling but with a simpler syntax
- Results can be retrieved later using the walker ID

## How It Works

1. When an async walker is triggered, it's scheduled as a background task
2. The API call returns immediately with a walker ID reference
3. The walker executes asynchronously in its own thread
4. Results are stored in the database and can be retrieved later

## Response Format

When you call an async walker, you receive a response containing the walker's unique ID:

```json
{
  "status": 200,
  "walker_id": "w:sample:550e8400-e29b-41d4-a716-446655440000"
}
```

## Retrieving Results

You can retrieve the results of an async walker by using its ID:

```jac
walker view_sample_result {
    has walker_id: str;

    can enter with `root entry {
        # Get a reference to the walker instance
        wlk = &walker_id;

        # Access the walker's attributes
        print(wlk.value);  # Will be 1 after execution completes

        # Check execution status and metadata
        schedule_info = wlk.__jac__.schedule;

        # Print execution details
        print(f"Status: {schedule_info.status}");
        print(f"Executed at: {schedule_info.executed_date}");

        # Check for errors
        if schedule_info.error{
            print(f"Error: {schedule_info.error}");
        }
    }
}
```

## Available Status Information

The `__jac__.schedule` object contains all execution metadata:

| **Field**       | **Description**                                                |
| --------------- | -------------------------------------------------------------- |
| `status`        | Current execution status (pending, running, completed, failed) |
| `node_id`       | ID of the node where the walker was executed                   |
| `root_id`       | ID of the root node of the user who triggered the walker       |
| `execute_date`  | When the walker was scheduled to execute                       |
| `executed_date` | When the walker actually executed                              |
| `http_status`   | HTTP status code for the execution result                      |
| `reports`       | Any values reported during walker execution                    |
| `custom`        | Custom metadata associated with the walker                     |
| `error`         | Error message if execution failed                              |

### Even though those fields are available, we still recommend using a walker's attribute as your status checker for more customizable and direct status updates.

## Example: Long-Running Process

```jac
async walker process_large_dataset {
    has dataset_id: str;
    has results: list = [];

    can enter with `root entry {
        # Simulate long-running process
        dataset = get_dataset(self.dataset_id);

        for item in dataset{
            # Do intensive processing
            processed = complex_computation(item);
            self.results.append(processed);
        }

        # Final result is stored in the walker
        print("Processing complete!");
    }
}

# Retrieve results when needed
walker check_processing {
    has process_id: str;

    can enter with `root entry {
        process = &process_id;

        if process.__jac__.schedule.status == "COMPLETED"{
            print("Results:", process.results);
        }
        else{
            print("Still processing...");
        }
    }
}
```

## Common Use Cases

### 1. Processing Large Datasets

```jac
async walker analyze_data {
    has dataset_id: str;
    has summary: dict = {};

    can enter with `root entry {
        # Fetch data (could take minutes)
        data = fetch_dataset(self.dataset_id);

        # Process each item (CPU intensive)
        for item in data{
            process_item(item);
        }

        # Generate final summary
        self.summary = create_summary(data);
    }
}
```

### 2. Generating Reports

```jac
async walker generate_report {
    has user_id: str;
    has report_type: str;
    has report_url: str;

    can enter with `root entry {
        # Collect user data
        user_data = fetch_user_data(self.user_id);

        # Generate PDF (slow operation)
        report_file = create_pdf_report(user_data, self.report_type);

        # Upload to storage
        self.report_url = upload_file(report_file);

        # Optional: Notify user
        send_email(self.user_id, "Your report is ready!", self.report_url);
    }
}
```

### 3. External API Integration

```jac
async walker sync_with_external_system {
    has account_id: str;
    has sync_status: str = "pending";
    has sync_results: list = [];

    can enter with `root entry {
        # Connect to external API
        self.sync_status = "connecting";
        api_client = connect_to_api();

        # Fetch data (network-bound, can be slow)
        self.sync_status = "fetching";
        external_data = api_client.fetch_account_data(self.account_id);

        # Process and save data
        self.sync_status = "processing";
        for item in external_data{
            result = process_and_save(item);
            self.sync_results.append(result);
        }

        self.sync_status = "complete";
    }
}
```

## Advanced Techniques

### Combining with WebSockets for Real-time Updates

```jac
import from jac_cloud.plugin {WEBSOCKET_MANAGER as socket}

async walker process_with_updates {
    has client_id: str;
    has progress: int = 0;

    can enter with `root entry {
        # Send initial notification
        socket.notify_clients([self.client_id], {
            "type": "progress",
            "data": {"progress": 0}
        });

        # Process in chunks and send updates
        for i in range(10){
            process_chunk(i);
            self.progress = (i+1) * 10;

            # Send progress update via WebSocket
            socket.notify_clients([self.client_id], {
                "type": "progress",
                "data": {"progress": self.progress}
            });
        }

        # Send completion notification
        socket.notify_clients([self.client_id], {
            "type": "complete",
            "data": {"message": "Processing complete!"}
        });
    }
}
```

### Error Handling

```jac
async walker safe_process {
    has input_id: str;
    has success: bool = False;
    has error_message: str = "";
    has results: dict = {};

    can enter with `root entry {
        try {
            # Attempt processing
            data = fetch_data(self.input_id);
            if not data{
                self.error_message = "No data found";
                return;
            }

            self.results = process_data(data);
            self.success = True;
        } except e {
            # Capture error details
            self.error_message = str(e);
            log_error(self.input_id, str(e));
        }
    }
}
```

## Next Steps

- Learn about [Task Scheduling](scheduler.md) for recurring tasks
- Explore [WebSockets](websocket.md) for real-time communication
- Set up [Logging](logging.md) to monitor your async processes




================================================================================
FILE: docs/learn/jac-cloud/deployment.md
================================================================================


# Cloud Deployment Guide

## Overview

Jac Cloud provides a Kubernetes-based deployment template to easily deploy your service into your cluster. This setup includes:

1. A Docker image with all necessary dependencies
2. Kubernetes configuration for essential resources (namespaces, service accounts, roles, etc.)
3. Dynamic configuration through environment variables and ConfigMaps

This guide will help you deploy your Jac applications to a Kubernetes cluster with minimal effort.

## Prerequisites

Before you begin, ensure you have:

1. **Kubernetes Cluster**: Access to a running Kubernetes cluster
2. **kubectl**: The Kubernetes command-line tool installed and configured
3. **Docker**: Docker installed for building and pushing images
4. **Namespace**: The target namespace should be created before deployment
5. **OpenAI API Key**: (Optional) An OpenAI API key if you're using OpenAI services

## Directory Structure

The deployment files are organized as follows:

```
jac-cloud/
â”œâ”€â”€ scripts/
â”‚   â”œâ”€â”€ Dockerfile
â”‚   â”œâ”€â”€ init_jac_cloud.sh
â”‚   â”œâ”€â”€ jac-cloud.yml
â”‚   â”œâ”€â”€ module-config.yml
```

## Step-by-Step Deployment Guide

Follow these steps to deploy your Jac application to Kubernetes:

### 1. Build and Push the Docker Image

First, build the Jac Cloud Docker image using the provided Dockerfile:

```bash
docker build -t your-dockerhub-username/jac-cloud:latest -f jac-cloud/scripts/Dockerfile .
docker push your-dockerhub-username/jac-cloud:latest
```

After pushing the image, update the `image` field in `jac-cloud.yml` with your Docker image path.

### 2. Apply the ConfigMap

Apply the module configuration to set up module-specific settings:

```bash
kubectl apply -f jac-cloud/scripts/module-config.yml
```

This creates the `littlex` namespace and configures the module settings.

### 3. Apply Kubernetes Resources

Deploy the Jac Cloud application and all required resources:

```bash
kubectl apply -f jac-cloud/scripts/jac-cloud.yml
```

This sets up:

- RBAC roles and bindings
- The Jac Cloud deployment in the `littlex` namespace

### 4. Add OpenAI API Key (Optional)

If your application uses OpenAI services, add your API key as a Kubernetes secret:

```bash
# Encode your API key in base64
echo -n "your-openai-key" | base64
```

Then, update the base64 value in the `data.openai-key` field of the secret definition in `jac-cloud.yml` and apply it:

```bash
kubectl apply -f jac-cloud/scripts/jac-cloud.yml
```

### 5. Verify Your Deployment

Check that all resources are created successfully:

```bash
kubectl get all -n littlex
```

You should see the Jac Cloud pod running along with all associated resources.

## Configuration Details

### Environment Variables

The following environment variables can be configured for your deployment:

| Variable         | Description                         | Default Value   |
| ---------------- | ----------------------------------- | --------------- |
| `NAMESPACE`      | Target namespace for the deployment | `default`       |
| `CONFIGMAP_NAME` | Name of the ConfigMap to mount      | `module-config` |
| `FILE_NAME`      | JAC file to execute in the pod      | `example.jac`   |
| `OPENAI_API_KEY` | OpenAI API key (from secret)        | None            |

## Troubleshooting and Validation

### Verify Namespace

Check if the namespace exists:

```bash
kubectl get namespaces
```

### Verify ConfigMap

Ensure the ConfigMap is properly applied:

```bash
kubectl get configmap -n littlex
```

### Verify Deployment

Check if the Jac Cloud pod is running:

```bash
kubectl get pods -n littlex
```

## Advanced Usage

### Updating Configurations

To update the ConfigMap or deployment:

1. Modify the YAML files as needed
2. Apply the changes:

```bash
kubectl apply -f jac-cloud/scripts/module-config.yml
kubectl apply -f jac-cloud/scripts/jac-cloud.yml
```

### Monitoring Logs

View the logs of your Jac Cloud application:

```bash
kubectl logs -f deployment/jac-cloud -n littlex
```

### Scaling the Deployment

Increase the number of replicas to handle more traffic:

```bash
kubectl scale deployment jac-cloud --replicas=3 -n littlex
```

### Configuring Resource Limits

Adjust CPU and memory limits in the `jac-cloud.yml` file:

```yaml
resources:
  limits:
    cpu: "1"
    memory: "1Gi"
  requests:
    cpu: "500m"
    memory: "512Mi"
```

## Cleanup

To remove all deployed resources:

```bash
kubectl delete namespace littlex
```

This will delete all resources associated with your Jac Cloud deployment.

## Next Steps

- Learn about [Environment Variables](env_vars.md) for configuration options
- Explore [WebSockets](websocket.md) for real-time features
- Set up [Logging](logging.md) to monitor your deployment
- Implement [Task Scheduling](scheduler.md) for background processing




================================================================================
FILE: docs/learn/jac-cloud/env_vars.md
================================================================================


# Environment Variables: Configuration Made Easy

## What Are Environment Variables?

Environment variables are a simple way to configure your Jac Cloud application without changing code. Think of them as settings you can adjust from outside your application. They're perfect for:

- Switching between development and production settings
- Connecting to different databases
- Adjusting security parameters
- Enabling or disabling features
- Storing API keys and secrets

## Quick Start: Setting Your First Variables

### In Development (Command Line)

```bash
# Set variables before running your application
export DATABASE_NAME=my_app_dev
export LOGGER_LEVEL=debug
jac serve main.jac
```

### In Production (Environment File)

```bash
# Create a .env file
echo "DATABASE_NAME=my_app_prod" > .env
echo "LOGGER_LEVEL=info" >> .env

# Load variables and run
source .env
jac serve main.jac
```

## Core Configuration Groups

### Database Connection

Connect to MongoDB or local storage:

```bash
# MongoDB Atlas (cloud database)
export DATABASE_HOST="mongodb+srv://username:password@cluster.mongodb.net"
export DATABASE_NAME="production_db"

# OR Local database
export DATABASE_PATH="local_data"
export DATABASE_NAME="my_app"
```

### Redis Configuration (for WebSockets & Caching)

```bash
# Basic Redis setup
export REDIS_HOST="redis://redis.example.com"
export REDIS_PORT="6379"

# Secured Redis
export REDIS_USER="admin"
export REDIS_PASS="your_secure_password"
```

### API Behavior

```bash
# Show detailed responses including return values
export SHOW_ENDPOINT_RETURNS=true

# Disable automatic API endpoint generation
export DISABLE_AUTO_ENDPOINT=true

# Disable authentication requirement for all walker endpoints
export REQUIRE_AUTH_BY_DEFAULT=false

# Performance optimizations
export DISABLE_AUTO_CLEANUP=true
export SINGLE_QUERY=true
export SESSION_MAX_TRANSACTION_RETRY=3
export SESSION_MAX_COMMIT_RETRY=3
```

## Security Settings

### Token Security

```bash
# Strong security for production
export TOKEN_SECRET="a_long_random_string_that_is_very_hard_to_guess"
export TOKEN_ALGORITHM="HS512"  # More secure algorithm
export TOKEN_TIMEOUT="4"        # 4-hour tokens
```

### User Verification

```bash
# Require email verification before login
export RESTRICT_UNVERIFIED_USER=true
export VERIFICATION_CODE_TIMEOUT=48  # 48 hours to verify
export RESET_CODE_TIMEOUT=1          # 1 hour to reset password
```

### Email Integration (for Verification)

```bash
# SendGrid configuration for email notifications
export SENDGRID_HOST="https://api.example.com"
export SENDGRID_API_KEY="SG.your-sendgrid-api-key"
```

## Logging Configuration

Control what gets logged and where:

```bash
# Production logging setup
export LOGGER_NAME="production"                   # Custom logger name
export LOGGER_LEVEL="info"                        # Less verbose logging
export LOGGER_FILE_PATH="/var/log/jac-cloud.log"  # Standard log location
export LOGGER_ROLLOVER_INTERVAL="D"               # Daily rotation
export LOGGER_MAX_BACKUP="30"                     # Keep 30 days of logs
export LOGGER_ROLLOVER_MAX_FILE_SIZE="10000000"   # 10MB max file size
export LOGGER_USE_UTC="true"                      # Use UTC timestamps
```

## Environment Variable Reference Tables

### Database & Cache Settings

| **Variable** | **Description** | **Default** | **Example** |
|--------------|-----------------|-------------|-------------|
| `DATABASE_HOST` | MongoDB connection string | `mongodb://localhost/?retryWrites=true&w=majority` | `mongodb+srv://user:pass@cluster.mongodb.net` |
| `DATABASE_NAME` | MongoDB database name | `jaseci` | `my_production_db` |
| `DATABASE_PATH` | Local path for DB | `mydatabase` | `path/to/db` |
| `REDIS_HOST` | Redis connection host | `redis://localhost` | `redis://redis.example.com` |
| `REDIS_PORT` | Redis connection port | `6379` | `6380` |
| `REDIS_USER` | Redis username | `null` | `admin` |
| `REDIS_PASS` | Redis password | `null` | `secret123` |

### API & Application Behavior

| **Variable** | **Description** | **Default** | **Example** |
|--------------|-----------------|-------------|-------------|
| `DISABLE_AUTO_ENDPOINT` | Disable automatic API endpoints | `false` | `true` |
| `REQUIRE_AUTH_BY_DEFAULT` | Require authentication for all walker endpoints | `true` | `false` |
<!-- | `SHOW_ENDPOINT_RETURNS` | Include walker return values | `false` | `true` | -->
| `DISABLE_AUTO_CLEANUP` | Disable automatic deletion of disconnected nodes | `false` | `true` |
| `SINGLE_QUERY` | Use individual queries instead of batch | `false` | `true` |
| `SESSION_MAX_TRANSACTION_RETRY` | MongoDB's transactional retry | `1` | `3` |
| `SESSION_MAX_COMMIT_RETRY` | MongoDB's transaction commit retry | `1` | `3` |

### Authentication & Security

| **Variable** | **Description** | **Default** | **Example** |
|--------------|-----------------|-------------|-------------|
| `TOKEN_SECRET` | Secret key for token encryption | 50 random characters | `your-super-secure-secret-key` |
| `TOKEN_ALGORITHM` | Algorithm for token encryption | `HS256` | `HS512` |
| `TOKEN_TIMEOUT` | Token expiration in hours | `12` | `24` |
| `RESTRICT_UNVERIFIED_USER` | Require email verification | `false` | `true` |
| `VERIFICATION_CODE_TIMEOUT` | Verification code expiration (hours) | `24` | `48` |
| `RESET_CODE_TIMEOUT` | Password reset code expiration (hours) | `24` | `1` |
| `SENDGRID_HOST` | Host for verification links | `http://localhost:8000` | `https://api.example.com` |
| `SENDGRID_API_KEY` | SendGrid API key | `null` | `SG.your-api-key` |

### Logging Configuration

| **Variable** | **Description** | **Default** | **Example** |
|--------------|-----------------|-------------|-------------|
| `LOGGER_NAME` | Logger name | `app` | `production` |
| `LOGGER_LEVEL` | Log level | `debug` | `info` |
| `LOGGER_FILE_PATH` | Log file location | `/tmp/jac_cloud_logs/jac-cloud.log` | `/var/log/jac-cloud.log` |
| `LOGGER_ROLLOVER_INTERVAL` | Rotation interval (M=minute, H=hour, D=day, W=week) | `D` | `H` |
| `LOGGER_MAX_BACKUP` | Maximum backup files | `-1` (unlimited) | `30` |
| `LOGGER_ROLLOVER_MAX_FILE_SIZE` | Maximum file size in bytes before rollover | `10000000` | `5000000` |
| `LOGGER_USE_UTC` | Use UTC time | `false` | `true` |

## Social Login Configuration

### Basic Pattern

```bash
# Replace PLATFORM with: GOOGLE, GITHUB, FACEBOOK, etc.
export SSO_{PLATFORM}_CLIENT_ID="your_client_id"
export SSO_{PLATFORM}_CLIENT_SECRET="your_client_secret"
```

### Google Example

```bash
export SSO_GOOGLE_CLIENT_ID="123456789-abcdef.apps.googleusercontent.com"
export SSO_GOOGLE_CLIENT_SECRET="GOCSPX-abcdefghijklmnop"
```

### GitHub Example

```bash
export SSO_GITHUB_CLIENT_ID="abc123def456"
export SSO_GITHUB_CLIENT_SECRET="ghp_abcdefghijklmnopqrstuvwxyz"
```

### Complete SSO Environment Variables

| **Variable Pattern** | **Description** |
|----------------------|-----------------|
| `SSO_{PLATFORM}_CLIENT_ID` | OAuth client ID for the platform |
| `SSO_{PLATFORM}_CLIENT_SECRET` | OAuth client secret for the platform |
| `SSO_{PLATFORM}_ALLOW_INSECURE_HTTP` | Allow non-HTTPS connections (not recommended for production) |
| `SSO_GITLAB_BASE_ENDPOINT_URL` | Base URL for GitLab SSO (for self-hosted GitLab) |
| `SSO_MICROSOFT_TENANT` | Microsoft tenant ID for Azure AD |

### Apple-Specific SSO Configuration

Apple requires a special configuration for client secret generation:

| **Variable** | **Description** |
|--------------|-----------------|
| `SSO_APPLE_CLIENT_ID` | Apple client ID |
| `SSO_APPLE_CLIENT_TEAM_ID` | Apple developer team ID |
| `SSO_APPLE_CLIENT_KEY` | Apple client key |
| `SSO_APPLE_CLIENT_CERTIFICATE_PATH` | Path to Apple client certificate |
| `SSO_APPLE_CLIENT_CERTIFICATE` | Raw Apple client certificate content |

### Supported Platforms

<div class="grid-container" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 10px;">
    <div class="grid-item" style="text-align: center; padding: 15px; border: 1px solid #444; border-radius: 8px; background-color: #333;">
        <div>Google</div>
    </div>
    <div class="grid-item" style="text-align: center; padding: 15px; border: 1px solid #444; border-radius: 8px; background-color: #333;">
        <div>Facebook</div>
    </div>
    <div class="grid-item" style="text-align: center; padding: 15px; border: 1px solid #444; border-radius: 8px; background-color: #333;">
        <div>GitHub</div>
    </div>
    <div class="grid-item" style="text-align: center; padding: 15px; border: 1px solid #444; border-radius: 8px; background-color: #333;">
        <div>Microsoft</div>
    </div>
    <div class="grid-item" style="text-align: center; padding: 15px; border: 1px solid #444; border-radius: 8px; background-color: #333;">
        <div>Apple</div>
    </div>
    <div class="grid-item" style="text-align: center; padding: 15px; border: 1px solid #444; border-radius: 8px; background-color: #333;">
        <div>LinkedIn</div>
    </div>
    <div class="grid-item" style="text-align: center; padding: 15px; border: 1px solid #444; border-radius: 8px; background-color: #333;">
        <div>Twitter</div>
    </div>
    <div class="grid-item" style="text-align: center; padding: 15px; border: 1px solid #444; border-radius: 8px; background-color: #333;">
        <div>GitLab</div>
    </div>
    <div class="grid-item" style="text-align: center; padding: 15px; border: 1px solid #444; border-radius: 8px; background-color: #333;">
        <div>KAKAO</div>
    </div>
    <div class="grid-item" style="text-align: center; padding: 15px; border: 1px solid #444; border-radius: 8px; background-color: #333;">
        <div>Notion</div>
    </div>
    <div class="grid-item" style="text-align: center; padding: 15px; border: 1px solid #444; border-radius: 8px; background-color: #333;">
        <div>YANDEX</div>
    </div>
    <div class="grid-item" style="text-align: center; padding: 15px; border: 1px solid #444; border-radius: 8px; background-color: #333;">
        <div>FITBIT</div>
    </div>
    <div class="grid-item" style="text-align: center; padding: 15px; border: 1px solid #444; border-radius: 8px; background-color: #333;">
        <div>LINE</div>
    </div>
    <div class="grid-item" style="text-align: center; padding: 15px; border: 1px solid #444; border-radius: 8px; background-color: #333;">
        <div>NAVER</div>
    </div>
</div>

## Server Configuration (Uvicorn)

Jac Cloud uses Uvicorn as its server. Configure it with these variables:

### Basic Server Settings

```bash
# Public server configuration
export UV_HOST="0.0.0.0"        # Listen on all interfaces
export UV_PORT="80"              # Standard HTTP port
export UV_TIMEOUT_KEEP_ALIVE="120"  # Keep connections alive longer
```

### HTTPS/SSL Configuration

```bash
# Enable HTTPS
export UV_SSL_KEYFILE="/etc/ssl/private/key.pem"
export UV_SSL_CERTFILE="/etc/ssl/certs/cert.pem"
```

### Complete Uvicorn Configuration Table

| **Variable** | **Uvicorn Equivalent** | **Default** | **Description** |
|--------------|------------------------|-------------|-----------------|
| `UV_HOST` | host | "127.0.0.1" | Interface to bind to |
| `UV_PORT` | port | 8000 | Port to bind to |
| `UV_UDS` | uds | None | Unix domain socket path |
| `UV_FD` | fd | None | File descriptor to use |
| `UV_LOOP` | loop | "auto" | Event loop implementation |
| `UV_HTTP` | http | "auto" | HTTP protocol implementation |
| `UV_WS` | ws | "auto" | WebSocket protocol implementation |
| `UV_WS_MAX_SIZE` | ws_max_size | 16777216 | WebSocket max message size |
| `UV_WS_MAX_QUEUE` | ws_max_queue | 32 | WebSocket max queue size |
| `UV_WS_PING_INTERVAL` | ws_ping_interval | 20.0 | WebSocket ping interval |
| `UV_WS_PING_TIMEOUT` | ws_ping_timeout | 20.0 | WebSocket ping timeout |
| `UV_WS_PER_MESSAGE_DEFLATE` | ws_per_message_deflate | True | WebSocket message compression |
| `UV_LIFESPAN` | lifespan | "auto" | Lifespan implementation |
| `UV_INTERFACE` | interface | "auto" | ASGI interface type |
| `UV_RELOAD_DIRS` | reload_dirs | None | Directories to monitor for reload |
| `UV_RELOAD_INCLUDES` | reload_includes | None | File patterns to include for reload |
| `UV_RELOAD_EXCLUDES` | reload_excludes | None | File patterns to exclude from reload |
| `UV_RELOAD_DELAY` | reload_delay | 0.25 | Reload delay in seconds |
| `UV_ENV_FILE` | env_file | None | Environment file path |
| `UV_LOG_CONFIG` | log_config | LOGGING_CONFIG | Logging configuration |
| `UV_LOG_LEVEL` | log_level | None | Log level |
| `UV_ACCESS_LOG` | access_log | True | Enable access log |
| `UV_PROXY_HEADERS` | proxy_headers | True | Trust proxy headers |
| `UV_SERVER_HEADER` | server_header | True | Include server header |
| `UV_DATE_HEADER` | date_header | True | Include date header |
| `UV_FORWARDED_ALLOW_IPS` | forwarded_allow_ips | None | IPs allowed for X-Forwarded-For |
| `UV_ROOT_PATH` | root_path | "" | ASGI root path |
| `UV_LIMIT_CONCURRENCY` | limit_concurrency | None | Maximum concurrent connections |
| `UV_BACKLOG` | backlog | 2048 | Maximum number of pending connections |
| `UV_LIMIT_MAX_REQUESTS` | limit_max_requests | None | Maximum requests per worker |
| `UV_TIMEOUT_KEEP_ALIVE` | timeout_keep_alive | 5 | Keep-alive connection timeout |
| `UV_TIMEOUT_GRACEFUL_SHUTDOWN` | timeout_graceful_shutdown | None | Graceful shutdown timeout |
| `UV_SSL_KEYFILE` | ssl_keyfile | None | SSL key file path |
| `UV_SSL_CERTFILE` | ssl_certfile | None | SSL certificate file path |
| `UV_SSL_KEYFILE_PASSWORD` | ssl_keyfile_password | None | SSL key file password |
| `UV_SSL_VERSION` | ssl_version | SSL_PROTOCOL_VERSION | SSL version |
| `UV_SSL_CERT_REQS` | ssl_cert_reqs | ssl.CERT_NONE | SSL certificate requirements |
| `UV_SSL_CA_CERTS` | ssl_ca_certs | None | SSL CA certificate file |
| `UV_SSL_CIPHERS` | ssl_ciphers | "TLSv1" | SSL cipher suite |
| `UV_HEADERS` | headers | None | HTTP headers to include |
| `UV_USE_COLORS` | use_colors | None | Use colors in logs |
| `UV_APP_DIR` | app_dir | None | Application directory |
| `UV_FACTORY` | factory | False | Use application factory pattern |
| `UV_H11_MAX_INCOMPLETE_EVENT_SIZE` | h11_max_incomplete_event_size | None | Maximum h11 incomplete event size |

!!! note "Running with Workers"
    `UV_RELOAD` and `UV_WORKERS` are not supported with `jac serve`. If you need multiple workers, use `poetry run standalone` and set the `APP_PATH` environment variable to your Jac file.

## Environment Presets for Different Scenarios

### Local Development

```bash
# Quick setup for local development
export DATABASE_NAME="dev_db"
export LOGGER_LEVEL="debug"
export SHOW_ENDPOINT_RETURNS="true"
```

### Testing

```bash
# Configuration for testing
export DATABASE_NAME="test_db"
export LOGGER_LEVEL="debug"
export TOKEN_TIMEOUT="1"  # Short-lived tokens for testing
export REQUIRE_AUTH_BY_DEFAULT="false"  # Disable auth for easier testing
```

### Production

```bash
# Secure production configuration
export DATABASE_HOST="mongodb+srv://user:pass@cluster.mongodb.net"
export DATABASE_NAME="prod_db"
export LOGGER_LEVEL="info"
export LOGGER_MAX_BACKUP="30"
export TOKEN_ALGORITHM="HS512"
export TOKEN_TIMEOUT="4"
export RESTRICT_UNVERIFIED_USER="true"
export UV_HOST="0.0.0.0"
export UV_PORT="443"
export UV_SSL_KEYFILE="/etc/ssl/private/key.pem"
export UV_SSL_CERTFILE="/etc/ssl/certs/cert.pem"
```

## Best Practices for Beginners

1. **Use environment files**: Create `.env` files for different environments
   ```bash
   # Create different environment files
   touch .env.development .env.testing .env.production
   ```

2. **Never commit secrets**: Add `.env` files to your `.gitignore`
   ```bash
   # Add to .gitignore
   echo ".env*" >> .gitignore
   ```

3. **Use different values per environment**:
   ```bash
   # Development
   DATABASE_NAME=my_app_dev

   # Production
   DATABASE_NAME=my_app_prod
   ```

4. **Document your variables**: Create a template file showing all options
   ```bash
   # Create a template with comments
   touch .env.template
   ```

5. **Validate critical variables**: Check for required variables in your code
   ```jac
   walker check_config {
       can enter with `root entry {
           if not env("DATABASE_HOST") {
               print("Warning: DATABASE_HOST not set, using default");
           }
       }
   }
   ```

## Next Steps

- Learn about [WebSocket Communication](websocket.md) for real-time features
- Explore [Task Scheduling](scheduler.md) for automated background tasks
- Set up [Logging & Monitoring](logging.md) to track application performance
- Deploy your app using the [Kubernetes Deployment Guide](deployment.md)



================================================================================
FILE: docs/learn/jac-cloud/introduction.md
================================================================================


# Introduction to Jac Cloud

## What is Jac Cloud?

Jac Cloud is a powerful cloud-native framework that transforms your Jac applications into production-ready API servers with minimal configuration. It bridges the gap between local Jac development and scalable cloud deployment, providing enterprise-grade features out of the box.

With Jac Cloud, you can:

- Deploy your Jac applications as RESTful APIs, WebSocket services, and scheduled tasks
- Simply replace `jac run` with `jac serve` to transform your application into a fully-featured web service
- Access a rich set of cloud-native features without writing additional code

## Key Features at a Glance

### Instant API Generation
- Automatically converts Jac walkers into REST endpoints
- Supports all HTTP methods (GET, POST, PUT, DELETE, etc.)
- Built-in OpenAPI/Swagger documentation at `/docs`

### Authentication & Authorization
- Token-based authentication system
- Role-based access control
- Configurable endpoint security

### Real-time Communication
- WebSocket support for real-time applications
- Channel-based messaging
- Client and user notification systems

### Task Scheduling
- Cron-based scheduling
- Interval-based tasks
- One-time date triggers

### Production-Ready Features
- Comprehensive logging with Elastic integration
- Environment variable configuration
- Health monitoring and metrics
- File upload support

### Cloud Integration
- Kubernetes deployment support
- Docker containerization
- ConfigMap-based configuration
- Horizontal scaling capabilities

## Quick Start (5-Minute Setup)

The simplest way to start with Jac Cloud is to take an existing Jac application and serve it:

```bash
# Install Jac Cloud
pip install jac-cloud

# Instead of running locally
jac run main.jac

# Serve as an API
jac serve main.jac
```

Your application will be available at `http://localhost:8000` with automatic API documentation at `http://localhost:8000/docs`.

## How Jac Cloud Works

Jac Cloud follows a modular architecture that includes:

- **Walker Endpoints**: Automatic REST API generation from walker declarations
- **WebSocket Manager**: Real-time bidirectional communication
- **Scheduler**: Background task execution
- **Authentication System**: Secure access control
- **Logging Framework**: Comprehensive request/response logging

## Perfect Use Cases for Beginners

Jac Cloud is ideal for:

- **Microservices**: Build scalable, independent services
- **Real-time Applications**: Chat systems, live updates, notifications
- **Data Processing APIs**: Transform and analyze data at scale
- **AI/ML Services**: Deploy machine learning models as APIs
- **IoT Backends**: Handle device communication and data ingestion
- **Task Automation**: Scheduled data processing and workflows

## Next Steps

Ready to get started? Check out these guides:

- [Quick Start Guide](quickstart.md) - Build your first Jac Cloud application
- [Walker Endpoints](quickstart.md#walker-endpoints) - Learn how to configure API endpoints
- [WebSocket Communication](websocket.md) - Add real-time features
- [Task Scheduling](scheduler.md) - Automate recurring tasks
- [Kubernetes Deployment](deployment.md) - Deploy to the cloud

<!-- ## Community and Support

Jac Cloud is part of the larger Jaseci ecosystem. Join our community to get help, share your projects, and contribute to the platform's growth.

---

*Transform your Jac applications into production-ready cloud services with Jac Cloud's powerful, yet simple framework.* -->



================================================================================
FILE: docs/learn/jac-cloud/logging.md
================================================================================


# Logging and Monitoring Your Application

## Why Logging Matters

Effective logging is crucial for:

- Troubleshooting problems
- Understanding user behavior
- Monitoring application performance
- Detecting security issues
- Analyzing usage patterns

Jac Cloud includes a comprehensive logging system that automatically tracks requests and responses, making your development experience smoother.

## Quick Start: Check Your Logs

By default, Jac Cloud logs everything to the `/tmp/jac_cloud_logs/` directory. To check your logs:

```bash
# View the latest log entries
tail -f /tmp/jac_cloud_logs/jac-cloud.log

# Search for errors
grep "ERROR" /tmp/jac_cloud_logs/jac-cloud.log
```

All logs are in JSON format, making them easy to parse and analyze.

## Setting Up Visualization with Elastic Stack

For a better logging experience, connect Jac Cloud to Elastic Stack (Elasticsearch + Kibana) in three easy steps:

### Step 1: Install Filebeat

[Download and install Filebeat](https://www.elastic.co/downloads/beats/filebeat) on your server.

### Step 2: Create Configuration File

Create a file named `filebeat.yml` with this content:

```yml
filebeat.inputs:
- type: log
  enabled: true
  paths:
    - /tmp/jac_cloud_logs/*-jac-cloud-*.log
    - /tmp/jac_cloud_logs/jac-cloud.log
  json:
    keys_under_root: true
    overwrite_keys: true
    add_error_key: true
    expand_keys: true

output.elasticsearch:
  hosts: ["localhost:9200"]  # Replace with your Elastic URL
  protocol: https
  api_key: "id:api_key"      # Replace with your API key
  index: "jac-cloud-logs"

setup.template.name: "filebeat"
setup.template.pattern: "filebeat-*"
```

### Step 3: Run Filebeat

```bash
filebeat -e -c filebeat.yml
```

For more detailed documentation:

- [Getting Started](https://www.elastic.co/guide/en/cloud/current/ec-getting-started-search-use-cases-python-logs.html)
- [Configure filebeat](https://www.elastic.co/guide/en/beats/filebeat/current/configuring-howto-filebeat.html)

Now you can view your logs in Kibana with powerful filtering, visualization, and alerting capabilities!

!!! warning "Port Configuration"
    If your Elastic instance is behind a load balancer with a URL that doesn't include a port, add either `:80` or `:443` to the hosts config:
    ```
    hosts: ["https://my_elastic_instance.me.com:443"]
    ```

## Customizing Your Logging

Adjust logging behavior by setting these environment variables:

| **Setting** | **Environment Variable** | **Description** | **Default** |
|-------------|--------------------------|-----------------|-------------|
| Logger Name | `LOGGER_NAME` | Name for your logger | `app` |
| Log Level | `LOGGER_LEVEL` | Level of detail (debug, info, warning, error) | `debug` |
| File Path | `LOGGER_FILE_PATH` | Where logs are stored | `/tmp/jac_cloud_logs/jac-cloud.log` |
| Rotation | `LOGGER_ROLLOVER_INTERVAL` | How often to create new log files (M=minute, H=hour, D=day, W=week) | `D` (daily) |
| Backup Count | `LOGGER_MAX_BACKUP` | Number of old logs to keep (-1 = unlimited) | `-1` |
| File Size | `LOGGER_ROLLOVER_MAX_FILE_SIZE` | Maximum log file size in bytes | `10000000` (10MB) |
| UTC Time | `LOGGER_USE_UTC` | Whether to use UTC time | `false` |

### Example: Production Settings

For a production environment, you might want to:

1. Use `info` level to reduce log size
2. Keep logs for 30 days
3. Use UTC time for consistency

```bash
export LOGGER_LEVEL=info
export LOGGER_MAX_BACKUP=30
export LOGGER_USE_UTC=true
```

## Understanding Log Structure

Jac Cloud logs contain these key components:

```json
{
  "timestamp": "2024-04-10T14:25:36.789Z",
  "level": "INFO",
  "message": "Request processed successfully",
  "request": {
    "method": "POST",
    "path": "/walker/create_user",
    "headers": {"authorization": "Bearer ***", "content-type": "application/json"},
    "body": {"username": "example_user", "email": "user@example.com"}
  },
  "response": {
    "status_code": 200,
    "body": {"status": 200, "reports": ["User created successfully"]}
  },
  "duration": 125,
  "client_ip": "192.168.1.1"
}
```

This format makes it easy to filter and search for specific information.

## Common Log Analysis Tasks

### Finding Errors

```bash
grep '"level":"ERROR"' /tmp/jac_cloud_logs/jac-cloud.log
```

### Tracking Slow Requests

```bash
grep -v '"level":"DEBUG"' /tmp/jac_cloud_logs/jac-cloud.log |
  jq 'select(.duration > 1000) | {path: .request.path, duration: .duration, time: .timestamp}'
```

### Monitoring User Activity

```bash
grep '/walker/login' /tmp/jac_cloud_logs/jac-cloud.log |
  jq '.request.body.username'
```

## Logging Best Practices

### 1. **Use appropriate log levels**:

   - `debug`: Detailed information for debugging
   - `info`: Confirmation that things are working
   - `warning`: Something unexpected but not critical
   - `error`: Something failed but the application continues
   - `critical`: Application cannot continue

### 2. **Be careful with sensitive data**:

   - Passwords, tokens, and personal information should never be logged
   - Jac Cloud automatically masks Authorization headers

### 3. **Establish log retention policies**:

   - Configure `LOGGER_MAX_BACKUP` based on your needs
   - Consider compliance requirements (GDPR, HIPAA, etc.)

### 4. **Set up alerts**:

   - Configure alerts in Kibana for error spikes
   - Monitor for unusual patterns or security issues

## Troubleshooting Common Issues

### Missing Logs

If logs aren't appearing:

1. Check directory permissions:
   ```bash
   sudo mkdir -p /tmp/jac_cloud_logs
   sudo chmod 777 /tmp/jac_cloud_logs
   ```

2. Verify the logger configuration:
   ```bash
   echo $LOGGER_FILE_PATH
   ```

### Filebeat Connection Issues

If Filebeat isn't sending logs to Elasticsearch:

1. Check connection:
   ```bash
   curl -k https://your-elastic-instance:9200
   ```

2. Verify API key:
   ```bash
   filebeat test output
   ```

### High Disk Usage

If logs are consuming too much space:

1. Adjust rotation settings:
   ```bash
   export LOGGER_ROLLOVER_INTERVAL=D
   export LOGGER_MAX_BACKUP=7
   ```

2. Manually clean old logs:
   ```bash
   find /tmp/jac_cloud_logs -name "*.log.*" -type f -mtime +7 -delete
   ```

## Next Steps

- Learn about [WebSocket Communication](websocket.md) for real-time features
- Explore [Webhook Integration](webhook.md) for third-party service integration
- Set up [Environment Variables](env_vars.md) for application configuration



================================================================================
FILE: docs/learn/jac-cloud/permission.md
================================================================================


# Permission Management: Secure Multi-User Access

## Why Permissions Matter

Jac Cloud's permission system lets you control who can access different parts of your application. This is crucial for:

- Building multi-user applications
- Protecting sensitive data
- Enabling collaboration features
- Creating public/private content
- Implementing access control

## Key Concepts for Beginners

### Understanding Data Representations

In Jac Cloud, your data exists in two forms:

- Anchor
  - EdgeAnchor
  - NodeAnchor
  - ObjectAnchor
  - WalkerAnchor
- Archetype
  - EdgeArchetype
  - NodeArchetype
  - ObjectArchetype
  - WalkerArchetype

#### **Anchors** are database-side class representations that contain:

| Name      | Description                                                       |
| --------- | ----------------------------------------------------------------- |
| id        | The database identifier.                                          |
| name      | The name of the associated archetype.                             |
| root      | The owning root anchor.                                           |
| access    | Permissions defining which nodes or roots can access this anchor. |
| archetype | The JSON representation of the actual archetype.                  |

#### **Archetypes** are the runtime class representations, directly reflecting fields declared in Jac source code. Dev can access their respective anchors via the `__jac__` attribute

### Permission Levels Explained

Jac Cloud has four permission levels that control what users can do:

| Level       | Description                          | Example Use Case           |
| ----------- | ------------------------------------ | -------------------------- |
| `NoPerm` | Cannot see or interact with the item | Private user data          |
| `ReadPerm`      | Can view but not modify the item     | Public profile information |
| `ConnectPerm`   | Can link nodes to this node          | Friend requests, comments  |
| `WritePerm`     | Full access to modify the item       | User's own content         |

## How Permissions Work (Simple Example)

Imagine a social media app with three users:

```
Root1 â†’ User1 â†’ Post1
Root2 â†’ User2 â†’ Post2
Root3 â†’ User3 â†’ Post3
```

By default, User2 cannot see Post1 (created by User1). To allow this:

1. User1 must explicitly grant permission to User2
2. This creates a connection in the permissions system
3. Now User2 can access Post1 according to the permission level granted

## Managing Permissions in Code

### Grant Access Using Helper Functions

```jac
# Allow User2 to read a post
walker grant_access {
    has target_root_id: str;  # ID of User2's root
    has access_level: str;    # ReadPerm, ConnectPerm, or WritePerm

    can grant_access with post entry {
        # Grant access to the current post
        _.allow_root(here, NodeAnchor.ref(self.target_root_id), self.access_level);
        report "Access granted!";
    }
}
```

The code snippet `_.allow_root(here, NodeAnchor.ref(self.target_root_id), self.access_level)` facilitates granting a specified level of access to a target root node from the current node.

Here's a breakdown of the components:

- `here`

  - Represents the current node, which in this context is the post node.

- `NodeAnchor.ref(self.target_root_id)`

  - This converts the target_root_id (a string identifier) into a NodeAnchor representation. This NodeAnchor then points to the specific target root node that will be granted access.

- `self.access_level`
  - This parameter specifies the level of access that the target root node will have to the current node's data (i.e., the post node's data).

In essence, this line of code enables the post node to grant the designated target root node permission to access its data, with the access permissions defined by self.access_level.

### Revoke Access Using Helper Functions

```jac
# Remove User2's access to a post
walker revoke_access {
    has target_root_id: str;  # ID of User2's root

    can revoke_access with post entry {
        # Revoke access to the current post
        _.disallow_root(here, NodeAnchor.ref(self.target_root_id));
        report "Access revoked!";
    }
}
```

The code snippet `_.disallow_root(here, NodeAnchor.ref(self.target_root_id))` performs the inverse operation of `_.allow_root`; it removes existing access permissions that a target root node had to the current node's data.

Here's how it works:

- `here`
  - This refers to the current node, which, as before, is the post node. This is the node from which the permission is being revoked.
- `NodeAnchor.ref(self.target_root_id)`
  - This converts the target_root_id (a string identifier) into a NodeAnchor representation. This NodeAnchor pinpoints the specific target root node whose access privileges are being revoked.

In essence, this line of code instructs the post node to remove the previously granted access for the designated target root node to its data.

### Make Content Public

```jac
# Make a post readable by everyone
walker make_public {
    can make_public with post entry {
        # Grant READ access to all users
        grant(here, ReadPerm);
        report "Post is now public!";
    }
}
```

The code snippet `grant(here, ReadPerm)` provides a mechanism to grant read access to all other root nodes concerning the data within the current node.

Here's a breakdown of the elements:

- `here`
  - This represents the current node, which in this case is the post node. This is the node whose data will be accessible.
- `ReadPerm`
  - This literal string specifies the type of permission being granted. In this instance, it grants read access, allowing other root nodes to view the data on the post node. They can choose one from permission levels.

### Make Content Private

```jac
# Make a post private (owner-only)
walker make_private {
    can make_private with post entry {
        # Remove all access
        revoke(here);
        report "Post is now private!";
    }
}
```

The code snippet `revoke(here)` is used to remove all previously granted access permissions from all other root nodes to the current node's data. It's the inverse operation of `grant`.

Here's a breakdown:

- `here`
  - This represents the current node (in this context, the post node) from which all access will be revoked.

Essentially, this line of code completely withdraws any permissions that were previously granted to other root nodes, making the post node's data inaccessible to them.

## Common Permission Patterns

### Public Read, Private Write

Perfect for social media posts or articles:

```jac
# Create a public post
walker create_public_post {
    has content: str;

    can enter with `root entry {
        # Create the post
        post = Post({content: self.content});
        here ++> post;

        # Make it readable by everyone, but only writable by owner
        grant(post, ReadPerm);

        report "Public post created!";
    }
}
```

### Group Access

Ideal for team collaboration:

```jac
# Grant access to a team
walker grant_team_access {
    has team_members: list[str];  # List of root IDs
    has access_level: str;        # ReadPerm, ConnectPerm, or WritePerm

    can grant_access with document entry {
        # Grant access to each team member
        for member_id in self.team_members {
            _.allow_root(here, NodeAnchor.ref(member_id), self.access_level);
        }

        report "Team access granted!";
    }
}
```

### Connection-based Permissions

For friend systems or social networks:

```jac
# Only friends can see posts
walker check_access {
    has viewer_id: str;

    can check with post entry {
        owner = [post<--][0];

        # Check if viewer is friends with owner
        is_friend = False;
        for friend in [owner -->] {
            if friend.id == self.viewer_id {
                is_friend = True;
                break;
            }
        }

        if is_friend {
            # Grant access if they're friends
            _.allow_root(here, NodeAnchor.ref(self.viewer_id), "READ");
            report "Access granted to friend!";
        } else {
            report "Access denied - not a friend!";
        }
    }
}
```

## Best Practices for Beginners

1. **Start restrictive**: Begin with tight permissions and open up as needed
2. **Use helper functions**: Prefer `_.allow_root()` over direct manipulation
3. **Check permissions**: Use `_.check_read_access()` to verify permissions
4. **Document your scheme**: Keep track of which nodes have which permissions
5. **Batch similar permissions**: Update permissions for multiple nodes at once

## Next Steps

- Learn about [WebSocket Communication](websocket.md) for real-time features
- Explore [Webhook Integration](webhook.md) for third-party service integration
- Set up [Logging & Monitoring](logging.md) to track access patterns

# Custom Access Validation

> This will only get triggered if the target node is not owned by current root

```jac
node A {
    # suggested to be `with access {}`
    def __jac_access__ {

        ###############################################
        #              YOUR PROCESS HERE              #
        ###############################################

        # Allowed string return NoPerm, ReadPerm, ConnectPerm, or WritePerm
        return NoPerm;

        # Allowed enum return AccessLevel.NO_ACCESS, AccessLevel.READ, AccessLevel.ConnectPerm, AccessLevel.WRITE
        # return AccessLevel.NO_ACCESS;

        # Not recommended as it may change in the future
        # Allowed int return -1 (NoPerm), 0 (ReadPerm), 1 (ConnectPerm), 2 (WritePerm)
        # return -1;

    }
}
```

> if you wish to prioritize current access validation and process it afterwards, you may follow this code

```jac
node A {
    # suggested to be `with access {}`
    def __jac_access__ {

        level = _Jac.check_access_level(here, True); # True means skip custom access validation trigger to avoid infinite loop

        ###############################################
        #              YOUR PROCESS HERE              #
        ###############################################

        # Allowed string return NoPerm, ReadPerm, ConnectPerm, or WritePerm
        return "NO_ACCESS";

        # Allowed enum return AccessLevel.NO_ACCESS, AccessLevel.READ, AccessLevel.ConnectPerm, AccessLevel.WRITE
        # return AccessLevel.NO_ACCESS;

        # Not recommended as it may change in the future
        # Allowed int return -1 (NoPerm), 0 (ReadPerm), 1 (ConnectPerm), 2 (WritePerm)
        # return -1;

    }
}
```




================================================================================
FILE: docs/learn/jac-cloud/quickstart.md
================================================================================


# Quick Start Guide

This guide will help you quickly get up and running with Jac Cloud, with step-by-step instructions designed for beginners.

## Your First Jac Cloud Server in 30 Seconds

Transform any Jac application into a cloud API server with a single command:

```bash
# Basic usage - this is all you need to start!
jac serve main.jac

# With custom host and port (optional)
jac serve main.jac --host 0.0.0.0 --port 8080 --reload
```

## Development Mode
- `--reload`
    - Enable auto-reload. Uvicorn supports two versions of auto-reloading behavior enabled by this option. Default: `False`.
- `--watch path/to/dir1,path/to/dir2`
    - Select which path/s (comma separated) to watch for changes for auto-reload. Requires `--reload` to work. Defaults to main jac directory

---

Once started, your API will be available at:

- **API Endpoint**: `http://localhost:8000`
- **Interactive Documentation**: `http://localhost:8000/docs`

## Understanding Walker Endpoints

### What Happens Automatically

Jac Cloud automatically converts your walker declarations into REST API endpoints. By default, each walker creates two endpoint groups:

| Endpoint Type | URL Pattern | Description |
|--------------|-------------|-------------|
| **Root Entry** | `/walker/{walker_name}` | Executes on the root |
| **Node Entry** | `/walker/{walker_name}/{node_id}` | Executes on a specific node |

### Want to Disable Auto-Generation?

To disable automatic endpoint generation, set the environment variable:
```bash
export DISABLE_AUTO_ENDPOINT=True
```

## Configuring Your Walkers

### Basic Configuration

Control endpoint behavior using the `__specs__` object within your walker:

```jac
walker my_walker {
    has data: str;

    # This is where you configure your endpoint behavior
    obj __specs__ {
        static has methods: list = ["get", "post"];   # Supports both GET and POST
        static has auth: bool = False;                # No authentication required
        static has as_query: list = ["data"];         # "data" will be a query parameter
        static has private: bool = True;              # Skip auto endpoint generation from walker
    }
}
```

## Configuration Reference

### Core Settings (Most Common)

| **Setting** | **Type** | **Description** | **Default** |
|-------------|----------|-----------------|-------------|
| `methods` | `list[str]` | Allowed HTTP methods: `"get"`, `"post"`, `"put"`, `"delete"`, etc. | `["post"]` |
| `as_query` | `str \| list[str]` | Fields to treat as query parameters. Use `"*"` for all fields | `[]` |
| `auth` | `bool` | Whether endpoint requires authentication | `true` |
| `path` | `str` | If it starts with `/`, it will be the complete path. Otherwise, it will be prefixed with `/walker` (for walkers) or /`webhook/walker` (for webhooks). If not specified, it defaults to the walker's name with its respective prefix. | N/A |
| `private` | `bool` | Skip walker in auto-generation | `false` |

### Advanced Settings

| **Setting** | **Type** | **Description** | **Default** |
|-------------|----------|-----------------|-------------|
| `entry_type` | `str` | `"NODE"`, `"ROOT"`, or `"BOTH"` | `"BOTH"` |
| `webhook` | `dict` | [Webhook configuration](webhook.md) | `None` |
| `schedule` | `dict` | [Scheduler configuration](scheduler.md) | `None` |

### Documentation Settings

| **Setting** | **Type** | **Description** | **Default** |
|-------------|----------|-----------------|-------------|
| `response_model` | `Any` | Type for response serialization and validation | `None` |
| `tags` | `list[str \| Enum]` | API tags for grouping in Swagger UI | `None` |
| `status_code` | `int` | Default response status code | `None` |
| `summary` | `str` | Brief endpoint description | `None` |
| `description` | `str` | Detailed endpoint description (supports Markdown) | `None` |
| `response_description` | `str` | Description for the default response | `"Successful Response"` |
| `responses` | `dict[int \| str, dict]` | Additional responses that could be returned | `None` |
| `deprecated` | `bool` | Mark endpoint as deprecated | `None` |
| `include_in_schema` | `bool` | Include endpoint in generated OpenAPI schema | `True` |
| `response_class` | `Type[Response]` | Response class to use for this endpoint | `JSONResponse` |
| `name` | `str` | Internal name for the path operation | `None` |
| `openapi_extra` | `dict[str, Any]` | Extra metadata for OpenAPI schema | `None` |

## Examples for Beginners

### Basic Endpoint Example - Time Service
Let's create a simple endpoint that returns the current time. For this example, we create a walker named `public_info` which provides one rest method `get` at the url `http://localhost:8000/walker/public_info`. The ability `get_current_time` will return the current timestamp in ISO format via the use of the `report` statement.

```jac
import from datetime {datetime}

# Public endpoint (no authentication)
walker public_info {
    obj __specs__ {
        static has methods: list = ["get"];
        static has auth: bool = False;
    }

    can get_current_time with `root entry{
        report {
            "timestamp": datetime.now().isoformat()
        };
    }
}
```


### Parameterized Endpoint Example - User Search
This example demonstrates how to create an endpoint from a walker that accepts query parameters for searching users. The walker `search_users` will allow users to search for a user by their username.

```jac
# GET endpoint with query parameters
walker search_users {
    has query: str;
    static has users: list = [
        {"username": "alice", "email": "alice@example.com"},
        {"username": "bob", "email": "bob@example.com"}
    ];

    obj __specs__ {
        static has methods: list = ["get"];
        static has as_query: list = ["query"];
        static has auth: bool = False;
    }

    can search_by_name with `root entry{
        for user in self.users {
            if user['username'] == self.query {
                report user;
                return;
            }
        }

        report {
            "error": f"User with username {self.query} not found"
        };
    }
}
```

To test this endpoint, you can use a web browser or a tool like `curl`:

```bash
curl -X 'GET' \
  'http://0.0.0.0:8000/walker/search_users?query=alice' \
  -H 'accept: application/json' \
  -H 'Content-Type: application/json'
```

If the user is found, the response will look like this:

```json
{
    "status": 200,
    "reports": [
        {
            "username": "alice",
            "email": "alice@example.com"
        }
    ]
}
```

### File Upload Example
In this example, we will create a walker that allows users to upload a file. The walker `single_file_upload` will accept a single file and return the filename in the response. This shows how the walker can handle post requests with file uploads.

Since jac is a superset of Python, we can use the `UploadFile` type from FastAPI to handle file uploads.

First, we create the upload_file.jac file with the following content:
```jac
# upload_file.jac
import from fastapi { UploadFile }

# Single file upload
walker single_file_upload {
    has file: UploadFile;

    obj __specs__ {
        static has methods: list = ["post"];
        static has auth: bool = False;
    }

    can enter with `root entry {
        report {
            "output": f"Received file: {self.file.filename}"
        };
    }
}

```

Next we can create a test text file named `test.txt` with the content "Hello, Jac Cloud!".
```bash
echo "Hello, Jac Cloud!" > test.txt
```

Now we can test the file upload endpoint using `curl`:

```bash
curl -L -F "file=@test.txt" \
"http://0.0.0.0:8080/walker/single_file_upload" \
```

Successful file upload will return a response like this:

```json
{
    "status": 200,
    "reports": [
        {
            "output": "Received file: test.txt"
        }
    ]
}
```

## Response Format

### What to Expect

All walker endpoints return a standardized JSON response:

```json
{
    "status": 200,
    "reports": [
        "Any reports generated during walker execution"
    ],
    "returns": [
        "Walker return values (optional - requires SHOW_ENDPOINT_RETURNS=true)"
    ]
}
```

### Working with Node and Edge Data

Jac Cloud automatically serializes walker, edge, and node archetypes:

```json
{
    "id": "unique_anchor_reference_id",
    "context": {
        "attribute1": "value1",
        "attribute2": "value2"
    }
}
```

## Data Persistence: Manual Saving and Commits

### **Save**

To save a walker or object to memory (queued for later database commit):

```jac
# Save a walker instance
save(my_walker_instance)

# Save an object instance
save(my_object_instance)
```

### **Commit**

**Commit all in-memory data:**
```jac
commit()  # Saves everything currently in memory to database
```

**Commit specific archetype:**
```jac
commit(archetype)  # Only commits this specific archetype
```

## Helpful Environment Variables

Control Jac Cloud behavior with these environment variables:

- `DISABLE_AUTO_ENDPOINT=True` - Disable automatic endpoint generation
- `SHOW_ENDPOINT_RETURNS=True` - Include walker return values in responses

## Next Steps

Now that you understand the basics, explore these features:

- [Authentication & Permissions](permission.md) - Secure your API
- [Real-time WebSocket Communication](websocket.md) - Add real-time features
- [Task Scheduling](scheduler.md) - Automate recurring tasks
- [Webhook Integration](webhook.md) - Create API integrations
- [Environment Variables](env_vars.md) - Configure your application
- [Logging & Monitoring](logging.md) - Track application performance

## Edge Case: Manually Creating Walker Endpoints

While not recommended, as you typically shouldn't change your API specifications in this manner, Jac Cloud does support manually creating walker endpoints.
This allows for advanced customization if absolutely necessary, but generally, you should rely on the automatic generation and configuration via **specs**.

Example Code snippet:

```
type("NameOfYourWalker", (_.Walker,), {
    "__specs__": your_specs_class,
    ... annotations / additional fields ...
})
```




================================================================================
FILE: docs/learn/jac-cloud/scheduler.md
================================================================================


# Task Scheduling: Automate Your Jac Applications

## Overview

Jac Cloud's scheduler allows you to run walkers automatically at specific times or intervals. This is useful for:

- Running periodic background tasks
- Processing data at scheduled intervals
- Sending scheduled notifications
- Executing maintenance operations
- Any task that needs to happen on a recurring basis

## Scheduler Configuration

To configure a scheduled walker, add a `schedule` dictionary to the walker's `__specs__` configuration. The schedule supports three trigger types:

1. **Cron** - Schedule using cron expressions
2. **Interval** - Schedule at regular time intervals
3. **Date** - Schedule at a specific date and time

### Common Configuration Options

| **NAME**      | **TYPE**               | **DESCRIPTION**                                                                                   | **DEFAULT** |
| ------------- | ---------------------- | ------------------------------------------------------------------------------------------------- | ----------- |
| trigger       | str                    | trigger type (`cron`, `interval`, `date`)                                                         | N/A         |
| node          | str or None            | entry node if necessary, defaults to root                                                         | None        |
| args          | list[Any] or None      | list of arguments to initialize the walker                                                        | None        |
| kwargs        | dict[str, Any] or None | dict of keyword arguments to initialize the walker                                                | None        |
| max_instances | int                    | max simultaneous running job per walker type                                                      | 1           |
| next_run_time | datetime or None       | target date before the first trigger will happen                                                  | None        |
| propagate     | bool                   | if multiple jac-cloud service can trigger at the same time or first service only per trigger only | false       |
| save          | bool                   | if walker instance will be save to the db including the results                                   | false       |

## Cron Trigger

The cron trigger uses a cron-like expression to schedule tasks with high precision.

### Additional Cron Configuration Options

| **NAME**    | **TYPES**               | **DESCRIPTION**                                                | **DEFAULT** |
| ----------- | ----------------------- | -------------------------------------------------------------- | ----------- |
| year        | int or str              | 4-digit year                                                   | \*          |
| month       | int or str              | month (1-12)                                                   | \*          |
| day         | int or str              | day of month (1-31)                                            | \*          |
| week        | int or str              | ISO week (1-53)                                                | \*          |
| day_of_week | int or str              | number or name of weekday (0-6 or mon,tue,wed,thu,fri,sat,sun) | \*          |
| hour        | int or str              | hour (0-23)                                                    | \*          |
| minute      | int or str              | minute (0-59)                                                  | \*          |
| second      | int or str              | second (0-59)                                                  | \*          |
| start_date  | datetime or str or None | earliest possible date/time to trigger on (inclusive)          | None        |
| end_date    | datetime or str or None | latest possible date/time to trigger on (inclusive)            | None        |

### Cron Example

```jac
walker walker_cron {
    has arg1: int;
    has arg2: str;
    has kwarg1: int = 3;
    has kwarg2: str = "4";

    can enter with `root entry {
        print("I am a scheduled walker!")
    }

    class __specs__ {
        has private: bool = True;
        has schedule: dict = {
            "trigger": "cron",
            "args": [1, "2"],
            "kwargs": {
                "kwarg1": 30,
                "kwarg2": "40"
            },
            # Run every day at midnight
            "hour": "0",
            "minute": "0",
            "save": True
        };
    }
}
```

## Interval Trigger

The interval trigger runs a task at regular time intervals.

### Additional Interval Configuration Options

| **NAME**   | **TYPES**               | **DESCRIPTION**                             | **DEFAULT** |
| ---------- | ----------------------- | ------------------------------------------- | ----------- |
| weeks      | int                     | number of weeks to wait                     |             |
| days       | int                     | number of days to wait                      |             |
| hours      | int                     | number of hours to wait                     |             |
| minutes    | int                     | number of minutes to wait                   |             |
| seconds    | int                     | number of seconds to wait                   | 1           |
| start_date | datetime or str or None | starting point for the interval calculation |             |
| end_date   | datetime or str or None | latest possible date/time to trigger on     |             |

### Interval Example

```jac
walker walker_interval {
    has arg1: int;
    has arg2: str;
    has kwarg1: int = 3;
    has kwarg2: str = "4";

    can enter with `root entry {
        print("I am a scheduled walker running every 5 seconds!");
    }

    class __specs__ {
        has private: bool = True;
        has schedule: dict = {
            "trigger": "interval",
            "args": [1, "2"],
            "kwargs": {
                "kwarg1": 30,
                "kwarg2": "40"
            },
            "seconds": 5,
            "save": True
        };
    }
}
```

## Date Trigger

The date trigger runs a task once at a specific date and time.

### Additional Date Configuration Options

| **NAME** | **TYPES**       | **DESCRIPTION**                 | **DEFAULT** |
| -------- | --------------- | ------------------------------- | ----------- |
| run_date | datetime or str | the date/time to run the job at |             |

### Date Example

```jac
walker walker_date {
    has arg1: int;
    has arg2: str;
    has kwarg1: int = 3;
    has kwarg2: str = "4";

    can enter with `root entry {
        print("I am a scheduled walker running once at a specific time!");
    }

    class __specs__ {
        has private: bool = True;
        has schedule: dict = {
            "trigger": "date",
            "args": [1, "2"],
            "kwargs": {
                "kwarg1": 30,
                "kwarg2": "40"
            },
            "run_date": "2025-04-30T11:12:00+00:00",
            "save": True
        };
    }
}
```

## Jac Cloud Optional Task Queue

Jac Cloud also supports asynchronous task management that can be enabled by setting the `TASK_CONSUMER_CRON_SECOND` environment variable. This allows you to create tasks that will be processed by a background worker.

### Example Use Case

```jac
import from jac_cloud.plugin.implementation {create_task}

node TaskCounter {
    has val: int = 0;
}

walker get_or_create_counter {
    can enter1 with `root entry {
        tc = TaskCounter();
        here ++> tc;

        report tc;
    }

    can enter2 with TaskCounter entry {
        report here;
    }
}

walker increment_counter {
    has val: int;

    can enter with TaskCounter entry {
        here.val += self.val;
    }

    class __specs__ {
        has private: bool = True;
    }
}

walker trigger_counter_task {
    can enter with `root entry {
        tcs = [-->(`?TaskCounter)];
        if tcs {
            report create_task(increment_counter(val=1), tcs[0]);
        }
    }
}
```

### How Tasks Work

- `trigger_counter_task` creates a walker task that will be consumed by the Task Consumer
- The task is saved to both the database and Redis
- The polling mechanism uses Redis to avoid excessive database traffic
  - The minimum polling interval is 1 second, configurable via `TASK_CONSUMER_CRON_SECOND`
- Task consumption is atomic, ensuring only one Jac Cloud instance processes each task
- If Redis is cleared, pending tasks will be repopulated from the database when Jac Cloud restarts

## Best Practices

1. **Set Appropriate Intervals**: Use intervals that match your application's needs (e.g., don't poll every second if hourly updates are sufficient)
2. **Make Tasks Idempotent**: Design scheduled tasks to be safely run multiple times
3. **Handle Failures Gracefully**: Add error handling in your scheduled walkers
4. **Consider Time Zones**: Be aware of server time zones when scheduling date/time-specific tasks
5. **Monitor Task Performance**: Log execution times and success rates for scheduled tasks

## Debugging Scheduled Tasks

If your scheduled task isn't running:

1. Check that the `schedule` configuration is correctly formatted
2. Ensure the `private` flag is set to `true` (recommended for scheduled tasks)
3. Verify the environment variable `TASK_CONSUMER_CRON_SECOND` is set (for async tasks)
4. Check the logs for any errors during task execution
5. Test the walker manually to ensure it works properly

## Next Steps

- Learn about [WebSocket Communication](websocket.md) for real-time updates
- Explore [Webhook Integration](webhook.md) for external service integration
- Set up [Logging & Monitoring](logging.md) to track task execution
- Deploy your application using [Kubernetes](deployment.md) for scalable task processing



================================================================================
FILE: docs/learn/jac-cloud/sso_implementation.md
================================================================================


# SSO integration made Easy

## What Is SSO?

Single Sign-On (SSO) is an authentication process that allows users to log in once and gain access to multiple applications or services without needing to enter their credentials repeatedly. Think of it as a single key that opens multiple doors securely.

Itâ€™s especially useful for:

- Simplifying user login â†’ Users donâ€™t have to remember multiple usernames and passwords.

- Improving security â†’ Credentials are managed centrally, reducing risks of weak or reused passwords.

- Enhancing user experience â†’ Smooth, one-click login across different apps and platforms.

- Centralized control â†’ Admins can manage authentication policies and permissions from one place.

- Integration with identity providers â†’ Works with providers like Google, Facebook, Microsoft, or enterprise systems (Okta, Azure AD).

## Supported Platforms in Jac Cloud

Currently following SSO platforms are supported in Jac cloud for SSO

| **Platform name** | **Used for** |
|----------------------|-----------------|
| `APPLE` |  Used for apple SSO integration for both websites and mobile apps|
| `GOOGLE` | Used for gmail SSO integration for websites|
| `GOOGLE_ANDROID` | Used for gmail SSO integration for android mobile apps|
| `GOOGLE_IOS` | Used for gmail SSO integration for ios mobile apps|



## Steps to implement SSO in Jac cloud Setting Your Environment variables

### Step 1: Obtain relevant client credentials from supported platforms
First choose the supported platform and register your application with the relevant platform to get credentials needed
to setup SSO in jac cloud.You can read following documentations and tutorials to register your application.

#### Google

##### General Implementation
- [Step by step to integrate Google OAuth2/SSO](https://dev.to/idrisakintobi/a-step-by-step-guide-to-google-oauth2-authentication-with-javascript-and-bun-4he7) - Complete guide with JavaScript and Bun
- [Easy Configure SSO with Google](https://developer.slashid.dev/docs/access/guides/SSO/oauth_creds_google) - Simplified configuration guide

##### Platform-Specific Guides
- **Web**: [Implementation guide for Web](https://developers.google.com/identity/gsi/web/guides/get-google-api-clientid) - Official Google documentation
- **Android**: [Implementation guide for Android](https://developer.android.com/identity/sign-in/credential-manager-siwg) - Using Credential Manager
- **iOS**: [Implementation guide for iOS](https://developers.google.com/identity/sign-in/ios/start-integrating) - Google Sign-In for iOS

#### Apple

- [Easy Configure SSO with Apple](https://developer.slashid.dev/docs/access/guides/SSO/oauth_creds_apple) - Configuration guide for Apple ID authentication

---

### Step 2: Setup relevant env variables
### Basic Pattern

```bash
# Replace PLATFORM with: GOOGLE, GITHUB, FACEBOOK, etc.
export SSO_{PLATFORM}_CLIENT_ID="your_client_id"
export SSO_{PLATFORM}_CLIENT_SECRET="your_client_secret"
```

#### Google Web Example

```bash
export SSO_GOOGLE_CLIENT_ID="123456789-abcdef.apps.googleusercontent.com"
export SSO_GOOGLE_CLIENT_SECRET="GOCSPX-abcdefghijklmnop"
```

#### Google iOS Example

```bash
export SSO_GOOGLE_IOS_CLIENT_ID="123456789-abcdef.apps.googleusercontent.com"
export SSO_GOOGLE_IOS_CLIENT_SECRET="GOCSPX-abcdefghijklmnop"
```

#### Google Android Example

```bash
export SSO_GOOGLE_ANDROID_CLIENT_ID="123456789-abcdef.apps.googleusercontent.com"
export SSO_GOOGLE_ANDROID_CLIENT_SECRET="GOCSPX-abcdefghijklmnop"
```

#### Apple-Specific SSO Configuration

Apple requires a special configuration for client secret generation:

| **Variable** | **Description** |
|--------------|-----------------|
| `SSO_APPLE_CLIENT_ID` | Apple client ID |
| `SSO_APPLE_CLIENT_TEAM_ID` | Apple developer team ID |
| `SSO_APPLE_CLIENT_KEY` | Apple client key |
| `SSO_APPLE_CLIENT_CERTIFICATE_PATH` | Path to Apple client certificate |
| `SSO_APPLE_CLIENT_CERTIFICATE` | Raw Apple client certificate content |


### Step 3: Call Register Callback Endpoint Provided by JAC Cloud

#### 1. Start the Backend Server

Once all the relevant platform specific environment variables are set, run the backend using:

```bash
jac serve main.jac
```

This command will provide the `backendURL` of the FastAPI server.

#### 2. Obtain ID Token from Frontend

In your frontend application (Web App, Android, or iOS), use the relevant libraries provided by each framework to get the `id_token`:

- **Web**: Google Sign-In JavaScript library
- **Android**: Google Sign-In for Android / Apple Sign-In
- **iOS**: Google Sign-In SDK / Apple Sign-In

#### 3. Call the Callback Endpoint

Once the `id_token` is obtained, call the callback endpoint provided by JAC Cloud

##### Endpoint Format
```
$GET {backendURL}/sso/${provider}/register/callback?id_token=${id_token}
```

##### Curl Example for apple with id_token
```bash
curl -X 'GET' \
  'http://localhost:8000/sso/apple/register/callback?id_token=eyJraWQiOiJFNnE4M1JCMTVuIiwiYWxnIjoiUlMyNTYifQ.eyJpc3MiOiJodHRwczovL2FwcGxlaWQuYXBwbGUuY29tIiwiYXVkIjoibGlmZS50b2J1IiwiZXhwIjoxNzU2NTYxOTg0LCJpYXQiOjE3NTY0NzU1ODQsInN1YiI6IjAwMDkwNC5hMTI5MDJmMzA1ZGE0ZWY1ODE5MGVmN2VjMGQ3ODE1OS4xMzU3IiwiY19oYXNoIjoiQksxdTdBYmlua2RsMUlBWUVISWp2dyIsImVtYWlsIjoicWM5N2s3Mm5mN0Bwcml2YXRlcmVsYXkuYXBwbGVpZC5jb20iLCJlbWFpbF92ZXJpZmllZCI6dHJ1ZSwiaXNfcHJpdmF0ZV9lbWFpbCI6dHJ1ZSwiYXV0aF90aW1lIjoxNzU2NDc1NTg0LCJub25jZV9zdXBwb3J0ZWQiOnRydWV9.iC_vnj2Ar268Z2IW0Ums1gr6OT0UFZocUFJaU_X1S9fudnd_pmIvgOgnlYO8Y7_P134xzjyrHV2-sB_APjZluaUNid7dUkLu7FaCEjU4GReuXlav9Ek9pZfV0FY0D2wqEJhMZ2EcQfgBJbthSewlbbwIeEF4OTHOPB3Pfw8jVJxEMseJ6glxOL0UHC7jRAJNsyYePG2ld1o66UMiFpOaIuuoTjJmigaPA4Mwe1Tiu_ZtGPONd9TEZo7xCXP_c2E68Rh9dLZcqULXAot58l71XEJJok63SQfGMfolR-ibCRAbWvqfe-ZFYYuxVIplva1MnLmiwuPCsb76nUxn0nNa5Q' \
  -H 'accept: application/json'
```

#### Supported Providers

The `${provider}` parameter can take the following values based on your frontend platform.

| Platform | Provider Value |
|----------|----------------|
| Apple (any platform) | `apple` |
| Google Web | `google` |
| Google Android | `google_android` |
| Google iOS | `google_ios` |

This will register your user with jac cloud and sso platform and returns you the required user informations like name,email etc
#### Example Calls

```bash
# For Apple Sign-In
curl "${backendURL}/sso/apple/register/callback?id_token=${id_token}"

# For Google Web
curl "${backendURL}/sso/google/register/callback?id_token=${id_token}"

# For Google Android
curl "${backendURL}/sso/google_android/register/callback?id_token=${id_token}"

# For Google iOS
curl "${backendURL}/sso/google_ios/register/callback?id_token=${id_token}"
```




================================================================================
FILE: docs/learn/jac-cloud/utilities.md
================================================================================


# Utility APIs

**Base URL:** `/util`

This section details the Utility APIs, which can be used to facilitate 3rd party Graph Access. Currently, there's two available endpoints, with plans for future expansion to include additional functionalities.

---

## Traverse

This API allows for the traversal of the knowledge graph starting from a specified source.

### Endpoint

`GET /util/traverse`

### Authentication

Bearer Token (Required)

### Query Parameters

| Name         | Type      | Description                                                                                                                                                                              | Default Value       |
| :----------- | :-------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :------------------ |
| `source`     | `string`  | The **JID** of the starting root, node, or edge for the traversal.                                                                                                                       | Current user's root |
| `detailed`   | `boolean` | If `true`, the response will include the archetype's context for each traversed item.                                                                                                    | `false`             |
| `depth`      | `integer` | The maximum number of steps to traverse. Both nodes and edges are considered one step.                                                                                                   | `1`                 |
| `node_types` | `string`  | Can be declared multiple times to filter the traversal results by node type. For example, `node_types=Node1&node_types=Node2` will include only nodes that are `Node1` or `Node2` types. | All node types      |
| `edge_types` | `string`  | Can be declared multiple times to filter the traversal results by edge type. For example, `edge_types=Edge1&edge_types=Edge2` will include only edges that are `Edge1` or `Edge2` types. | All edge types      |

### Sample Request

```bash
curl -X GET "/util/traverse?source=n::68875f383d1e672f517094ff&detailed=true&depth=2&node_types=Node1&node_types=Node2&edge_types=Edge1" \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
```

### Sample Response

```json
{
  "edges": [
    {
      "id": "e::68875f483d1e672f517096a5",
      "source": "n::68875f383d1e672f517094ff",
      "target": "n:A:68875f483d1e672f517096a0"
    },
    {
      "id": "e::68875f483d1e672f517096a2",
      "source": "n:A:68875f483d1e672f517096a0",
      "target": "n:B:68875f483d1e672f517096a1"
    },
    {
      "id": "e::68875f483d1e672f517096a4",
      "source": "n:B:68875f483d1e672f517096a1",
      "target": "n:C:68875f483d1e672f517096a3"
    }
  ],
  "nodes": [
    {
      "id": "n::68875f383d1e672f517094ff",
      "edges": ["e::68875f483d1e672f517096a5"]
    },
    {
      "id": "n:A:68875f483d1e672f517096a0",
      "edges": ["e::68875f483d1e672f517096a2", "e::68875f483d1e672f517096a5"]
    },
    {
      "id": "n:B:68875f483d1e672f517096a1",
      "edges": ["e::68875f483d1e672f517096a2", "e::68875f483d1e672f517096a4"]
    },
    {
      "id": "n:C:68875f483d1e672f517096a3",
      "edges": ["e::68875f483d1e672f517096a4"]
    }
  ]
}
```

---

## Traverse Stream

This API is similar to the `/util/traverse` endpoint but streams the traversal results. It returns data incrementally, pushing results as they are processed for each step of the traversal.

### Endpoint

`GET /util/traverse-stream`

### Authentication

Bearer Token (Required)

### Query Parameters

The query parameters for `/util/traverse-stream` are identical to those for `/util/traverse`:

| Name         | Type      | Description                                                                                                                                                                              | Default Value       |
| :----------- | :-------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :------------------ |
| `source`     | `string`  | The **JID** of the starting root, node, or edge for the traversal.                                                                                                                       | Current user's root |
| `detailed`   | `boolean` | If `true`, the response will include the archetype's context for each traversed item.                                                                                                    | `false`             |
| `depth`      | `integer` | The maximum number of steps to traverse. Both nodes and edges are considered one step.                                                                                                   | `1`                 |
| `node_types` | `string`  | Can be declared multiple times to filter the traversal results by node type. For example, `node_types=Node1&node_types=Node2` will include only nodes that are `Node1` or `Node2` types. | All node types      |
| `edge_types` | `string`  | Can be declared multiple times to filter the traversal results by edge type. For example, `edge_types=Edge1&edge_types=Edge2` will include only edges that are `Edge1` or `Edge2` types. | All edge types      |

### Sample Request

```bash
curl -X GET "/util/traverse-stream?source=n::68875f383d1e672f517094ff&detailed=true&depth=2&node_types=Node1&node_types=Node2&edge_types=Edge1" \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
```

### Sample Streamed Response

The response will be a continuous stream of JSON objects, each representing a "step" in the traversal. The order of `nodes` and `edges` within each step may vary depending on the traversal logic.

```json
{"nodes": [], "edges": [{"id": "e::step1_edge1", "source": "n::start_node", "target": "n::next_node_A"}]}
{"nodes": [{"id": "n::next_node_A", "edges": ["e::step1_edge1"]}], "edges": []}
{"nodes": [], "edges": [{"id": "e::step2_edge1", "source": "n::next_node_A", "target": "n::final_node_B"}]}
{"nodes": [{"id": "n::final_node_B", "edges": ["e::step2_edge1"]}], "edges": []}
... (additional steps will be streamed as the traversal continues)
```




================================================================================
FILE: docs/learn/jac-cloud/webhook.md
================================================================================


# Webhooks: External API Integration

## What are Webhooks?

Webhooks are a way for external services to securely call your Jac Cloud application when certain events occur. Unlike regular authenticated walkers (which are associated with a specific user), webhook walkers are directly linked to the root node and are secured with API keys rather than user tokens.

## Key Features

- **Direct Root Access**: Webhooks operate at the root level, not tied to any specific user
- **API Key Management**: Generate, extend, and delete API keys through the API
- **Flexible Authentication**: Support for different API key placement methods (header, query, path, body)
- **Customizable**: You can specify allowed walkers, nodes, and expiration dates for each API key

## Creating a Webhook Walker

To declare a walker as a webhook endpoint, add a `webhook` configuration to the `__specs__` class:

```jac
walker webhook {
    can enter1 with `root entry {
        report here;
    }

    class __specs__ {
        has webhook: dict = {
            "type": "header | query | path | body",  # optional: defaults to header
            "name": "any string"                     # optional: defaults to X-API-KEY
        };
    }
}
```

The `type` field specifies where the API key will be placed in the HTTP request:

- `header`: In the HTTP headers (default)
- `query`: As a query parameter
- `path`: As part of the URL path
- `body`: In the request body

The `name` field is the name of the parameter that will contain the API key.

## Managing API Keys

Jac Cloud provides several endpoints for managing webhook API keys:

![Webhook Management API endpoints](https://github.com/user-attachments/assets/3a01ab35-06b0-4942-8f1f-0c4ae794ce21)

### Generating a New API Key

**Endpoint:** `POST /webhook/generate-key`

**Request Body:**

```python
{
  "name": "webhook1",
  "walkers": ["webhook"],
  "nodes": ["root"],
  "expiration": {
    "count": 60,
    "interval": "days"
  }
}
```

| Parameter  | Description                                                                                                                  |
| ---------- | ---------------------------------------------------------------------------------------------------------------------------- |
| name       | A unique identifier for the webhook key.                                                                                     |
| walkers    | A list of specific walker names that are permitted to use this key. If this list is empty, all walkers are allowed.          |
| nodes      | A list of specific node names that are permitted to be accessed with this key. If this list is empty, all nodes are allowed. |
| expiration | Defines the expiration settings for the webhook key.                                                                         |
| count      | The numerical value for the expiration duration.                                                                             |
| interval   | The unit of time for the expiration duration. Valid values include "seconds", "minutes", "hours", and "days".                |

**Response:**

```python
{
  "id": "672203ee093fd3d208a4b6d4",
  "name": "webhook1",
  "key": "6721f000ee301e1d54c3de3d:1730282478:P4Nrs3DOLIkaw5aYsbIWNzWZZAwEyb20"
}
```

### Listing All API Keys

**Endpoint:** `GET /webhook`

**Response:**

```python
{
  "keys": [
    {
      "id": "672203ee093fd3d208a4b6d4",
      "name": "test",
      "root_id": "6721f000ee301e1d54c3de3d",
      "walkers": ["webhook"],
      "nodes": ["root"],
      "expiration": "2025-12-24T10:01:18.206000",
      "key": "6721f000ee301e1d54c3de3d:1730282478:P4Nrs3DOLIkaw5aYsbIWNzWZZAwEyb20"
    }
  ]
}
```

### Extending an API Key's Expiration

**Endpoint:** `PATCH /webhook/extend/{id}`

**Request Body:**

```python
{
  "count": 60,
  # seconds | minutes | hours | days
  "interval": "days"
}
```

**Response:**

```python
{
  "message": "Successfully Extended!"
}
```

### Deleting API Keys

**Endpoint:** `DELETE /webhook/delete`

**Request Body:**

```python
{
  # list of ids to be deleted
  "ids": ["672203ee093fd3d208a4b6d4"]
}
```

**Response:**

```python
{
  "message": "Successfully Deleted!"
}
```

## Webhook Implementation Examples

Here are examples of different webhook implementations:

### 1. Using Header for API Key (Default)

```jac
walker webhook_by_header {
    can enter1 with `root entry {
        report here;
    }

    class __specs__ {
        has webhook: dict = {
            "type": "header",
            "name": "test-key"
        };
    }
}
```

**Example Request:**

```bash
curl -X 'POST' 'http://localhost:8001/webhook/walker/webhook_by_header' \
  -H 'test-key: YOUR-GENERATED-KEY'
```

### 2. Using Query Parameter for API Key

```jac
walker webhook_by_query {
    can enter1 with `root entry {
        report here;
    }

    class __specs__ {
        has webhook: dict = {
            "type": "query",
            "name": "test_key"
        };
    }
}
```

**Example Request:**

```bash
curl -X 'POST' 'http://localhost:8001/webhook/walker/webhook_by_query?test_key=YOUR-GENERATED-KEY'
```

### 3. Using Path Parameter for API Key

```jac
walker webhook_by_path {
    can enter1 with `root entry {
        report here;
    }

    class __specs__ {
        has webhook: dict = {
            "type": "path",
            "name": "test_key"  # name and the path var should be the same
        }, path: str = "/{test_key}";
    }
}
```

**Example Request:**

```bash
curl -X 'POST' 'http://localhost:8001/webhook/walker/webhook_by_path/YOUR-GENERATED-KEY'
```

### 4. Using Request Body for API Key

```jac
walker webhook_by_body {
    can enter1 with `root entry {
        report here;
    }

    class __specs__ {
        has webhook: dict = {
            "type": "body",
            "name": "test_key"
        };
    }
}
```

**Example Request:**

```bash
curl -X 'POST' 'http://localhost:8001/webhook/walker/webhook_by_body' -d '{"test_key": "YOUR-GENERATED-KEY"}'
```

## Best Practices

1. **Set Appropriate Expirations**: For security, use short-lived keys when possible.
2. **Limit Walker Access**: Specify only the walkers that should be accessible for each key.
3. **Use Specific Node Restrictions**: When possible, limit which nodes can be accessed.
4. **Regularly Rotate Keys**: Create a process to regularly generate new keys and invalidate old ones.
5. **Use Headers by Default**: Header-based API keys are generally more secure than query parameters or body values.

## Common Use Cases

Webhooks are ideal for:

- **Integration with Third-Party Services**: Allow external services to trigger specific actions in your application
- **Scheduled Events**: Receive notifications from scheduling services
- **Notifications**: Handle notifications from payment processors, source control systems, etc.
- **IoT Communication**: Enable secure communication from IoT devices
- **CI/CD Pipelines**: Trigger deployments or other actions from CI/CD systems

## Troubleshooting

If your webhook isn't working:

1. Verify the API key hasn't expired
2. Ensure you're sending the key in the correct location (header, query, path, or body)
3. Check that the parameter name matches your configuration
4. Confirm the walker and node are allowed for the API key
5. Check the logs for any errors

## Next Steps

- Learn about [WebSocket Communication](websocket.md) for real-time bidirectional communication
- Explore [Task Scheduling](scheduler.md) for running walkers on a schedule
- See how to properly [Deploy to Production](deployment.md) with secure webhook configurations




================================================================================
FILE: docs/learn/jac-cloud/websocket.md
================================================================================


# WebSocket: Real-Time Communication

## Overview

WebSockets enable real-time, bidirectional communication between clients and your Jac application. This is particularly useful for:

- Chat applications
- Real-time dashboards
- Collaborative tools
- Live notifications
- Any application requiring instant updates

## Walker Declaration for WebSockets

You can declare a walker to handle WebSocket connections by setting the `methods` property to include `"websocket"` in the `__specs__` configuration:

```jac
walker your_event_name {
    has val: int;

    can enter with `root entry {
        report "Do something!";
    }

    class __specs__ {
        has methods: list = ["websocket"];
    }
}
```

**Note**: WebSocket walkers can still work with other HTTP methods; however, they currently don't support file uploads.

## WebSocket Connection Details

### Connection URL and Parameters

- **Protocol**: `ws`
- **URL**: `/websocket`
- **Optional Header**: `Authorization: Bearer {{USER-TOKEN}}`
- **Optional Query Parameter**: `?channel_id=anystring`

### Connection Process

When a client connects to the WebSocket endpoint, it will immediately receive a connection information event:

```python
{
	"type": "connection",
	"data": {
        # your websocket client id
		"client_id": "1730887348:f46d85203c704c099e9f44e948322a20",

        # user's root_id
		"root_id": "n::672b35cec309e5ef8469c372",

        # non authenticated
		# "root_id": "n::000000000000000000000001",

        # user's channel id, random if not specified
		"channel_id": "1730887348:796ad2e9fa3e484ebe01f071c381b7e8"
	}
}
```

### Connection Types

There are two types of connections:

1. **Authenticated Connection** - Uses a valid Authorization token
2. **Non-Authenticated Connection** - Public access

### Channel Subscription

You can specify a `channel_id` via query parameter to receive notifications from a specific channel. This is particularly useful for group chat or notification applications.

## Client Event Types

Clients can send different types of events to the server through the WebSocket connection:

### 1. Walker Event

Triggers a walker just like a REST API call:

```python
{
    # event type
	"type": "walker",

    # walker's name
	"walker": "your_event_name",

    # if you want to receive a notification for response
	"response": true,

    # walker's request context
	"context": {
        "val": 1
    }
}
```

### 2. User Event

Sends a notification to specific users:

```python
{
    # event type
	"type": "user",

    # target user/s via root_id
    "root_ids": ["n::672b35cec309e5ef8469c372"],

    # data you want to send
	"data": {
        "val": 1
    }
}
```

### 3. Channel Event

Sends a notification to all clients subscribed to specific channels:

```python
{
    # event type
	"type": "channel",

    # target channel_id/s
    "channel_ids": ["anystring"],

    # data you want to send
	"data": {
        "val": 1
    }
}
```

### 4. Client Event

Sends a notification to specific clients:

```python
{
    # event type
	"type": "client",

    # target client_ids
    "client_ids": ["1730887348:f46d85203c704c099e9f44e948322a20"],

    # data you want to send
	"data": {
        "val": 1
    }
}
```

### 5. Change User Event

Switches between authenticated and public user:

```python
{
    # event type
	"type": "change_user",

    # optional - defaults to public user
	"token": "bearer {{user's token}}"
}
```

## Server-Side Notification Methods

### Prerequisites

To send notifications from your walker, import the WebSocket manager:

```python
import from jac_cloud.plugin {WEBSOCKET_MANAGER as socket}
```

### Available Notification Methods

#### 1. Self Notification

Sends a notification to the current WebSocket client (only valid on WebSocket walker events):

```python
socket.notify_self({"any_field": "for_progress", "progress": "0%", "status": "started"});
```

#### 2. User Notification

Sends a notification to all clients of specific users:

```python
socket.notify_users([root], {"any_field": "for_progress", "progress": "0%", "status": "started"});
```

#### 3. Channel Notification

Sends a notification to all clients subscribed to specific channels:

```python
socket.notify_channels([channel_id], {"any_field": "for_progress", "progress": "0%", "status": "started"});
```

#### 4. Client Notification

Sends a notification to specific client connections:

```python
socket.notify_clients([client_id], {"any_field": "for_progress", "progress": "0%", "status": "started"});
```

## End-to-End Integration Example

### Server-Side (Jac)

```jac
"""Websocket scenarios."""
import from jac_cloud.plugin {WEBSOCKET_MANAGER as socket}

###########################################################
#                   WEBSOCKET ENDPOINTS                   #
###########################################################

walker send_chat_to_user {
    has root_id: str;

    can enter1 with `root entry {
        _root = &(self.root_id);

        socket.notify_users([_root], {"type": "chat", "data": {"message": "string"}});
    }

    class __specs__ {
        has methods: list = ["websocket", "post"];
    }
}


walker send_chat_to_group {
    has channel_id: str;

    can enter1 with `root entry {
        socket.notify_channels([self.channel_id], {"type": "chat", "data": {"message": "string"}});
    }

    class __specs__ {
        has methods: list = ["websocket", "post"];
    }
}

walker send_chat_to_client {
    has client_id: str;

    can enter1 with `root entry {
        socket.notify_clients([self.client_id], {"type": "chat", "data": {"message": "string"}});
    }

    class __specs__ {
        has methods: list = ["websocket", "post"];
    }
}
```

### Client-Side (JavaScript)

#### WebSocket Connection

**Important Note**: The JavaScript WebSockets API doesn't natively support headers for authentication. You'll need to use the `change_user` event or a third-party WebSocket library that supports headers.

```js
//####################################################//
//           NOT AUTHENTICATED - JS LIBRARY           //
//####################################################//
const client = new WebSocket("ws://localhost:8000/websocket");

//####################################################//
//             AUTHENTICATED - JS LIBRARY             //
//####################################################//

const client = new WebSocket("ws://localhost:8000/websocket");
client.onopen = (event) => {
  client.send(JSON.stringify({
    "type": "change_user",
    "token": "Bearer {{user's token}}" // optional - default to public user
  }));
};

//####################################################//
//           AUTHENTICATED - NPM WS LIBRARY           //
//####################################################//
import WebSocket from 'ws';

const client = new WebSocket('ws://localhost:8000/websocket', {
  headers: {
    "Authorization": "Bearer {{user's token}}"
  }
});
```

#### Consuming Events

```js
client.onmessage = (event) => {
  const msg = JSON.parse(event.data);
  switch (msg.type) {
    case "connection":
      // to check connection info
    case "chat":
      console.log(msg.data)
    case "your_event1":
      console.log(msg.data)
    case "your_event2":
      console.log(msg.data)
    case "your_event3":
      console.log(msg.data)
  }
};
```

#### Publishing Events

```js
// TRIGGER WALKER EVENT
client.send(JSON.stringify({
	"type": "walker",
	"walker": "your_walker_name",
	"response": true,
	"context": {}
}));

// TRIGGER CLIENT EVENT (ex: direct chat)
client.send(JSON.stringify({
	"type": "client",
	"client_ids": ["target client_id from connection event"],
	"data": {
		"type": "chat",
    "data": {
      "any_field": "any_value"
    }
	}
}));

// TRIGGER CHANNEL EVENT (ex: group chat or chat blast)
client.send(JSON.stringify({
	"type": "channel",
	"channel_ids": ["target channel_id from connection event"],
	"data": {
		"type": "chat",
    "data": {
      "any_field": "any_value"
    }
	}
}));

// TRIGGER USER EVENT (ex: chat but all target user's client)
client.send(JSON.stringify({
	"type": "user",
	"root_ids": ["target root_id from connection event"],
	"data": {
		"type": "chat",
    "data": {
      "any_field": "any_value"
    }
	}
}));

// TRIGGER CONNECTION EVENT - to get connection info)
client.send(JSON.stringify({
	"type": "connection"
}));
```

## Best Practices

1. **Use Channels for Group Communication**: Instead of sending messages to multiple clients individually, use channels.
2. **Handle Reconnection Logic**: Implement reconnection logic in your client to handle network disruptions.
3. **Validate All Messages**: Always validate incoming messages to prevent security issues.
4. **Set Ping/Pong Timeouts**: Configure appropriate ping/pong intervals to detect disconnected clients.
5. **Use Authorization**: For private communications, always use authenticated connections.

## Common Use Cases

- **Chat Applications**: Real-time messaging between users
- **Notifications**: Instant alerts and notifications
- **Live Updates**: Real-time updates to dashboards or data displays
- **Collaborative Tools**: Multiple users working on the same document or project
- **Gaming**: Real-time multiplayer games

## Troubleshooting

- **Connection Issues**: Verify the WebSocket URL and ensure your server is running
- **Authentication Problems**: Check that your token is valid and properly formatted
- **Message Delivery Failures**: Confirm that client IDs, user IDs, or channel IDs are correct
- **Performance Issues**: Consider using channels instead of individual client notifications for better performance

---
### Additional Resources
For a complete working example, you may download this [API Request Collection](https://github.com/amadolid/jaseci/blob/websocket-backup-final/jac-cloud/jac_cloud/tests/jac-cloud-websocket.insomnia)



================================================================================
FILE: docs/learn/jac-lens.md
================================================================================


<div style="text-align: center; margin-bottom: 30px;">
    <!-- <img src="./assets/jac-lens/jac-lens-logo.png" alt="Jac Lens Logo" style="width: 120px; height: auto; margin-bottom: 15px;"> -->
    <h1 style="color: orange; font-weight: bold; margin: 0;">Jac Lens</h1>
    <h2 style="color: white; font-weight: 300; font-size: 1.2em; margin-top: 5px; margin-bottom: 0; opacity: 0.8;">Manage your jac cloud data at ease</h2>
</div>

<style>
.md-typeset .grid.cards {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 1rem;
    margin: 1.5rem 0;
}

.md-typeset .grid.cards > * {
    min-height: 200px;
    display: flex;
    flex-direction: column;
}

.md-typeset .grid.cards.single-column {
    grid-template-columns: 1fr;
}

@media (max-width: 768px) {
    .md-typeset .grid.cards {
        grid-template-columns: 1fr;
    }
}
</style>


Jac Lens is a powerful Progressive Web App (PWA) that provides an intuitive visual interface for exploring and managing your Jac graph data. It allows you to connect to your Jac server, navigate through node relationships, and modify node properties in real-time.

## Quick Start

### 1. Access the Application

- **URL**: https://jaclens.jaseci.org/
- **Browser**: Chrome recommended for optimal experience
- **Installation**: Follow browser prompts to install as a Progressive Web App (PWA)

<div class="grid cards single-column" markdown>

-   __Install as PWA__

    ---

    *Get the full app experience*

    ![PWA Installation](./assets/jac-lens/jac-lens-download.gif)

-   __Connect to Server__

    ---

    *Link to your Jac instance*

    ![Server Connection](./assets/jac-lens/jac-lens-create-session.gif)

-   __Explore Graph__

    ---

    *Navigate node relationships*

    ![Graph Exploration](./assets/jac-lens/jac-lens-explore-graphs.gif)

-   __Update Graph__

    ---

    *Navigate node relationships*

    ![Graph Exploration](./assets/jac-lens/jac-lens-modify-graph.gif)

</div>

### 2. Installation Process

The Jac Lens PWA installation is straightforward:

1. **Open the URL** in Chrome browser
2. **Look for the install prompt** in the address bar or menu
3. **Click "Install"** to add to your home screen
4. **Launch from your apps** for a native experience

> **Note**
>
> Installing as a PWA provides offline capabilities and a more app-like experience.

## Setup for Jac Cloud (Pre-0.2.5)

If you're using Jac Cloud version prior to 0.2.5, you need to manually add the required walkers to your application.

### Required Walkers

Create a file named `jaclens.jac` with the following content:

```jac
walker get_attached_nodes {
    has node_id: str = "";
    can get_attach_nodes with `root entry {
        if(self.node_id == "") {
            report jid(here);
        } else {
            selected_node = &self.node_id;
            attached_nodes = [selected_node-->];
            report attached_nodes;
        }
    }
}

walker update_node_data {
    has node_id: str = "";
    has node_data: dict = {};
    can update_node_data with `root entry {
        selected_node = &self.node_id;
        selected_node.__dict__.update(self.node_data);
        report selected_node;
    }
}
```

### Integration Steps

1. **Create the file** `jaclens.jac` in your project
2. **Copy the walker code** above into the file
3. **Include in your main file** by adding `include jaclens;` at the top of your application entry JAC file

??? info "Why These Walkers?"
    These walkers provide the necessary functionality for Jac Lens to:
    - Retrieve node information and relationships
    - Update node properties in real-time
    - Navigate through your graph structure

## Using Jac Lens

### 1. Server Connection

Connect to your Jac server by providing:

- **Host URL**: Your Jac server address (remove trailing slash)
- **Email**: Your account email
- **Password**: Your account password

??? example "Example Connection"
    ```
    Host URL: https://my-jac-server.com
    Email: user@example.com
    Password: ********
    ```

### 2. Graph Navigation

Once connected, you can explore your graph:

- **Click on nodes** to view their properties
- **Navigate connections** between nodes
- **Zoom and pan** to explore large graphs
- **Search for specific nodes** using the search functionality

### 3. Node Management

Modify node properties directly in the interface:

- **Edit node attributes** in the side panel
- **Save changes** to update your server
- **View node relationships** and connections
- **Delete nodes** when needed

### 4. Session Management

Jac Lens automatically manages your sessions:

- **Automatic saving** of your current view
- **Session persistence** across browser sessions
- **Resume where you left off** when returning to the app

## Features Overview

<div class="grid cards" markdown>

-   __Real-time Updates__

    ---

    *See changes instantly*

    Changes made in Jac Lens are immediately reflected in your Jac server

-   __Graph Visualization__

    ---

    *Visual node relationships*

    Interactive graph view with zoom, pan, and node selection

-   __Property Editing__

    ---

    *Modify node attributes*

    In-place editing of node properties and metadata

-   __Search & Filter__

    ---

    *Find nodes quickly*

    Search functionality to locate specific nodes in large graphs

</div>

## Troubleshooting

### Common Issues

??? failure "Connection Failed"
    - Verify your server URL is correct
    - Ensure your credentials are valid
    - Host url doesn't have trailing slash
    - Check that your server is running and accessible


??? failure "Graph Not Loading"
    - Confirm you have the required walkers installed
    - Check your server logs for errors
    - Verify your graph has data to display

??? failure "Changes Not Saving"
    - Ensure you have write permissions
    - Check your network connection
    - Verify the update_node_data walker is working

### Getting Help

If you encounter issues not covered here:

1. **Check the browser console** for error messages
2. **Verify your Jac server logs** for backend errors
3. **Ensure you're using a compatible browser** (Chrome recommended)
4. **Contact the Jac community** for additional support





================================================================================
FILE: docs/learn/jac_playground.md
================================================================================


# Jac Playground Guide

Welcome to the Jac Playground! This interactive development environment lets you write, run, and debug Jac programs directly in your browser.

## Getting Started

The Jac Playground is designed to help you learn and experiment with the Jac programming language. When you first open the playground, you'll see a simple "Hello World" program:

```jac
with entry {
    print("Welcome to Jac!");
}
```

## How to Use

![Description of GIF](../assets/runtime.gif)

1. **Start with Examples**: Click on any example from the right sidebar to load it into the editor
2. **Modify and Experiment**: Edit the code to see how changes affect the output
3. **Run Your Code**: Press the "Run" button to execute your program
4. **Debug When Needed**: Enable Debug Mode for detailed execution analysis
5. **Reset When Stuck**: Use the Reset button to start with a clean slate

## Debug Mode
Debug Mode transforms the Jac Playground into a powerful development environment with advanced debugging capabilities. When enabled, the interface splits into two main sections: the code editor on the left and the **Jaclang Graph Visualizer** on the right.

### Jaclang Graph Visualizer

![Debug Mode with Graph Visualizer](../assets/visualizer.jpg)


### Jac Playground - Jaclang Graph Visualizer Demo

![Click here to watch the Debug Mode Demo Video](../assets/playground_demo.gif)

### Using Debug Mode Effectively

1. **Set breakpoints** by clicking on line numbers in the editor
2. **Start debugging** by clicking the Debug button instead of Run
3. **Navigate execution** using the arrow keys or debug controls
4. **Observe the graph** to understand how your nodes and edges are connected
5. **Step through slowly** to see how data flows through your spatial program structure

The Graph Visualizer makes Jac's spatial programming concepts tangible, allowing you to see exactly how your objects, walkers, and edges interact during program execution.


## Interface Overview

### Main Editor
The left side of the screen contains the code editor where you can write your Jac programs. The editor features:

- Syntax highlighting for Jac language
- Line numbers for easy reference
- Auto-indentation and bracket matching

### Control Panel
At the top of the editor, you'll find:

- **Run Button** â–¶ï¸ - Execute your Jac program
- **Reset Button** ðŸ”„ - Clear the editor and start fresh
- **Debug Mode Toggle** ðŸ› - Enable debugging features for step-by-step execution

### Debug Controls

When Debug Mode is active, you'll notice additional controls in the Run Mode toolbar:

- **Continue** â–¶ï¸ - Start or continue execution
- **Step Over** â­ï¸ - Execute the next line of code
- **Step Into** â¬‡ï¸ - Move deeper into function calls
- **Step Out** â¬†ï¸ - Move up from current execution context
- **Restart** ðŸ”„ - Reset the debug session
- **Stop** â¹ï¸ - Terminate the current debug session

The Graph Visualizer is one of Jac's most powerful debugging features, providing a real-time visual representation of your program's execution flow. This unique tool shows:

### Output Panel
The bottom section displays the output of your program, including:

- Print statements and results
- Error messages and debugging information
- Program execution feedback

### Example Library
The right sidebar contains a collection of sample programs organized by category:

#### Basic Examples
- **For Loop** - Learn iteration with for loops
- **While Loop** - Understand conditional looping
- **Archetypes** - Explore Jac's type system
- **Code Block Statements** - Work with code organization
- **Assignments** - Variable declaration and manipulation
- **Conditional Statements** - If/else logic and branching

#### Object Spatial Programming
- **Reference** - Understanding object references and relationships

## Tips for New Users

- Start with the "Basic" examples to understand Jac syntax
- Use the print statement to output values and debug your code
- Experiment with modifying the example programs
- Don't be afraid to break things - that's how you learn!
- Use Debug Mode when your program doesn't behave as expected

## Example Categories Explained

### Basic Programming Concepts
These examples cover fundamental programming constructs that are essential for any Jac programmer.

### Object Spatial Programming
Jac's unique approach to spatial programming and object relationships. These advanced examples show how Jac handles complex data structures and spatial reasoning.

## Getting Help

If you encounter issues or want to learn more about specific Jac language features, refer to the official Jac documentation or community resources.

Happy coding with Jac! ðŸš€



================================================================================
FILE: docs/learn/keywords.md
================================================================================


# Jac Programming Language Keyword Reference

 Keywords are special reserved words that have a specific meaning and purpose in the language and cannot be used as identifiers for variables, functions, or other objects. In Jac, all the keywords that exist in Python can also be used.

---

## 1. Archetype and Data Structure Keywords

These keywords define the core data and structural elements in Jac, forming the foundation for graph-based and object-oriented programming.

**Core Archetype Keywords**

| Keyword | Description |
| --- | --- |
| [`obj`](https://www.jac-lang.org/learn/jac_ref/#archetype-types) | Defines a standard object, similar to a Python class, for holding data and behaviors. |
| [`node`](https://www.jac-lang.org/learn/jac_ref/#archetype-types) |Represents a vertex or location in a graph, capable of storing data.|
| [`edge`](https://www.jac-lang.org/learn/jac_ref/#archetype-types)|Defines a directed connection between two nodes, which can have its own attributes and logic. |
| [`walker`](https://www.jac-lang.org/learn/jac_ref/#archetype-types) | A mobile computational agent that traverses the graph of nodes and edges to process data. |
| [`class`](https://www.jac-lang.org/learn/jac_ref/#archetype-types)  |Defines a standard Python-compatible class, allowing for seamless integration with the Python ecosystem. |
| [`enum`](https://www.jac-lang.org/learn/jac_ref/#enumerations)  |Creates an enumeration, a set of named constants. |

---

## 2. Variable and State Declaration Keywords

These keywords are used for declaring variables and managing their state and scope.

**Variable Declaration**

| Keyword | Description |
| --- | --- |
| [`has`](https://www.jac-lang.org/learn/jac_ref/#constructor-rules-and-has-variables) | Declares an instance variable within an archetype, with mandatory type hints. |
| [`let`](https://www.jac-lang.org/learn/jac_ref/#declaration-keywords) | Declares a module-level variable with lexical (module-level) scope. |
| [`glob`](https://www.jac-lang.org/learn/jac_ref/#declaration-keywords) | Declares a global variable accessible across all modules. |
| [`global`](https://www.jac-lang.org/learn/jac_ref/#global-and-nonlocal-statements) | Modifies a global variable from within a local scope. |
| [`nonlocal`](https://www.jac-lang.org/learn/jac_ref/#global-and-nonlocal-statements) | Modifies a variable from a nearby enclosing scope that isn't global. |

---

## 3. Ability and Function Keywords

These keywords define callable units of code, such as functions and methods associated with archetypes.

**Function and Method Definition**

| Keyword | Description |
| --- | --- |
| [`can`](https://www.jac-lang.org/learn/jac_ref/#functions-and-abilities) | Defines an "ability" (a method) for an archetype. |
| [`def`](https://www.jac-lang.org/learn/jac_ref/#functions-and-abilities) | Defines a standard function with mandatory type annotations. |
| [`impl`](https://www.jac-lang.org/learn/jac_ref/#implementations) | Separates the implementation of a construct from its declaration. |
| [`yield`](https://www.jac-lang.org/learn/jac_ref/#yield-statements) | Pauses a function, returns a value, and creates a generator. |

---

## 4. Control Flow and Logic Keywords

These keywords direct the path of execution, enabling conditional logic, loops, and error handling.

**Control Flow Statements**

| Keyword | Description |
| --- | --- |
| [`if` / `elif` / `else`](https://www.jac-lang.org/learn/jac_ref/#if-statements) | Executes code blocks conditionally. |
| [`for`](https://www.jac-lang.org/learn/jac_ref/#for-statements) | Iterates over a sequence. |
| [`while`](https://www.jac-lang.org/learn/jac_ref/#while-statements) | Creates a loop that executes as long as a condition is true. |
| [`match` / `case`](https://www.jac-lang.org/learn/jac_ref/#match-statements) | Implements structural pattern matching. |
| [`try` / `except` / `finally`](https://www.jac-lang.org/learn/jac_ref/#try-statements) | Handles exceptions. |
| [`break`](https://www.jac-lang.org/learn/jac_ref/#while-statements) | Exits the current loop. |
| [`continue`](https://www.jac-lang.org/learn/jac_ref/#while-statements) | Proceeds to the next iteration of a loop. |
| [`raise`](https://www.jac-lang.org/learn/jac_ref/#raise-statements) | Triggers an exception. |

---

## 5. Walker-Specific Control Keywords

These keywords are used exclusively to control the traversal behavior of `walker` agents on a graph.

**Walker Navigation**

| Keyword | Description |
| --- | --- |
| [`visit`](https://www.jac-lang.org/learn/jac_ref/#visit-statement) | Directs a walker to traverse to a node or edge. |
| [`spawn`](https://www.jac-lang.org/learn/jac_ref/#object-spatial-spawn-expressions) | Creates and starts a walker on a graph. |
| [`ignore`](https://www.jac-lang.org/learn/jac_ref/#ignore-statement)  |Excludes a node or edge from a walker's traversal. |
| [`disengage`](https://www.jac-lang.org/learn/jac_ref/#disengage-statement) | Immediately terminates a walker's traversal. |
| [`report`](https://www.jac-lang.org/learn/jac_ref/#report-statements) | Sends a result from a walker back to its spawning context. |
| [`with entry`](https://www.jac-lang.org/learn/jac_ref/#integration-with-entry-points) | Defines the main execution block for a module. |


---

## 6. Concurrency and Asynchronous Keywords

These keywords are used to manage concurrent and asynchronous operations for non-blocking execution.

**Asynchronous Operations**

| Keyword | Description |
| --- | --- |
| [`flow`](https://www.jac-lang.org/learn/jac_ref/#flow-modifier)  |Initiates a concurrent, non-blocking execution of an expression. |
| [`wait`](https://www.jac-lang.org/learn/jac_ref/#flow-modifier) | Pauses execution to await the completion of a concurrent operation. |
| [`async`](https://www.jac-lang.org/learn/jac_ref/#flow-modifier) | Declares a function or ability as asynchronous. |

---


## 7. AI and Language Model Integration

These keywords facilitate the integration of AI and Large Language Models (LLMs) directly into the language.


**AI Integration**


| Keyword | Description |
| --- | --- |
| [`sem`](https://www.jac-lang.org/learn/jac_ref/#semstrings)  |Associates a natural language "semantic string" with a code element for AI interpretation. |
| [`by`](https://www.jac-lang.org/learn/jac-byllm/usage/) | Defers a task to an LLM instead of providing a manual implementation. |

---

## 8. Miscellaneous Keywords

This section covers other essential keywords used for various operations.


**Other Essential Keywords**

| Keyword | Description |
| --- | --- |
| [`del`](https://www.jac-lang.org/learn/jac_ref/#delete-statements) | Deletes objects, properties, or elements. |
| [`assert`](https://www.jac-lang.org/learn/jac_ref/#assert-statements) | Verifies if a condition is true, raising an error if not. |
| [`<keyword>`](https://www.jac-lang.org/learn/jac_ref/#keyword-escaping) | Used to escape reserved keywords when you want to use them as variable or attribute names, e.g., `<>node= 90;`, `<>dict = 8;`|
|[`test`](https://www.jac-lang.org/learn/jac_ref/#test-implementations)|Defines test cases for code validation and unit testing. |


---

!!! tip "Keyword Usage Guidelines"
    - **Reserved words**: Keywords cannot be used as variable or function names
    - **Case sensitive**: All keywords must be written in lowercase
    - **Context matters**: Some keywords are only valid in specific contexts (e.g., walker keywords)
    - **Type safety**: Many keywords work with Jac's type system for better code reliability



================================================================================
FILE: docs/learn/library_mode.md
================================================================================


# **Jac Library Mode: Pure Python with Jac's Power**

## **Introduction**

Every Jac program can be expressed as pure Python code using Jac's library mode. This means you get **100% of Jac's object-spatial programming capabilities** in regular Python syntaxâ€”no new language to learn, just powerful libraries to import.

Library mode is perfect for:
- **Python-first teams** wanting to adopt Jac gradually
- **Existing Python codebases** that need graph-based features
- **Understanding Jac's internals** by seeing the Python equivalent
- **Maximum interoperability** with Python tools and frameworks

### **Turn any Jac code example you see to Pure Python**

When you run `jac jac2lib myfile.jac`, Jac generates clean Python code that:
1. Imports from `jaclang.lib` instead of using aliased imports
2. Uses direct function calls like `spawn()` and `visit()` instead of `_jl.spawn()`
3. Produces readable, maintainable code suitable for library distribution

---

## **The Friends Network Example**

Let's walk through a complete example that demonstrates Jac's object-spatial programming in library mode.

### **The Jac Code**

Here's a social network graph with people connected by friendship and family relationships:

```jac
node Person {
    has name: str;

    can announce with FriendFinder entry {
        print(f"{visitor} is checking me out");
    }
}

edge Friend {}
edge Family {
    can announce with FriendFinder entry {
        print(f"{visitor} is traveling to family member");
    }
}

with entry {
    # Build the graph
    p1 = Person(name="John");
    p2 = Person(name="Susan");
    p3 = Person(name="Mike");
    p4 = Person(name="Alice");
    root ++> p1;
    p1 +>: Friend :+> p2;
    p2 +>: Family :+> [p1, p3];
    p2 +>: Friend :+> p3;
}

walker FriendFinder {
    has started: bool = False;

    can report_friend with Person entry {
        if self.started {
            print(f"{here.name} is a friend of friend, or family");
        } else {
            self.started = True;
            visit [-->];
        }
        visit [edge ->:Family :->];
    }

    can move_to_person with `root entry {
        visit [-->];
    }
}

with entry {
    result = FriendFinder() spawn root;
    print(result);
}
```

### **The Library Mode Python Equivalent**

Run `jac jac2lib friends.jac` to generate:

```python
from __future__ import annotations
from jaclang.lib import (
    Edge,
    Node,
    Path,
    Root,
    Walker,
    build_edge,
    connect,
    on_entry,
    refs,
    root,
    spawn,
    visit,
)


class Person(Node):
    name: str

    @on_entry
    def announce(self, visitor: FriendFinder) -> None:
        print(f"{visitor} is checking me out")


class Friend(Edge):
    pass


class Family(Edge):

    @on_entry
    def announce(self, visitor: FriendFinder) -> None:
        print(f"{visitor} is traveling to family member")


# Build the graph
p1 = Person(name="John")
p2 = Person(name="Susan")
p3 = Person(name="Mike")
p4 = Person(name="Alice")
connect(left=root(), right=p1)
connect(left=p1, right=p2, edge=Friend)
connect(left=p2, right=[p1, p3], edge=Family)
connect(left=p2, right=p3, edge=Friend)


class FriendFinder(Walker):
    started: bool = False

    @on_entry
    def report_friend(self, here: Person) -> None:
        if self.started:
            print(f"{here.name} is a friend of friend, or family")
        else:
            self.started = True
            visit(self, refs(Path(here).edge_out().visit()))
        visit(
            self,
            refs(
                Path(here).edge_out(edge=lambda i: isinstance(i, Family)).edge().visit()
            ),
        )

    @on_entry
    def move_to_person(self, here: Root) -> None:
        visit(self, refs(Path(here).edge_out().visit()))


result = spawn(FriendFinder(), root())
print(result)
```

---

## **Key Concepts Explained**

### **1. Nodes and Edges**

**In Jac:**
```jac
node Person {
    has name: str;
}

edge Friend {}
```

**In Library Mode:**
```python
from jaclang.lib import Node, Edge


class Person(Node):
    name: str


class Friend(Edge):
    pass
```

- Inherit from `Node` for graph nodes
- Inherit from `Edge` for relationships between nodes
- Use Python's class attributes for data fields

### **2. Walkers**

**In Jac:**
```jac
walker FriendFinder {
    has started: bool = False;
}
```

**In Library Mode:**
```python
from jaclang.lib import Walker


class FriendFinder(Walker):
    started: bool = False
```

- Inherit from `Walker` for graph traversal agents
- Walkers move through the graph and execute logic at each node

### **3. Abilities (Event Handlers)**

**In Jac:**
```jac
can report_friend with Person entry {
    print(f"{here.name} is a friend");
}
```

**In Library Mode:**
```python
from jaclang.lib import on_entry


@on_entry
def report_friend(self, here: Person) -> None:
    print(f"{here.name} is a friend")
```

- Use `@on_entry` decorator for entry abilities
- Use `@on_exit` decorator for exit abilities
- The `here` parameter represents the current node
- The `visitor` parameter (in node/edge abilities) represents the walker

### **4. Connecting Nodes**

**In Jac:**
```jac
root ++> p1;                      # Connect root to p1
p1 +>: Friend :+> p2;             # Connect p1 to p2 with Friend edge
p2 +>: Family :+> [p1, p3];       # Connect p2 to multiple nodes
```

**In Library Mode:**
```python
from jaclang.lib import connect, root

connect(left=root(), right=p1)
connect(left=p1, right=p2, edge=Friend)
connect(left=p2, right=[p1, p3], edge=Family)
```

- `connect()` creates directed edges between nodes
- `edge` parameter specifies the edge type
- Can connect to single nodes or lists of nodes

### **5. Spawning Walkers**

**In Jac:**
```jac
result = FriendFinder() spawn root;
```

**In Library Mode:**
```python
from jaclang.lib import spawn, root

result = spawn(FriendFinder(), root())
```

- `spawn()` starts a walker at a specific node
- `root()` returns the root node of the graph
- Returns the walker after traversal completes

### **6. Visiting Nodes**

**In Jac:**
```jac
visit [-->];                      # Visit all outgoing edges
visit [edge ->:Family :->];       # Visit only Family edges
```

**In Library Mode:**
```python
from jaclang.lib import visit, refs, Path

visit(self, refs(Path(here).edge_out().visit()))
visit(
    self, refs(Path(here).edge_out(edge=lambda i: isinstance(i, Family)).edge().visit())
)
```

- `Path()` creates a traversal path from a node
- `edge_out()` specifies outgoing edges
- `edge()` filters to edges only (not nodes)
- `visit()` marks the path for walker to follow
- `refs()` converts path to node references

---

## **Common Patterns**

### **Pattern 1: Simple Graph Traversal**

```python
from jaclang.lib import Node, Walker, spawn, visit, refs, Path, root, connect, on_entry


class Item(Node):
    value: int = 0


class Traverser(Walker):
    @on_entry
    def process(self, here: Item) -> None:
        print(f"Processing item: {here.value}")
        visit(self, refs(Path(here).edge_out().visit()))


# Build graph
items = [Item(value=i) for i in range(5)]
for i in range(len(items) - 1):
    connect(left=items[i], right=items[i + 1])
connect(left=root(), right=items[0])

# Traverse
spawn(Traverser(), root())
```

### **Pattern 2: Filtered Edge Traversal**

```python
from jaclang.lib import Node, Edge, Walker, spawn, visit, refs, Path, on_entry


class Person(Node):
    name: str


class Friend(Edge):
    pass


class Colleague(Edge):
    pass


class FriendFinder(Walker):
    @on_entry
    def find_friends(self, here: Person) -> None:
        # Only traverse Friend edges
        visit(
            self,
            refs(Path(here).edge_out(edge=lambda e: isinstance(e, Friend)).visit()),
        )
```

### **Pattern 3: Bidirectional Traversal**

```python
from jaclang.lib import Path, visit, refs

# Visit incoming edges
visit(self, refs(Path(here).edge_in().visit()))

# Visit both incoming and outgoing
visit(self, refs(Path(here).edge_any().visit()))
```

### **Pattern 4: Node Type Filtering**

```python
# Visit only Person nodes
visit(self, refs(Path(here).edge_out(node=lambda n: isinstance(n, Person)).visit()))

# Visit only edges, not nodes
visit(self, refs(Path(here).edge_out().edge().visit()))
```

### **Pattern 5: Filtering Archetype Lists**

```python
from jaclang.lib import filter_on, Node

class Task(Node):
    priority: int
    completed: bool

# Get all high priority incomplete tasks
tasks = [Task(priority=i, completed=i % 2 == 0) for i in range(10)]
high_priority = filter_on(tasks, lambda t: t.priority > 5 and not t.completed)
```

### **Pattern 6: Batch Attribute Assignment**

```python
from jaclang.lib import assign_all, Node

class Item(Node):
    status: str = ""
    version: int = 0

items = [Item() for _ in range(5)]
# Assign status and version to all items at once
assign_all(items, (("status", "version"), ("active", 2)))
```

### **Pattern 7: Working with Multiple Roots**

```python
from jaclang.lib import root, get_all_root, allow_root, elevate_root

# Get current root
current = root()

# Get all roots in the system
all_roots = get_all_root()

# Grant access from one root to another
allow_root(my_node, all_roots[0].__jac__.id, "READ")

# Elevate to system root for admin operations
elevate_root()
```

### **Pattern 8: Dynamic Archetype Creation**

```python
from jaclang.lib import create_archetype_from_source, get_archetype

# Create archetypes from Jac source code at runtime
source = """
node DataPoint {
    has x: float;
    has y: float;
}
"""

module = create_archetype_from_source(source, module_name="dynamic_nodes")
DataPoint = get_archetype("dynamic_nodes", "DataPoint")
point = DataPoint(x=1.0, y=2.0)
```

### **Pattern 9: Persistence and Graph Management**

```python
from jaclang.lib import save, object_ref, get_object, commit, reset_graph

# Save a node to make it persistent
person = Person(name="Alice")
save(person)

# Get its ID for later retrieval
person_id = object_ref(person)

# Retrieve it later
retrieved = get_object(person_id)

# Commit all changes to datasource
commit()

# Clear entire graph (careful!)
deleted_count = reset_graph()
```

### **Pattern 10: Threading for Parallel Operations**

```python
from jaclang.lib import thread_run, thread_wait

def expensive_computation(data):
    # Some heavy processing
    return sum(data)

# Run in background thread
future = thread_run(expensive_computation, range(1000000))

# Do other work...

# Wait for result when needed
result = thread_wait(future)
```

---

## **Advanced Features**

### **Semantic Strings (AI Integration)**

```python
from jaclang.lib import sem, by


# Add semantic metadata to classes
@sem(
    "Returns the weather for a given city.",
    {"city": "Name of the city to get weather for"},
)
class Weather(Node):
    city: str
    temp: float


# Use LLM-powered functions (requires byllm package)
@by(model)
def analyze_sentiment(text: str) -> str:
    """Analyze the sentiment of the given text."""
    pass  # Implementation generated by LLM
```

### **Data Persistence & Object Management**

```python
from jaclang.lib import save, object_ref, get_object, commit, destroy

# Save a node to database
person = Person(name="Alice")
save(person)

# Get unique ID (hex string)
node_id = object_ref(person)

# Retrieve by ID later
retrieved_person = get_object(node_id)

# Commit changes to datasource
commit(person)

# Delete archetype from memory
destroy(person)
```

### **Fine-Grained Access Control**

```python
from jaclang.lib import (
    perm_grant, perm_revoke, allow_root, disallow_root,
    check_read_access, check_write_access, check_connect_access, elevate_root
)

# Grant public read access to archetype
perm_grant(node, "READ")

# Revoke public access
perm_revoke(node)

# Allow specific root to access this node
allow_root(node, root_id, "WRITE")

# Disallow specific root access
disallow_root(node, root_id, "READ")

# Check permissions before operations
if check_write_access(node.__jac__):
    node.value = 42

# Elevate to system root for admin operations
elevate_root()
```

### **Dynamic Module Loading**

```python
from jaclang.lib import (
    jac_import, create_archetype_from_source, get_archetype,
    spawn_node, spawn_walker, update_walker
)

# Import Jac module dynamically
jac_import("my_module", "./path/to/modules")

# Create archetypes from source code at runtime
source_code = """
node Task {
    has description: str;
    has priority: int = 0;
}
"""
module = create_archetype_from_source(source_code, "dynamic_tasks")

# Get and use the dynamically created archetype
Task = get_archetype("dynamic_tasks", "Task")
task = Task(description="Complete documentation", priority=1)

# Spawn node by name string
node = spawn_node("Task", {"description": "Test", "priority": 5}, "dynamic_tasks")

# Spawn walker by name string
walker = spawn_walker("TaskProcessor", {}, "__main__")

# Hot-reload walker from module
update_walker("my_module", {"TaskProcessor": None})
```

### **Graph Introspection**

```python
from jaclang.lib import (
    list_modules, list_nodes, list_walkers, list_edges,
    get_edges, edges_to_nodes, get_edges_with_node
)

# List all loaded modules
modules = list_modules()

# List archetypes in a module
nodes = list_nodes("my_module")
walkers = list_walkers("my_module")
edges = list_edges("my_module")

# Get edges connected to nodes
from jaclang.lib import ObjectSpatialPath, EdgeDir
path = ObjectSpatialPath([node], [])
connected_edges = get_edges([node], path.destinations[0])

# Get both edges and connected nodes
edges_and_nodes = get_edges_with_node([node], path.destinations[0])
```

---

## **Complete Library Interface Reference**

### **Type Aliases & Constants**

| Name | Type | Description |
|------|------|-------------|
| `TYPE_CHECKING` | bool | Python typing constant for type checking blocks |
| `EdgeDir` | Enum | Edge direction enum (IN, OUT, ANY) |
| `DSFunc` | Type | Data spatial function type alias |

### **Base Classes**

| Class | Description | Usage |
|-------|-------------|-------|
| `Obj` | Base class for all archetypes | Generic archetype base |
| `Node` | Graph node archetype | `class MyNode(Node):` |
| `Edge` | Graph edge archetype | `class MyEdge(Edge):` |
| `Walker` | Graph traversal agent | `class MyWalker(Walker):` |
| `Root` | Root node type | Entry point for graphs |
| `GenericEdge` | Generic edge when no type specified | Default edge type |
| `Path` | Object-spatial path builder | `Path(node).edge_out()` |

### **Decorators**

| Decorator | Description | Usage |
|-----------|-------------|-------|
| `@on_entry` | Entry ability decorator | Executes when walker enters node/edge |
| `@on_exit` | Exit ability decorator | Executes when walker exits node/edge |
| `@sem(doc, fields)` | Semantic string decorator | AI/LLM integration metadata |

### **Graph Construction**

| Function | Description | Parameters |
|----------|-------------|------------|
| `connect(left, right, edge, undir, conn_assign, edges_only)` | Connect nodes with edge | `left`: source node(s)<br>`right`: target node(s)<br>`edge`: edge class (optional)<br>`undir`: undirected flag<br>`conn_assign`: attribute assignments<br>`edges_only`: return edges instead of nodes |
| `disconnect(left, right, dir, filter)` | Remove edges between nodes | `left`: source node(s)<br>`right`: target node(s)<br>`dir`: edge direction<br>`filter`: edge filter function |
| `build_edge(is_undirected, conn_type, conn_assign)` | Create edge builder function | `is_undirected`: bidirectional flag<br>`conn_type`: edge class<br>`conn_assign`: initial attributes |
| `assign_all(target, attr_val)` | Assign attributes to list of objects | `target`: list of objects<br>`attr_val`: tuple of (attrs, values) |

### **Graph Traversal & Walker Operations**

| Function | Description | Parameters |
|----------|-------------|------------|
| `spawn(walker, node)` | Start walker at node | `walker`: Walker instance<br>`node`: Starting node |
| `spawn_call(walker, node)` | Internal spawn execution (sync) | `walker`: Walker anchor<br>`node`: Node/edge anchor |
| `async_spawn_call(walker, node)` | Internal spawn execution (async) | Same as spawn_call (async version) |
| `visit(walker, nodes)` | Visit specified nodes | `walker`: Walker instance<br>`nodes`: Node/edge references |
| `disengage(walker)` | Stop walker traversal | `walker`: Walker to stop |
| `refs(path)` | Convert path to node/edge references | `path`: ObjectSpatialPath |
| `arefs(path)` | Async path references (placeholder) | `path`: ObjectSpatialPath |
| `filter_on(items, func)` | Filter archetype list by predicate | `items`: list of archetypes<br>`func`: filter function |

### **Path Building (Methods on Path class)**

| Method | Description | Returns |
|--------|-------------|---------|
| `Path(node)` | Create path from node | ObjectSpatialPath |
| `.edge_out(edge, node)` | Filter outgoing edges | Self (chainable) |
| `.edge_in(edge, node)` | Filter incoming edges | Self (chainable) |
| `.edge_any(edge, node)` | Filter any direction | Self (chainable) |
| `.edge()` | Edges only (no nodes) | Self (chainable) |
| `.visit()` | Mark for visit traversal | Self (chainable) |

### **Node & Edge Operations**

| Function | Description | Parameters |
|----------|-------------|------------|
| `get_edges(origin, destination)` | Get edges connected to nodes | `origin`: list of nodes<br>`destination`: ObjectSpatialDestination |
| `get_edges_with_node(origin, destination, from_visit)` | Get edges and connected nodes | `origin`: list of nodes<br>`destination`: destination spec<br>`from_visit`: include nodes flag |
| `edges_to_nodes(origin, destination)` | Get nodes connected via edges | `origin`: list of nodes<br>`destination`: destination spec |
| `remove_edge(node, edge)` | Remove edge reference from node | `node`: NodeAnchor<br>`edge`: EdgeAnchor |
| `detach(edge)` | Detach edge from both nodes | `edge`: EdgeAnchor |

### **Data Access & Persistence**

| Function | Description | Returns |
|----------|-------------|---------|
| `root()` | Get current root node | Root node instance |
| `get_all_root()` | Get all root nodes | List of roots |
| `get_object(id)` | Get archetype by ID string | Archetype or None |
| `object_ref(obj)` | Get hex ID string of archetype | String |
| `save(obj)` | Persist archetype to database | None |
| `destroy(objs)` | Delete archetype(s) from memory | None |
| `commit(anchor)` | Commit data to datasource | None |
| `reset_graph(root)` | Purge graph from memory | Count of deleted items |

### **Access Control & Permissions**

| Function | Description | Parameters |
|----------|-------------|------------|
| `perm_grant(archetype, level)` | Grant public access to archetype | `archetype`: Target archetype<br>`level`: AccessLevel (READ/CONNECT/WRITE) |
| `perm_revoke(archetype)` | Revoke public access | `archetype`: Target archetype |
| `allow_root(archetype, root_id, level)` | Allow specific root access | `archetype`: Target<br>`root_id`: Root UUID<br>`level`: Access level |
| `disallow_root(archetype, root_id, level)` | Disallow specific root access | Same as allow_root |
| `elevate_root()` | Elevate context to system root | No parameters (uses context) |
| `check_read_access(anchor)` | Check read permission | `anchor`: Target anchor |
| `check_write_access(anchor)` | Check write permission | `anchor`: Target anchor |
| `check_connect_access(anchor)` | Check connect permission | `anchor`: Target anchor |
| `check_access_level(anchor, no_custom)` | Get access level for anchor | `anchor`: Target<br>`no_custom`: skip custom check |

### **Module Management & Archetypes**

| Function | Description | Parameters |
|----------|-------------|------------|
| `jac_import(target, base_path, ...)` | Import Jac/Python module | `target`: Module name<br>`base_path`: Search path<br>`absorb`, `mdl_alias`, `override_name`, `items`, `reload_module`, `lng`: import options |
| `load_module(module_name, module, force)` | Load module into machine | `module_name`: Name<br>`module`: Module object<br>`force`: reload flag |
| `attach_program(program)` | Attach JacProgram to runtime | `program`: JacProgram instance |
| `list_modules()` | List all loaded modules | Returns list of names |
| `list_nodes(module_name)` | List nodes in module | `module_name`: Module to inspect |
| `list_walkers(module_name)` | List walkers in module | `module_name`: Module to inspect |
| `list_edges(module_name)` | List edges in module | `module_name`: Module to inspect |
| `get_archetype(module_name, archetype_name)` | Get archetype class from module | `module_name`: Module<br>`archetype_name`: Class name |
| `make_archetype(cls)` | Convert class to archetype | `cls`: Class to convert |
| `spawn_node(node_name, attributes, module_name)` | Create node instance by name | `node_name`: Node class name<br>`attributes`: Init dict<br>`module_name`: Source module |
| `spawn_walker(walker_name, attributes, module_name)` | Create walker instance by name | `walker_name`: Walker class<br>`attributes`: Init dict<br>`module_name`: Source module |
| `update_walker(module_name, items)` | Reload walker from module | `module_name`: Module<br>`items`: Items to update |
| `create_archetype_from_source(source_code, ...)` | Create archetype from Jac source | `source_code`: Jac code string<br>`module_name`, `base_path`, `cachable`, `keep_temporary_files`: options |

### **Testing & Debugging**

| Function | Description | Parameters |
|----------|-------------|------------|
| `jac_test(func)` | Mark function as test | `func`: Test function |
| `run_test(filepath, ...)` | Run test suite | `filepath`: Test file<br>`func_name`, `filter`, `xit`, `maxfail`, `directory`, `verbose`: test options |
| `report(expr, custom)` | Report value from walker | `expr`: Value to report<br>`custom`: custom report flag |
| `printgraph(node, depth, traverse, edge_type, bfs, edge_limit, node_limit, file, format)` | Generate graph visualization | `node`: Start node<br>`depth`: Max depth<br>`traverse`: traversal flag<br>`edge_type`: filter edges<br>`bfs`: breadth-first flag<br>`edge_limit`, `node_limit`: limits<br>`file`: output path<br>`format`: 'dot' or 'mermaid' |

### **LLM & AI Integration**

| Function | Description | Use Case |
|----------|-------------|----------|
| `by(model)` | Decorator for LLM-powered functions | `@by(model) def func(): ...` |
| `call_llm(model, mtir)` | Direct LLM invocation | Advanced LLM usage |
| `get_mtir(caller, args, call_params)` | Get method IR for LLM | LLM internal representation |
| `sem(semstr, inner_semstr)` | Semantic metadata decorator | `@sem("doc", {"field": "desc"})` |

### **Runtime & Threading**

| Function | Description | Parameters |
|----------|-------------|------------|
| `setup()` | Initialize class references | No parameters |
| `get_context()` | Get current execution context | Returns ExecutionContext |
| `field(factory, init)` | Define dataclass field | `factory`: Default factory<br>`init`: Include in init |
| `impl_patch_filename(file_loc)` | Patch function file location | `file_loc`: File path for stack traces |
| `thread_run(func, *args)` | Run function in thread | `func`: Function<br>`args`: Arguments |
| `thread_wait(future)` | Wait for thread completion | `future`: Future object |
| `create_cmd()` | Create CLI commands | No parameters (placeholder) |

---

## **Best Practices**

### **1. Type Hints**

Always use type hints for better IDE support:

```python
from typing import Optional


class Person(Node):
    name: str
    age: Optional[int] = None
```

### **2. Walker State**

Keep walker state minimal and immutable when possible:

```python
class Counter(Walker):
    count: int = 0  # Simple state

    @on_entry
    def increment(self, here: Node) -> None:
        self.count += 1
```

### **3. Path Filtering**

Use lambda functions for flexible filtering:

```python
# Filter by edge type
visit(
    self,
    refs(Path(here).edge_out(edge=lambda e: isinstance(e, (Friend, Family))).visit()),
)

# Filter by node attribute
visit(
    self,
    refs(Path(here).edge_out(node=lambda n: hasattr(n, "active") and n.active).visit()),
)
```

### **4. Clean Imports**

Import only what you need:

```python
# Good
from jaclang.lib import Node, Walker, spawn, visit, on_entry

# Avoid
from jaclang.lib import *
```

---

## **Migration Guide**

### **From Jac to Library Mode**

| Jac Syntax | Library Mode Python |
|------------|---------------------|
| `node Person { has name: str; }` | `class Person(Node):`<br>&nbsp;&nbsp;&nbsp;&nbsp;`name: str` |
| `edge Friend {}` | `class Friend(Edge):`<br>&nbsp;&nbsp;&nbsp;&nbsp;`pass` |
| `walker W { has x: int; }` | `class W(Walker):`<br>&nbsp;&nbsp;&nbsp;&nbsp;`x: int` |
| `root ++> node` | `connect(root(), node)` |
| `a +>: Edge :+> b` | `connect(a, b, Edge)` |
| `W() spawn root` | `spawn(W(), root())` |
| `visit [-->]` | `visit(self, refs(Path(here).edge_out().visit()))` |
| `visit [<--]` | `visit(self, refs(Path(here).edge_in().visit()))` |
| `visit [--]` | `visit(self, refs(Path(here).edge_any().visit()))` |
| `can f with T entry {}` | `@on_entry`<br>`def f(self, here: T): ...` |
| `disengage;` | `disengage(self)` |

---

## **Summary**

Library mode demonstrates that **Jac is Python**â€”just with powerful abstractions for object-spatial programming. You get:

âœ… **100% Feature Parity**: Everything Jac can do, library mode can do
âœ… **Clean Python**: No magic, just classes, decorators, and functions
âœ… **Full IDE Support**: Type hints, autocomplete, and debugging work perfectly
âœ… **Easy Integration**: Drop into any Python project without friction
âœ… **Readable Output**: Generated code is maintainable and understandable

Whether you write `.jac` files or use library mode directly, you're writing Python with superpowers for graph-based, AI-native applications.




================================================================================
FILE: docs/learn/research.md
================================================================================


<h2 style="color: orange; font-weight: bold; text-align: center;">In Research (Coming Later)</h2>

## Object-Spatial Programming Makes Pytorch/Triton Look Slow

## Object-Spatial Programming Make PIM General Purpose

## Object-Spatial Programming Makes Database Schema's A Dynamic Optimization IR



================================================================================
FILE: docs/learn/superset_python.md
================================================================================


## **Jac's Native Superset of Python**

At its core, Jac is a natural evolution of Pythonâ€”not a replacement, but an enhancement. For Python developers, Jac offers a familiar foundation with powerful new features for modern software architecture, all while integrating seamlessly with the existing Python ecosystem.

### **How it Works: Transpilation to Native Python**

Unlike languages that require their own runtime environments, virtual machines, or interpreters, Jac programs execute on the standard Python runtime. The Jac compiler **transpiles** your Jac code into pure, efficient Python code through a multi-stage compilation pipeline that generates optimized Python bytecode. This means:

*   **100% Python Runtime:** Your Jac programs execute on the standard Python runtime, giving you access to Python's mature garbage collector, memory management, and threading model.
*   **Full Ecosystem Access:** Every package on PyPI, every internal library, and every Python tool you already use works out-of-the-box with Jac.
*   **Readable Output:** The transpiled Python is clean, maintainable code that you can inspect, debug, and understand.

Essentially, Jac is to Python what TypeScript is to JavaScript: a powerful superset that compiles down to the language you know and love.

**Example: From Jac to Python**

A simple Jac module with functions, objects, and an entrypoint...

```jac
"""Functions in Jac."""

def factorial(n: int) -> int {
    if n == 0 { return 1; }
    else { return n * factorial(n-1); }
}

obj Person {
    has name: str;
    has age: int;

    def greet() -> None {
        print(f"Hello, my name is {self.name} and I'm {self.age} years old.");
    }
}

with entry {
    person = Person("John", 42);
    person.greet();
    print(f"5! = {factorial(5)}");
}
```

...is transpiled into clean, readable Python code:

```python
"""Functions in Jac."""
from __future__ import annotations
from jaclang.lib import Obj

def factorial(n: int) -> int:
    if n == 0:
        return 1
    else:
        return n * factorial(n - 1)

class Person(Obj):
    name: str
    age: int

    def greet(self) -> None:
        print(f"Hello, my name is {self.name} and I'm {self.age} years old.")

person = Person('John', 42)
person.greet()
print(f'5! = {factorial(5)}')
```

Notice how Jac's object-oriented features compile to standard Python classes inheriting from `Obj` (Jac's base object archetype), with clean imports from `jaclang.lib`.

---

### **Seamless Interoperability: Import Jac Files Like Python Modules**

One of Jac's most powerful features is how effortlessly it integrates with Python. Once you add a single lineâ€”`import jaclang`â€”to your Python code, you can import `.jac` files exactly as you would any Python module. No build steps, no compilation commands, no configuration files.

**What This Means for You:**

*   **Mix and Match Files Freely:** Write some modules in `.jac` and others in `.py`, then import them interchangeably. Your Python files can import Jac modules, and your Jac files can import Python modulesâ€”it just works.

*   **Zero Friction Adoption:** Add Jac to your existing Python project without restructuring your codebase. Keep your Python files as-is, and gradually introduce Jac modules where they add value.

*   **Natural Developer Experience:** Use the same `import` statements you already know. No special syntax, no extra toolsâ€”just natural Python imports that happen to work with `.jac` files too.

**Example: Importing Across Languages**

Say you have a Jac module with graph utilities:

```jac
# graph_tools.jac
node Task {
    has name: str;
    has priority: int;
}
```

Import it in Python just like any other module:

```python
# main.py
import jaclang  # Enable Jac imports (one-time setup)
from graph_tools import Task  # Import from .jac file

# Use Jac classes in Python naturally
my_task = Task(name="Deploy", priority=1)
```

It works in reverse tooâ€”your Jac files can import Python libraries:

```jac
# analyzer.jac
import pandas as pd;
import numpy as np;

# Use Python libraries directly in Jac code
```

**How It Works:** Jac leverages Python's [PEP 302](https://peps.python.org/pep-0302/) import hook system to extend Python's native import mechanism. When you `import jaclang`, it registers a custom importer that teaches Python how to find and load `.jac` files. From that point forward, whenever Python encounters an import statement, it automatically checks for `.jac` files alongside `.py` files, compiles them transparently, and loads them into your programâ€”all behind the scenes. This means Jac modules become first-class citizens in your Python environment, indistinguishable from native Python modules.

---

### **Five Adoption Patterns: Choose Your Integration Level**

Jac offers flexible adoption strategies to fit your team's needs, from pure Python with Jac enhancements to pure Jac applications. Here are the five primary patterns:

#### **Pattern Comparison Table**

| Pattern | Use Case | Jac Content | Python Content | Key Benefits | Example Scenario |
|---------|----------|-------------|----------------|--------------|------------------|
| **1. Pure Jac** | New projects, microservices | 100% | 0% | Full Jac language features, modern syntax | Building a new graph-based application with only `.jac` files |
| **2. Jac + Inline Python** | Inline Python in Jac files | Mixed (::py:: blocks) | Embedded inline | Gradual migration, use Python syntax when needed | `.jac` files with embedded Python for legacy logic or complex imports |
| **3. Mostly Jac** | Import Python modules into Jac | 80-95% .jac | 5-20% .py | Jac architecture with existing Python utilities | Project with `.jac` files importing your existing `.py` utility modules |
| **4. Mostly Python** | Import Jac modules into Python | 5-20% .jac | 80-95% .py | Python codebase with select Jac features | Python project with `.py` files importing specialized `.jac` modules for graphs/AI |
| **5. Pure Python + Jac Library** | Conservative adoption | 0% | 100% | No new syntax, just Jac runtime capabilities | Pure `.py` project using Jac runtime via imports and decorators |

```mermaid
graph LR
    A[Pure Jac<br/>100% .jac files] --> B[Jac + Inline Python<br/>::py:: blocks]
    B --> C[Mostly Jac<br/>import .py files]
    C --> D[Mostly Python<br/>import .jac files]
    D --> E[Pure Python<br/>+ Jac Library]

    style A fill:#2d5f3f,stroke:#4CAF50,stroke-width:2px,color:#fff
    style B fill:#3d4f2d,stroke:#8BC34A,stroke-width:2px,color:#fff
    style C fill:#5f4d1a,stroke:#FFC107,stroke-width:2px,color:#fff
    style D fill:#5f3d1a,stroke:#FF9800,stroke-width:2px,color:#fff
    style E fill:#5f2d2d,stroke:#FF5722,stroke-width:2px,color:#fff
```

---

### **Pattern Details and Examples**

**Example Project:** A simple task manager that stores tasks and generates AI-powered task descriptions.

**Core Features:**
- Task storage with graph-based relationships
- Task validation (title length check)
- AI-generated task descriptions

Let's see how to build this across all 5 patterns.

---

#### **Pattern 1: Pure Jac**

Everything in `.jac` filesâ€”no Python files needed.

**When to use:** New projects where you want full Jac features

**Directory Structure:**
```
project/
â”œâ”€â”€ main.jac
â”œâ”€â”€ models.jac
â””â”€â”€ utils.jac
```

=== "main.jac"
    ```jac
    """Main application."""
    import models, utils;

    walker TaskCreator {
        has title: str;

        can create with `root entry {
            if utils.validate_title(self.title) {
                task = models.Task(title=self.title);
                here ++> task;
                desc = utils.generate_desc(self.title);
                print(f"âœ“ Created: {task.title}");
                print(f"  AI: {desc}");
            } else {
                print("âœ— Title too short!");
            }
        }
    }

    with entry {
        root spawn TaskCreator(title="Build API");
    }
    ```

=== "models.jac"
    ```jac
    """Task node definition."""

    node Task {
        has title: str;
        has done: bool = False;
    }
    ```

=== "utils.jac"
    ```jac
    """Validation and AI utilities."""

    def validate_title(title: str) -> bool {
        return len(title) > 3;
    }

    def generate_desc(title: str) -> str {
        return f"Task description for: {title}";
    }
    ```

---

#### **Pattern 2: Jac + Inline Python**

Embed Python code directly in `.jac` files using `::py::` blocksâ€”useful for migration or when you need Python-specific libraries.

**When to use:** Migrating Python code incrementally, keeping legacy utilities as-is

**Directory Structure:**
```
project/
â”œâ”€â”€ main.jac
â””â”€â”€ models.jac
```

=== "main.jac"
    ```jac
    """Application with inline Python validation."""
    import models;

    def generate_desc(title: str) -> str {
        return f"Task description for: {title}";
    }

    ::py::
    # Legacy Python validation - kept as-is
    def validate_title(title):
        """Complex validation logic from old codebase."""
        return len(title) > 3 and title.strip() != ""

    def get_sample_task():
        """Helper from legacy code."""
        return {"title": "Build API"}
    ::py::

    walker TaskCreator {
        can create with `root entry {
            # Use inline Python functions
            task_data = get_sample_task();

            if validate_title(task_data["title"]) {
                task = models.Task(title=task_data["title"]);
                here ++> task;
                desc = generate_desc(task.title);
                print(f"âœ“ Created: {task.title}");
                print(f"  AI: {desc}");
            } else {
                print("âœ— Title invalid!");
            }
        }
    }

    with entry {
        root spawn TaskCreator();
    }
    ```

=== "models.jac"
    ```jac
    """Task node definition."""

    node Task {
        has title: str;
        has done: bool = False;
    }
    ```

Keep tested Python code while adding Jac featuresâ€”best for incremental migration.

---

#### **Pattern 3: Mostly Jac**

Write your app in Jac, import Python utilities from separate `.py` files.

**When to use:** Jac-first development with existing Python utilities or shared modules

**Directory Structure:**
```
project/
â”œâ”€â”€ main.jac
â”œâ”€â”€ models.jac
â””â”€â”€ validators.py
```

=== "main.jac"
    ```jac
    """Main application - imports Python module."""
    import models;
    import validators;

    def generate_desc(title: str) -> str {
        return f"Task description for: {title}";
    }

    walker TaskCreator {
        has title: str;

        can create with `root entry {
            # Call Python module functions
            if validators.validate_title(self.title) {
                task = models.Task(title=self.title);
                here ++> task;
                desc = generate_desc(task.title);
                print(f"âœ“ Created: {task.title}");
                print(f"  AI: {desc}");
            } else {
                print("âœ— Title too short!");
            }
        }
    }

    with entry {
        root spawn TaskCreator(title="Build API");
    }
    ```

=== "models.jac"
    ```jac
    """Task node definition."""

    node Task {
        has title: str;
        has done: bool = False;
    }
    ```

=== "validators.py"
    ```python
    """Python validation utilities - shared with other projects."""

    def validate_title(title: str) -> bool:
        """Validator used across multiple projects."""
        return len(title) > 3

    def get_sample_title():
        """Helper to load sample data."""
        return "Build API"
    ```

Jac seamlessly imports Python modulesâ€”no configuration needed.

---

#### **Pattern 4: Mostly Python**

Python-first application that imports `.jac` modules for graph and AI features.

**When to use:** Existing Python projects adding Jac's graph/AI capabilities

**Directory Structure:**
```
project/
â”œâ”€â”€ main.py
â”œâ”€â”€ validators.py
â””â”€â”€ task_graph.jac
```

=== "main.py"
    ```python
    """Python application importing Jac modules."""
    import jaclang  # Enable Jac imports

    from validators import validate_title
    from task_graph import Task, TaskCreator, generate_desc
    from jaclang.lib import spawn, root

    def create_task(title: str):
        """Python function using Jac features."""
        if not validate_title(title):
            print("âœ— Title too short!")
            return

        # Use Jac walker
        creator = TaskCreator(title=title)
        spawn(creator, root())

        # Use Jac's AI
        desc = generate_desc(title)
        print(f"  AI: {desc}")

    if __name__ == "__main__":
        create_task("Build API")
    ```

=== "validators.py"
    ```python
    """Python validation utilities."""

    def validate_title(title: str) -> bool:
        """Title validator."""
        return len(title) > 3
    ```

=== "task_graph.jac"
    ```jac
    """Jac module with graph and AI features."""

    node Task {
        has title: str;
        has done: bool = False;
    }

    walker TaskCreator {
        has title: str;

        can create with `root entry {
            task = Task(title=self.title);
            here ++> task;
            print(f"âœ“ Created: {task.title}");
        }
    }

    def generate_desc(title: str) -> str {
        return f"Task description for: {title}";
    }
    ```

Python stays familiar, but you get Jac's graph and AI features where needed.

---

#### **Pattern 5: Pure Python + Jac Library**

Pure Python using Jac's runtime as a libraryâ€”no `.jac` files.

**When to use:** Conservative adoption, teams preferring Python syntax, existing projects

**Directory Structure:**
```
project/
â”œâ”€â”€ main.py
â””â”€â”€ validators.py
```

=== "main.py"
    ```python
    """Pure Python using Jac runtime."""
    from jaclang.lib import Node, Walker, on_entry, connect, spawn, root
    from validators import validate_title

    # Define Task node using Jac base class
    class Task(Node):
        title: str
        done: bool

        def __init__(self, title: str):
            super().__init__()
            self.title = title
            self.done = False

    # Define walker using Jac decorators
    class TaskCreator(Walker):
        def __init__(self, title: str):
            super().__init__()
            self.title = title

        @on_entry
        def create(self, here) -> None:
            """Entry point - creates task."""
            if validate_title(self.title):
                task = Task(title=self.title)
                connect(here, task)
                print(f"âœ“ Created: {task.title}")
                # Note: AI features require .jac syntax
            else:
                print("âœ— Title too short!")

    if __name__ == "__main__":
        creator = TaskCreator(title="Build API")
        spawn(creator, root())
    ```

=== "validators.py"
    ```python
    """Python validation utilities."""

    def validate_title(title: str) -> bool:
        """Title validator."""
        return len(title) > 3
    ```

Pure Python with graph capabilitiesâ€”no new syntax, but you get Jac's data-spatial model.

---

### **Key Takeaways**

Jac's relationship with Python isn't about choosing one over the otherâ€”it's about providing a powerful "and". You get:

- **Incremental Adoption:** Start with Pattern 5 (pure Python + Jac library) and gradually move toward Pattern 1 (pure Jac) at your own pace
- **Full Ecosystem Access:** Continue using your favorite Python libraries, frameworks, and tools without compatibility issues
- **Flexible Integration:** Choose from five adoption patterns based on your team's comfort level and project requirements
- **Zero Lock-in:** Transpiled Python code is readable and maintainable, giving you an exit strategy if needed
- **Seamless Imports:** PEP 302 import hooks enable transparent `.jac` and `.py` interoperability

| Adoption Pattern | Learning Curve | Migration Effort | Feature Access | Risk Level |
|------------------|---------------|------------------|----------------|------------|
| Pattern 1: Pure Jac | Higher | Higher | 100% Jac features | Low |
| Pattern 2: Jac + Inline Python | Medium | Low | 100% Jac features | Low |
| Pattern 3: Mostly Jac | Medium-High | Medium | 100% Jac features | Low |
| Pattern 4: Mostly Python | Low-Medium | Low | Select Jac features | Low |
| Pattern 5: Pure Python + Library | Low | Very Low | Core runtime only | Very Low |

Whether you're building a new application from scratch or enhancing an existing Python codebase, Jac provides the tools and flexibility to write more structured, maintainable, and scalable codeâ€”without abandoning the Python ecosystem you know and trust.




================================================================================
FILE: docs/learn/tools/cli.md
================================================================================


# **Jac Language Command Line Interface (CLI)**

Jac Language CLI is with a variety of commands to facilitate users. Additionally, Jac language offers users the ability to define custom CLI commands through plugins. This document aims to provide an overview of each command along with clear usage instructions. Jac CLI can ba accessed using bash commands as well as by bashing ```jac``` which will start the Jac CLI.


## `jac tool`
Jac Language offers language tools to perform various tasks efficiently. The `tool` command is utilized to execute specific language tools along with any optional arguments as needed. This command enables users to interact with language-specific command line tools designed to manage the language effectively.
```bash
$ jac tool <jac_tool> <args>
```
Parameters to execute the tool command:
- `jac_tool`: The name of the language tool to execute.
    - `ir`, `pass_template`, `py_uni_nodes`,  `md_doc`, `automate_ref` are the jac_tools used to handle (Usage instruction is below)
- `args`: Optional arguments for the specific language tool.


> 1.1. jac_tool `ir`:
  `ir` tool generates an Abstract Syntax Tree (AST) and SymbolTable tree for a .jac file, or a Python AST for a .py file. `ir` tool is used with `tool` cli command.
```bash
jac tool ir <output_type> <file_path>
```

*Parameters for `jac tool ir`*

- `output_type`: Choose one of the following options:
- `sym`: Provides the symbol table of the specified .jac file.
- `sym.`: Generates a dot graph representation of the symbol table for the specified .jac file.
- `ast`: Displays the Abstract Syntax Tree (AST) of the specified .jac file.
- `ast.`: Generates a dot graph representation of the AST for the specified .jac file.
- `cfg.`: Genarates a dot graph of the control flow graph(s) for the specified .jac file.
- `pyast`: Generates the Python AST for a .py file or the relevant Python AST for the generated Python code from a .jac file.
- `py`: Displays the relevant generated Python code for the respective Jac code in a .jac file.
- `file_path`: Path to the .jac or .py file.



- To get the symbol table tree of a Jac file:
```bash
jac tool ir sym <file_path>
```
- To generate a dot graph of the symbol table tree for a Jac file:
```bash
jac tool ir sym. <file_path>
```
- To view the AST tree of a Jac file:
```bash
jac tool ir ast <file_path>
```


> jac_tool `pass_template`:
  `pass_template` tool generates pass template for jac.
```bash
jac tool pass_template
```


> jac_tool `py_uni_nodes`:
  `py_uni_nodes` tool lists python ast nodes.
```bash
jac tool py_uni_nodes
```


> jac_tool `md_doc`:
  `md_doc` tool generate mermaid markdown doc.
```bash
jac tool md_doc
```


> jac_tool `automate_ref`:
  `automate_ref` tool automates the reference guide generation.
```bash
jac tool automate_ref
```



## `jac run`

The `run` command is utilized to run the specified .jac or .jir file.
```bash
jac run <file_path> [main] [cache]
```
Parameters to execute the run command:
- `file_path`: Path of .jac or .jir file to run.
- `main`: (Optional, bool) A flag indicating whether the module being executed is the main module. Defaults to True
- `cache` :The cache flag to cache
- To run file_path Jac file:
```bash
jac run <file_path>
```



## `jac clean`
The `clean` command is utilized to remove the __jac_gen__ , __pycache__ folders from the current directory recursively.
```bash
jac clean
```
No Parameters needed to execute the clean command



## `jac format`
The `format` command is utilized to run the specified .jac file or format all .jac files in a given directory.
```bash
jac format <file_path/directory_path> [outfile] [debug]
```
  Parameters to execute the format command:
  - `file_path/directory_path`: The path to the .jac file or directory containing .jac files.
  - `outfile`: (Optional) The output file path (only applies when formatting a single file).
  - `debug` :(Optional) If True, print debug information.  Defaults to False

  >To format all .jac files from walking through current located directory:
  >```bash
  >$ jac format .
  >```



## `jac check`
The `check` command is utilized to run type checker for a specified .jac file.
```bash
jac check <file_path>
```
Parameters to execute the check command:
- `file_path`: Path of .jac file to run type checker.



## `jac build`

The `build` command is utilized to build the specified .jac file.
```bash
jac build <file_path>
```
  Parameters to execute the build command:
  - `file_path`: Path of .jac file to build.



## `jac enter`

The `enter` command is utilized to run the specified entrypoint function in the given .jac file.

```bash
jac enter <file_path> <entrypoint> <args>
```
Parameters to execute the enter command:
- `file_path`: The path to the .jac file.
- `entrypoint`: The name of the entrypoint function.
- `args`: Arguments to pass to the entrypoint function.

- To enter file_path Jac file
```bash
jac enter <file_path>
```



## `jac test`

The `test` command is utilized to run the test suite in the specified .jac file.
```bash
jac test <file_path>
```
Parameters to execute the test command:
- `file_path`: The path to the .jac file.




================================================================================
FILE: docs/learn/tools/streamlit.md
================================================================================


# Jac Streamlit Plugin

The Jac Streamlit plugin enables you to create interactive web applications using Streamlit with Jac code. This plugin seamlessly integrates Jac's powerful features with Streamlit's web app capabilities, allowing you to build data science applications, dashboards, and interactive tools.

## Installation

The Jac Streamlit plugin needs to be installed separately using pip:

```bash
pip install jac-streamlit
```

This will install the plugin and make the `jac streamlit` command available.

## Quick Start

To run a Jac file as a Streamlit application, use the `jac streamlit` command:

```bash
jac streamlit your_app.jac
```

This command will:
1. Compile your Jac code
2. Launch a Streamlit web server
3. Open your app in the default web browser

### Example Applications

We've included several example applications to help you get started:

#### Simple Calculator
A basic calculator demonstrating form handling and user interaction:

```jac
import streamlit as st;

def simple_calculator() {
    st.title("ðŸ§® Simple Calculator");
    st.write("A basic calculator built with Jac and Streamlit");

    # Create two columns for inputs
    columns = st.columns(2);
    col1 = columns[0];
    col2 = columns[1];

    with col1 {
        num1 = st.number_input("First number:", value=0.0);
    }

    with col2 {
        num2 = st.number_input("Second number:", value=0.0);
    }

    # Operation selection
    operation = st.selectbox(
        "Choose operation:",
        ["Add", "Subtract", "Multiply", "Divide"]
    );

    # Calculate result
    if st.button("Calculate") {
        if operation == "Add" {
            result = num1 + num2;
        } elif operation == "Subtract" {
            result = num1 - num2;
        } elif operation == "Multiply" {
            result = num1 * num2;
        } elif operation == "Divide" {
            if num2 != 0 {
                result = num1 / num2;
            } else {
                st.error("Cannot divide by zero!");
                return;
            }
        }

        st.success("Result: " + str(result));

        # Add to history
        if "history" not in st.session_state {
            st.session_state.history = [];
        }

        st.session_state.history.append(
            str(num1) + " " + operation.lower() + " " + str(num2) + " = " + str(result)
        );
    }

    # Show calculation history
    if "history" in st.session_state and st.session_state.history {
        st.subheader("ðŸ“ History");
        for calc in st.session_state.history {
            st.write("â€¢ " + calc);
        }

        if st.button("Clear History") {
            st.session_state.history = [];
            st.rerun();
        }
    }
}

with entry {
    simple_calculator();
}
```

Run this example with:
```bash
jac streamlit simple_calculator.jac
```

#### Todo App
A todo application showcasing session state management:

```jac
import streamlit as st;

def todo_app() {
    st.title("ðŸ“‹ Todo App");
    st.write("A simple todo application built with Jac and Streamlit");

    # Initialize session state
    if "todos" not in st.session_state {
        st.session_state.todos = [];
    }

    # Add new todo
    with st.form("add_todo") {
        new_todo = st.text_input("Add a new todo:");

        if st.form_submit_button("Add Todo") and new_todo {
            st.session_state.todos.append(new_todo);
            st.success("Todo added!");
        }
    }

    # Display todos
    if st.session_state.todos {
        st.subheader("ðŸ“ Your Todos");

        todos_to_remove = [];

        for todo in st.session_state.todos {
            columns = st.columns([4, 1]);

            with columns[0] {
                st.write("â€¢ " + todo);
            }

            with columns[1] {
                if st.button("Remove", key=todo) {
                    todos_to_remove.append(todo);
                }
            }
        }

        # Remove completed todos
        for todo in todos_to_remove {
            st.session_state.todos.remove(todo);
        }

        if todos_to_remove {
            st.rerun();
        }

        # Clear all button
        if st.button("Clear All") {
            st.session_state.todos = [];
            st.rerun();
        }
    } else {
        st.info("No todos yet! Add one above.");
    }

    # Show count
    if st.session_state.todos {
        st.write("Total todos: " + str(len(st.session_state.todos)));
    }
}

with entry {
    todo_app();
}
```

Run this example with:
```bash
jac streamlit todo_app.jac
```

## Features

### 1. Full Streamlit API Access

You can use all Streamlit components and features in your Jac applications:

```jac
import streamlit as st;
import pandas as pd;
import numpy as np;

with entry {
    st.title("Data Dashboard");

    # Create sample data
    data = pd.DataFrame({
        'x': np.random.randn(100),
        'y': np.random.randn(100)
    });

    # Display chart
    st.line_chart(data);

    # Add sidebar
    st.sidebar.header("Controls");
    chart_type = st.sidebar.selectbox("Chart Type", ["line", "bar", "area"]);

    if chart_type == "bar" {
        st.bar_chart(data);
    } elif chart_type == "area" {
        st.area_chart(data);
    }
}
```

### 2. Session State Management

Streamlit's session state works seamlessly with Jac:

```jac
import streamlit as st;

with entry {
    st.title("Counter App");

    # Initialize session state
    if "counter" not in st.session_state {
        st.session_state.counter = 0;
    }

    # Display current count
    st.write("Current count: " + str(st.session_state.counter));

    # Buttons to modify counter
    col1, col2, col3 = st.columns(3);

    with col1 {
        if st.button("Increment") {
            st.session_state.counter += 1;
        }
    }

    with col2 {
        if st.button("Decrement") {
            st.session_state.counter -= 1;
        }
    }

    with col3 {
        if st.button("Reset") {
            st.session_state.counter = 0;
        }
    }
}
```


## Advanced Usage

### Integration with Jac Cloud

You can build Streamlit frontends that interact with Jac Cloud APIs:

```jac
import streamlit as st;
import requests;

def make_api_call(token: str, endpoint: str, payload: dict) -> dict {
    response = requests.post(
        "http://localhost:8000/" + endpoint,
        json=payload,
        headers={"Authorization": "Bearer " + token}
    );
    return response.json() if response.status_code == 200 else {};
}

with entry {
    st.title("Jac Cloud Frontend");

    # Authentication
    if "token" not in st.session_state {
        st.session_state.token = None;
    }

    if not st.session_state.token {
        with st.form("login_form") {
            email = st.text_input("Email");
            password = st.text_input("Password", type="password");

            if st.form_submit_button("Login") {
                # Attempt login
                response = requests.post(
                    "http://localhost:8000/user/login",
                    json={"email": email, "password": password}
                );

                if response.status_code == 200 {
                    st.session_state.token = response.json()["token"];
                    st.rerun();
                } else {
                    st.error("Login failed!");
                }
            }
        }
    } else {
        st.success("Logged in successfully!");

        # Your app content here
        user_input = st.text_input("Enter your message:");

        if st.button("Send") and user_input {
            result = make_api_call(
                st.session_state.token,
                "walker/interact",
                {"message": user_input}
            );

            if result {
                st.write("Response:", result);
            }
        }
    }
}
```



## Next Steps

- Check out the [Jac Cloud documentation](../jac-cloud/introduction.md) for backend integration
- Try building a complete application using Jac + Streamlit + Jac Cloud


