Jac Language: Python superset for AI-powered applications. Installation: pip install jaclang. Python 3.12+ required. CLI: jac run file.jac, jac serve file.jac, jac --version. VS Code extension: jaclang-extension. Entry point: with entry { statements; }. Files: .jac interface, .impl.jac implementation, .test.jac tests. Syntax: Statements end semicolons ;. Blocks use braces { }. Comments: # single-line, #* multi-line *#. String formatting: f"text {variable}". Type annotations: mandatory variable: type = value;. Global variables: glob var_name: type = value; accessed with :g:var_name. Data types: Primitives: int str float bool any. Collections: list[T] dict[K,V] set[T] tuple[T1,T2]. Type unions: type1 | type2. Enums: enum Name { VALUE1, VALUE2 }. Control flow: If-elif-else: if condition { } elif condition { } else { }. Comparison: > < >= <= == != and or not. While: while condition { }. For: for item in collection { } or for i = start to condition by step { }. Pattern matching: match value { case type() if condition: code; case _: default; }. Exception handling: try { } except Type as e { }. Raise: raise ErrorType("message"). Functions: Definition: def name(param: type) -> return_type { body; }. Lambda: lambda param: type: expression. Callable type: callable or callable[[arg_types], return_type]. Decorators: @decorator_name. Async: async def name() { await operation; } run with asyncio.run(). Default parameters: def func(param: type = default) { }. Objects (OOP): Declaration: obj ClassName { has attr: type; def method() { } }. Automatic constructor: attributes defined with has become constructor params. Instantiation: instance = ClassName(attr=value). Methods: def method_name() { self.attribute; }. Implementation separation: impl ClassName.method_name { code; }. Inheritance: obj Child(Parent) { }. Postinit: def postinit { } runs after construction. Nodes (Graph Data): Declaration: node NodeName { has attr: type; }. Node abilities: can ability_name with entry|exit { }. Walker-specific: can ability with WalkerType entry|exit { }. Reference keywords: self (node itself), visitor (walker visiting). Connections: one2one one2many many2one many2many supported. Edges (Relationships): Generic edge: node1 ++> node2 forward, node1 <++> node2 bidirectional. Custom edge: edge EdgeName { has prop: type; }. Typed connection: node1 +>:EdgeName(prop=val):+> node2. Bidirectional typed: node1 <+:EdgeName(prop=val):+> node2. Delete edge: node1 del --> node2. Edge abilities: can ability with WalkerType entry|exit { }. Walkers (Mobile Computation): Declaration: walker WalkerName { has attr: type; }. Spawn: node spawn WalkerName() or root spawn WalkerName(). Visit patterns: visit [-->] outgoing, visit [<--] incoming, visit [<-->] both. Visit node: visit [node_name] specific. Filter: visit [-->(`?NodeType)] by type. Edge filter: visit [->:EdgeType:->] by edge type. Attribute filter: visit [->:Edge:prop>val:->]. Reference keywords: self (walker), here (current node), visitor (in node abilities). Control: disengage exit walker, skip skip current node. Report: report value; streams results to caller. Walker abilities: Entry ability: can ability_name with entry { } runs once at spawn. Exit ability: can ability_name with exit { } runs once at end. Node-specific: can ability with NodeType entry|exit { }. Execution order: location entry abilities → walker entry abilities → walker exit abilities → location exit abilities. Root entry: can ability with `root entry { }. Graph queries & filtering: Node reference: [node-->] get successors, [<--node] predecessors. Type filter: [node-->(`?TypeName)] filter by node type. Attribute filter: [node-->(`?Type)(?attr == val)] filter by properties. Edge filter: [node->:EdgeType:->] filter by edge type. Edge property filter: [node->:Edge:prop == val:->] filter edge attributes. Multi-hop: [node --> --> -->] traverse multiple levels. Combination: filters can be combined for complex queries. Persistence & Root: Root node: special per-user persistent anchor point root. Auto-persistence: nodes/edges connected to root persist automatically. Local vs cloud: same code runs locally or as API. Manual save: save(instance) queue for commit. Commit: commit() flush to database, commit(archetype) specific type. ByLLM (AI Integration): Install: pip install byllm. Import: import from byllm { Model, Image }. Model declaration: glob llm = Model(model_name="gpt-4o-mini"). AI function: def func_name(params) -> return_type by llm();. Docstrings enhance prompts automatically, function signature = prompt. Semantic strings: sem ClassName.attr = "description" enrich AI context. Model params: temperature max_tokens top_k top_p verbose. Image support: Image("path.jpg") for multimodal. Enum return types: force LLM to return specific enum values. Custom types: LLM output typed to custom classes automatically. Retry: max_tries=3 in Model config. Jac Cloud (Deployment): Serve: jac serve main.jac creates REST API at localhost:8000. Docs: automatic Swagger UI at /docs. Walker endpoints: /walker/{walker_name} (root), /walker/{walker_name}/{node_id} (node). Methods: __specs__ object configures HTTP methods auth query params. Specs config: static has methods: list = ["get","post"] HTTP methods. Auth: static has auth: bool = False disable authentication. Query params: static has as_query: list = ["param"] or "*" for all. Private: static has private: bool = True skip auto-endpoint. Path: static has path: str = "/custom" custom URL path. Entry type: static has entry_type: str = "ROOT" or "NODE" or "BOTH". Response: {"status": 200, "reports": [], "returns": []} standard format. Environment vars: DATABASE_HOST DISABLE_AUTO_ENDPOINT SHOW_ENDPOINT_RETURNS. Jac Cloud Advanced: Webhooks: static has webhook: dict for external integrations. Scheduler: static has schedule: dict for cron tasks. WebSocket: real-time bidirectional communication support. File upload: has file: UploadFile for handling file uploads. Permissions: role-based access control authentication decorators. Logging: structured logging with configurable levels. Deployment: Docker Kubernetes YAML templates provided. Archetypes (4 types): obj: standard OOP classes dataclass-like with auto-constructor. node: graph data locations can connect via edges persist when rooted. edge: first-class relationships between nodes have properties abilities. walker: mobile computation entities traverse graphs trigger abilities. Object-Spatial Programming (OSP): Paradigm shift: computation moves to data (not data to computation). Nodes: data locations with abilities triggered by walker visits. Edges: relationships as first-class objects with state behavior. Walkers: autonomous agents traversing executing on nodes/edges. Abilities: event-driven execution triggered by spatial context. Bidirectional polymorphism: both nodes and walkers define interaction. Operators: Connection: ++> forward, <++ backward, <++> bidirectional. Typed edge: +>:Type:+> or <+:Type:+> with properties inline. Edge reference: --> <-- <--> for queries (not connection). Delete: del removes edges. Spawn: spawn activates walker. Visit: visit [pattern] traverse graph. Imports & Modules: Python imports: import module; or import from module { item }. Jac imports: include :jac:file.jac; or from :jac:file.jac import item. Implementation: separate .impl.jac files auto-linked. Package structure: organize in folders models/ utils/ etc. Collections: Lists: [1, 2, 3] mutable ordered list[T]. Dicts: {"key": value} mutable key-value dict[K,V]. Sets: {1, 2, 3} mutable unique set[T]. Tuples: (1, 2) immutable ordered tuple[T1,T2]. List comprehension: [expr for item in iterable if condition]. Dict comprehension: {k: v for item in iterable}. Built-in functions: map filter sorted len sum range. Functional Programming: First-class functions: assign to variables pass as arguments. Higher-order: functions taking/returning functions. Map: map(func, iterable) apply function to each. Filter: filter(predicate, iterable) select matching items. Sorted: sorted(iterable, key=lambda) custom sorting. Lambda: lambda args: expr anonymous functions. Decorators: @decorator function wrappers. Composition: combine functions for pipelines. Type System: Strong typing: all variables require type annotations. Type inference: return types inferred from return statements. Generic types: list[T] dict[K,V] parameterized. Union types: T1 | T2 multiple possibilities. Optional: T | None nullable types. Any: any escape hatch for dynamic typing. Type aliases: type Alias = ComplexType. Callable: callable[[Args], Return] function types. Project Structure: main.jac: entry point with with entry. models/: domain objects nodes edges. utils/: helper functions constants. tests/: .test.jac test files. .impl.jac: implementation files separate from interface. Separation: interface declaration vs implementation details. Abilities Execution Order: Walker arrival at location: 1. Location entry abilities (node/edge responding to walker) 2. Walker entry abilities (walker processing location) 3. Visit statements executed (queue updates) 4. Walker exit abilities (walker preparing to leave) 5. Location exit abilities (location responding to departure) 6. Walker moves to next queued location. Auto edge-to-node: visiting edge auto-queues destination node. Queue exhaustion: walker deactivates when queue empty at node. Walker Destination Queue: Queue: ordered list of nodes/edges to visit FIFO. Dynamic modification: visit statements add to queue. Path expansion: visiting path collection expands to traversable sequence. Automatic transitions: edge → node automatic. Persistence: queue maintained throughout traversal. Empty queue: walker becomes inactive (if at node). Path Collections: Definition: ordered sequence of nodes/edges [p1, p2, ...]. Constraints: origin connectivity sequential connectivity path completeness. Construction: explicit [node1, node2] or query-based. Traversal: BFS-ordered for predictability. First-class: can be manipulated filtered transformed. Visit path: visit [path_collection] traverse entire path. Edge Abilities: Entry: can ability with WalkerType entry { }. Exit: can ability with WalkerType exit { }. Context: self (edge), visitor (walker), path (queue). Transition computation: logic during node-to-node movement. Auto-queuing: destination node added automatically. Cannot visit: from edge visit statements invalid. Semantic Programming: Docstrings: """description""" enhance AI understanding. Sem keyword: sem Class.attr = "meaning" attribute semantics. Context-rich: more effective than traditional prompts. Domain-specific: tailor AI to specific application contexts. No prompt engineering: function signatures become prompts. Type-guided: return types constrain LLM outputs. Multimodal AI: Image: Image("path.jpg") pass to AI functions. Audio: support for audio files (similar to images). Text: default string processing. Combined: mix text image audio in same function. Vision models: use models like gpt-4-vision-preview. Automatic handling: framework manages encoding formats. Deployment Patterns: Local: jac run file.jac single-user development. Server: jac serve file.jac multi-user API. Docker: containerize with Dockerfile. Kubernetes: YAML templates for k8s deployment. Scale-agnostic: same code local or distributed. Auto-API: walkers become REST endpoints automatically. Database: auto-persistence with root connections. Authentication & Security: Auth spec: static has auth: bool enable/disable. Permissions: role-based access control. JWT tokens: standard bearer token auth. User isolation: per-user root nodes automatic. SSO: single sign-on integration support. API keys: environment variable configuration. Decorators: custom auth decorators supported. Advanced Cloud Features: Environment vars: configure via env or ConfigMap. Logging: structured logs with levels debug info warn error. Webhooks: external service integration. Scheduler: cron-like task scheduling. Background tasks: async job processing. WebSockets: real-time bidirectional. Monitoring: metrics logging health checks. Error Handling: Try-except: try { } except Type as e { }. Raise: raise ErrorType("msg"). Custom exceptions: define custom error classes. Fallback: AI functions can have fallback logic. Validation: type system catches errors early. Retry: decorator patterns for retry logic. Graceful degradation: handle failures cleanly. Testing Patterns: Test files: .test.jac convention. Unit tests: test functions classes. Integration tests: test walkers graph traversal. Mocking: mock AI responses for testing. Fixtures: setup teardown patterns. Assertions: standard Python assertions. Coverage: track code coverage. Performance Optimization: Caching: decorator patterns for memoization. Indexing: graph structure optimization. Lazy evaluation: defer expensive computations. Batch processing: process multiple items together. Async: use async/await for I/O operations. Connection pooling: database connection management. Query optimization: efficient graph queries. Common Patterns: CRUD operations: Create Read Update Delete via walkers. State machines: nodes as states walkers as transitions. Workflow: nodes as steps edges as flow. Social graph: users as nodes relationships as edges. Knowledge graph: concepts as nodes relations as edges. Recommendation: traverse graph for suggestions. Search: walkers traverse to find nodes. Aggregation: walkers collect data from nodes. Debugging: Print debugging: print() statements. Verbose mode: verbose=True in Model config. Logging: structured logging framework. Graph visualization: VS Code extension visualizes graphs. Breakpoints: standard debugger support. Error messages: descriptive type error messages. Stack traces: full Python stack traces. Best Practices: Type annotations: always use types for clarity safety. Separation of concerns: interface vs implementation. Descriptive names: clear function node walker names. Error handling: try-except for robustness. Documentation: docstrings for AI and developers. Testing: write tests for critical paths. Modularity: break large programs into modules. Semantic strings: use sem for AI context. Conventions: File naming: lowercase_with_underscores.jac. Class naming: PascalCase for obj node edge walker. Function naming: snake_case for functions abilities. Constant naming: UPPER_CASE for global constants. Private: prefix with _ for internal use. Entry point: with entry at bottom of main file. Keywords: with entry: program entry point. has: declare attributes in obj/node/edge/walker. can: declare abilities in node/edge/walker. def: define methods functions. impl: implement separated method. glob: global variable. obj: OOP class archetype. node: graph data archetype. edge: relationship archetype. walker: mobile computation archetype. spawn: activate walker. visit: traverse to node/edge. disengage: exit walker. skip: skip current node. report: stream result. sem: semantic string for AI. by: delegate to AI model. `root: root node reference. self: instance reference. here: current location reference (in walker). visitor: visiting walker reference (in node/edge). path: walker queue reference. del: delete edge. async/await: asynchronous execution. match/case: pattern matching. try/except: exception handling. raise: throw exception. import/from: module imports. include: Jac file imports. for/while: loops. if/elif/else: conditionals. return: function return. break/continue: loop control. and/or/not: logical operators. in: membership test. is: identity test. lambda: anonymous function. type: type alias. enum: enumeration. File Operations: Read: standard Python file I/O. Write: standard Python file I/O. Upload: UploadFile type in walkers. Path handling: pathlib or os.path. JSON: import json for JSON handling. CSV: import csv for CSV handling. Config: environment variables ConfigMap. Database: Auto-persistence: nodes/edges rooted to root. Manual save: save(instance) for queue. Commit: commit() flush to DB. Queries: graph queries via edge references. Transactions: implicit with commit. Migrations: handled by framework. Backends: pluggable DB backends. Concurrency: Async functions: async def with await. Asyncio: event loop for async operations. Threading: standard Python threading. Walker parallelism: multiple walkers concurrent. Queue management: walker queues independent. Locking: manual locking if needed for shared state. Monitoring: Logs: structured logging framework. Metrics: custom metrics via logging. Health checks: endpoint health status. Error tracking: exception logging. Performance: timing decorators profiling. Alerts: integrate with monitoring systems. Integration: Python libraries: full Python ecosystem. REST APIs: consume external APIs. Webhooks: receive external events. WebSockets: real-time communication. Message queues: async message processing. Databases: SQLAlchemy or custom. Cloud services: AWS GCP Azure integrations. Lifecycle: Development: jac run for local testing. Testing: jac run tests.jac. Staging: jac serve with test config. Production: Docker/Kubernetes deployment. Monitoring: logs metrics alerts. Updates: rolling deployments zero-downtime. Common Errors: Missing semicolon: statements must end with ;. Missing type annotation: all vars need types. Missing entry block: executable needs with entry. Wrong brackets: use { } not indentation. Type mismatch: strong typing catches errors. Import errors: check module paths. Spawn location: walker spawn needs valid node. Visit from edge: cannot visit from edge position. Queue empty: walker deactivates at empty queue. Scale-Agnostic Philosophy: Write once: code works local or cloud. Root abstraction: per-user persistence automatic. Walker endpoints: auto-generate REST APIs. State management: automatic serialization. Multi-user: user isolation built-in. Distribution: transparent distribution support. Zero config: minimal deployment configuration. Data Spatial Foundation: Traditional: data pulled to computation centralized processing imperative control flow. Data Spatial: computation dispatched to data decentralized processing declarative spatial traversal. Nodes: data containers with computational responsibilities. Edges: typed relationships with traversal semantics. Walkers: mobile code units with execution context. Spatial queries: graph pattern matching with filters. Event-driven: abilities triggered by walker arrivals. Context-aware: self here visitor references provide context. Examples: RAG Chatbot: nodes for documents chunks, walker for query processing, similarity-based retrieval, LLM integration for responses. Task Manager: tasks as nodes, dependencies as edges, walkers for scheduling, priority-based traversal. Social Network: users as nodes, friendships as edges, walkers for feed generation, recommendation algorithms. Fantasy Game: characters locations items as nodes, relationships as edges, walkers for game logic, state persistence. CLI Tools: jac: main entry point. jac run <file>: execute Jac program. jac serve <file>: start API server. jac test <file>: run tests. jac --version: show version. jac --help: show help. Options: --verbose: verbose output. --debug: debug mode. Streamlit Integration: import streamlit as st. Combine Jac graph logic with Streamlit UI. Build interactive dashboards. Visualize graph structures. Deploy with streamlit run. Library Mode: Use Jac as Python library. Import Jac modules in Python: import jac_module. Access Jac classes functions from Python. Hybrid development: Python for general logic, Jac for graph/AI. Flexible integration: choose paradigm per component. VS Code Extension: Syntax highlighting. Code completion. Error detection. Graph visualization. Debugging support. Install: search jaclang-extension in marketplace. Works with Cursor: install .vsix manually. Jac-Lens: Visual graph explorer. Interactive node/edge inspection. Real-time graph updates. Debugging visualization. Development tool for understanding graph state. Jac Playground: Web-based IDE. No installation required. Try Jac in browser. Example programs included. Share code with links. Learning tool for beginners. Jac Book Chapters: Chapter 1: Introduction to Jac, installation, hello world. Chapter 2: Basic syntax, variables, types. Chapter 3: Control flow, loops, conditionals. Chapter 4: Functions, decorators, lambdas. Chapter 5: Objects, classes, inheritance. Chapter 6: Nodes, graph basics, connections. Chapter 7: Edges, typed relationships, properties. Chapter 8: Walkers, traversal, abilities. Chapter 9: Graph queries, filtering, patterns. Chapter 10: Persistence, root, database. Chapter 11: AI integration, byLLM, semantic programming. Chapter 12: Multimodal AI, images, audio. Chapter 13: Cloud deployment, API generation. Chapter 14: Authentication, permissions, security. Chapter 15: Advanced cloud features, webhooks, scheduler. Chapter 16: Testing, debugging, best practices. Chapter 17: Performance optimization, scaling. Chapter 18: Real-world examples, patterns. Chapter 19: Integration with Python ecosystem. Chapter 20: Advanced topics, internals, plugins. Internals: Compiler: multi-pass compilation, AST generation, symbol tables. Symbol Tables: scope management, name resolution, type checking. Type System: static type checking, inference, generic types. Parser: LALR parser, error recovery, syntax tree. Code Generation: Python bytecode target, optimization passes. Plugins: extensible architecture, custom archetypes, language extensions. Plugin System: Plugin interface: extend Jac functionality. Custom archetypes: define new archetype types. Language features: add syntax semantic features. Integration points: hooks for compilation execution. Distribution: PyPI packages for sharing. Documentation: API docs for plugin developers. Breaking Changes: Version 0.x to 1.0: syntax changes, archetype semantics. Migration guide: provided for major versions. Deprecation warnings: advance notice of changes. Backward compatibility: maintained where possible. Changelog: detailed in release notes. Release Notes: Latest features: documented per release. Bug fixes: listed with issue numbers. Performance improvements: benchmarks provided. Known issues: tracked in GitHub. Upgrade instructions: version-specific guidance. Roadmap: Planned features: future language enhancements. Community input: feedback drives priorities. Timelines: estimated release schedules. Experimental features: early access opt-in. Long-term vision: scale-agnostic AI-first programming. Content Pieces: Tutorials: step-by-step guides for common tasks. How-tos: specific problem solutions. Explanations: deep dives into concepts. References: quick lookup for syntax APIs. Videos: screencasts and presentations. Blog posts: announcements case studies. Community Projects: Open source Jac applications. Example implementations. Shared libraries utilities. Contributions welcome. Showcase: featured projects. Learning resources: community-created tutorials. Beginner's Guide: Start with installation setup. Learn basic syntax types. Progress to objects functions. Understand graph concepts nodes edges. Master walkers traversal. Explore AI integration byLLM. Deploy with Jac Cloud. Build real projects. Jac in a Flash: Quick reference: essential syntax. Code snippets: common patterns. Cheat sheet: operators keywords. Visual diagrams: architecture concepts. Printable: PDF format available. Getting Started: Install Python 3.12+. pip install jaclang. Create first.jac file. Write with entry { print("Hello"); }. Run jac run first.jac. Explore examples. Join community Discord Slack. Read documentation. Build projects. Keywords Reference: Complete list: all reserved words. Usage examples: code snippets per keyword. Context: when to use each. Restrictions: what's not allowed. Related: grouped by functionality. Tour: Interactive walkthrough: major features. Hands-on exercises: practice coding. Progressive difficulty: beginner to advanced. Code challenges: test understanding. Certificates: completion badges. Research: Academic papers: published research on Jac. Citations: use in academic work. Benchmarks: performance comparisons. Case studies: real-world deployments. Collaboration: research partnerships welcome. Superset Python: Full Python compatibility: valid Python is valid Jac. Extensions: Jac adds graph AI features. Interoperability: seamless Python integration. Libraries: use any Python package. Migration: easy adoption for Python developers.